'*************************************************************************************************************************
'           Aggregate Agent Library
'	Agent Libarary is the interface for TIDE project to work with Tibbo AggreGate Server,
'	for more details on Agent and AggreGate please visit the website
'	http://aggregate.tibbo.com/docs/
'
'*************************************************************************************************************************

include "global.tbh"

'------------------------------------------------------------------------------

const AGG_STAMP1="AGG("
const AGG_STAMP2=")> "
const AGG_SOCK_GET_SIGNATURE="AGG"
const AGG_COMMAND_START=&h02
const AGG_COMMAND_END=&h0d
const AGG_COMMAND_PARAMETERS_SEPARATOR=&h17
const AGG_ELEMENT_START=&h1c
const AGG_ELEMENT_END=&h1d
const AGG_ELEMENT_NAME_VALUE_SEPARATOR=&h1e
const AGG_NULL=&h1a
const AGG_SCRIPT_FIELD_SEPARATOR=&h9
const AGG_CR_LF=chr(&h0d)+chr(&h0a)
const AGG_INIT_SIGNATURE=&hEF4E
const AGG_TX_BUF_SIZE=2 'AGG_TX_BUFF_PAGES
const AGG_RX_BUF_SIZE=2 'AGG_RX_BUFF_PAGES

const AGG_MSG_TBL_STATUS_FAILURE = "Data disk error."
const AGG_MSG_TBL_STATUS_UNKNOWN_TABLE = "Unknown table."
const AGG_MSG_TBL_STATUS_UNKNOWN_FIELD = "Unknown field."
const AGG_MSG_TBL_STATUS_INVALID = "Field value invalid."
const AGG_MSG_TBL_STATUS_FULL = "Max record number for this table reached or the disk is full."
const AGG_MSG_TBL_STATUS_KEY_VIOLATION = "Key field violation."
const AGG_MSG_STG_STATUS_UNKNOWN="Unknown setting or invalid setting number."
const AGG_MSG_STG_STATUS_FAILURE="Read failure or write failure (checksum error, hardware malfunction, etc.)"
const AGG_MSG_STG_STATUS_INVALID="Invalid setting value."

#if AGG_MAX_ITEM_NAME_LEN>AGG_MAX_COMMAND_NAME_LEN 
	const AGG_ITEM_BUFF_LEN=AGG_MAX_ITEM_NAME_LEN
#else
	const AGG_ITEM_BUFF_LEN=AGG_MAX_COMMAND_NAME_LEN
#endif

#if AGG_MULTI_NODE=0
	#define AGG_MAX_CONTEXT_NAME_LEN 0
#endif
'------------------------------------------------------------------------------

enum en_agg_entity
	EN_AGG_ENTITY_INFO,
	EN_AGG_ENTITY_VARIABLES,
	EN_AGG_ENTITY_FUNCTIONS,
	EN_AGG_ENTITY_EVENTS
end enum

type agg_entity
	context_name as string(AGG_MAX_CONTEXT_NAME_LEN)
	entity_type as en_agg_entity
	romaddr_script as word
end type

type agg_item
	context_name as string(AGG_MAX_CONTEXT_NAME_LEN)
	entity_type as en_agg_entity
	item_name as string(AGG_MAX_ITEM_NAME_LEN)
	p1 as string(2)
	romaddr_script as word
end type

type agg_command
	context_name as string(AGG_MAX_CONTEXT_NAME_LEN)
	code as string(1)
	id as string(8)
	msg_code as string(1)
	op_code as string(1)
	item_name as string(AGG_MAX_COMMAND_NAME_LEN)	
end type

'------------------------------------------------------------------------------

dim agg_entities as agg_entity(AGG_MAX_NUM_ENTITIES)
dim agg_items as agg_item(AGG_MAX_NUM_ITEMS)
dim agg_init_flag as word
dim agg_sock as byte
dim agg_connected as no_yes
dim agg_sychronized as no_yes
dim agg_auto_register as no_yes
dim agg_owner_name as string(32)
dim agg_device_name as string(32)
dim agg_password as string(8)
dim agg_rx as string
dim agg_timer as byte
dim agg_cmd as agg_command
dim agg_start_cmd_recieved as byte
dim agg_selected_tbl_info as string(AGG_MAX_ITEM_NAME_LEN)
dim agg_event_in_proc as no_yes
dim agg_event_item_index as byte
dim agg_cur_event_rec_num as word
dim agg_link_state as en_agg_link_states
dim agg_first_conn_failed as no_yes

'------------------------------------------------------------------------------
declare function agg_get_descriptor_field(line_end_pos as word, byref field_start_pos as word) as string
declare function agg_connect() as en_agg_status_codes
declare sub agg_debug_print_status(status as en_agg_status_codes)
declare sub agg_debugprint(byref print_data as string)
declare sub agg_sock_close()
declare function agg_rx_getdata(byref substr as string) as string
declare sub agg_rx_clr(l as byte)
declare sub agg_send_script()
declare sub agg_get_items()
declare sub agg_data_send(s as string)
declare function agg_element_get(byref element_level as string, byref element_str as string, byref opening_chr as string, byref closing_chr as string ) as string
declare function agg_entity_get(byref s as string) as en_agg_entity
declare sub agg_invisible_separators(byref s as string)
declare sub agg_replace_chr(byref s as string, byref a as string, byref b as string)
declare function agg_call_function(byref op as string ,byref context_name as string, byref func_input as string, byref msg as string) as ok_ng
declare function agg_root_login(byref function_input as string) as string
declare function agg_hex_to_hexstr(byref is as string) as string
declare sub agg_systime_sg(byref date_time as string(23), op as en_agg_rdwr)
declare function agg_modtime_sg(selected_item as agg_item, byref date_time as string, op as en_agg_rdwr) as ok_ng
declare function agg_send_all_record(byref tbl_name as string) as ok_ng

#if AGG_SETTING_CONTROL
	declare function agg_settings_sg(byref setting_name as string, byref setting_val as string, index as byte, rw as en_stg_rdwr) as en_stg_status_codes
	declare function agg_stg_msg(stg_result as en_stg_status_codes) as string
#endif

#if AGG_TABLE_CONTROL
	declare sub agg_date_time_formating(byref td_str as string, tbl_date_time_format as en_tbl_date_time_format, op as en_agg_rdwr)
	declare function agg_tbl_msg(tbl_result as en_tbl_status_codes) as string
	declare function agg_tbl_hash(byref contain as string, byref msg as string)as ok_ng
	declare function agg_tbl_add_record(byref contain as string, byref msg as string)as ok_ng 
	declare function agg_tbl_put_record(byref contain as string, byref msg as string)as ok_ng 
	declare function agg_tbl_update_record(byref contain as string, byref msg as string)as ok_ng 
	declare function agg_tbl_remove_record(byref contain as string, byref msg as string)as ok_ng 
	declare function agg_tbl_start_table(byref contain as string, byref msg as string)as ok_ng 
	declare function agg_tbl_finish_table(byref contain as string, byref msg as string)as ok_ng
#endif

'================================================================================
public function agg_start(interface as pl_sock_interfaces, byref on as string, byref dn as string, byref pw as string, byref agg_server_ip as string, byref agg_server_port as string, agg_server_tout as word, auto_reg as no_yes) as en_agg_status_codes
'API procedure, allocate the sock, and opens the connection to aggregate server
	dim agg_result as en_agg_status_codes
	dim i as word
	
	'check if properly initialized
	if agg_init_flag<>AGG_INIT_SIGNATURE then
		agg_result=agg_init()
		if agg_result<>EN_AGG_STATUS_OK then
			agg_start=agg_result
			exit function
		end if
		agg_init_flag=AGG_INIT_SIGNATURE
	end if
	
	agg_start=EN_AGG_STATUS_OK

	'we only need to obtain a socket once
	if agg_sock>=sock.numofsock then
		agg_sock=sock_get(AGG_SOCK_GET_SIGNATURE)
	end if
	
	if agg_sock>=sock.numofsock then
		#if AGG_DEBUG_PRINT
			agg_debugprint("ERROR: Out of socket.")
		#endif
		agg_start=EN_AGG_STATUS_OUT_OF_SOCKETS
		exit function
	end if
	
	sock.num=agg_sock
	
	'check if already connected to the aggregate server
	if sock.statesimple=PL_SSTS_EST then exit function
	
	sock.allowedinterfaces="WLN,NET,PPP"
	sock.protocol=PL_SOCK_PROTOCOL_TCP
	sock.connectiontout=agg_server_tout
	sock.targetip=agg_server_ip
	sock.targetport=agg_server_port
	
	#if NET_AVAILABLE
		if interface=PL_SOCK_INTERFACE_NET then
			sock.targetinterface=PL_SOCK_INTERFACE_NET
			goto l1
		end if
	#endif
	
	#if WLN_AVAILABLE
		if interface=PL_SOCK_INTERFACE_WLN then
			sock.targetinterface=PL_SOCK_INTERFACE_WLN
			goto l1
		end if
	#endif

	#if SUPPORTS_GPRS
		if interface=PL_SOCK_INTERFACE_PPP then
			sock.targetinterface=PL_SOCK_INTERFACE_PPP
			goto l1
		end if
	#endif

	#if AGG_DEBUG_PRINT
		agg_debug_print_status(EN_AGG_STATUS_INSUFFICIENT_BUFFER_SPACE)
	#endif
	
	agg_start=EN_AGG_STATUS_INVALID_INTERFACE
	exit function 'invalid interface specified

l1:
	agg_connected=YES
	agg_sychronized=NO
	agg_event_in_proc=NO
	agg_event_item_index=0
	agg_cur_event_rec_num=0
	agg_timer=0
	agg_auto_register=auto_reg
	agg_owner_name=on
	agg_device_name=dn
	agg_password=pw
	agg_rx=""
	agg_selected_tbl_info=""
	agg_first_conn_failed=NO
	agg_start=agg_connect()
	i=sys.timercount
	while sock.statesimple<>PL_SSTS_EST and sys.timercount-i<3 and sys.timercount>=i
	wend	
	if sock.statesimple<>PL_SSTS_EST then agg_first_conn_failed=YES	
end function

'-------------------------------------------------------------
public function agg_init() as en_agg_status_codes
'API procedure, initialize the aggregate agent library, parses the descriptor file, checks compilation options, and exams the memory usage.

	dim i, j, line_end, field_start_pos as word
	dim agg_entity_index, agg_item_index, b, context_name_len, item_name_len as byte
	dim s as string
	dim agg_temp_entity as agg_entity
	dim agg_temp_item as agg_item
	
	agg_init=EN_AGG_STATUS_OK
	agg_sock=255
	agg_link_state=EN_AGG_LINK_STATE_IDLE
	
	#if AGG_DEBUG_PRINT
		agg_debugprint("---START---")
	#endif
	
	'varify all #defines
	if AGG_MAX_ITEM_NAME_LEN<1 or AGG_MAX_ITEM_NAME_LEN>255 then
		#if	AGG_DEBUG_PRINT
			agg_debugprint("ERROR: AGG_MAX_ITEM_NAME_LEN must be between 1 and 255, you now have '#AGG_MAX_ITEM_NAME_LEN "+str(AGG_MAX_ITEM_NAME_LEN)+"'.")
		#endif
		agg_entity_index=0
		agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
		exit function
	end if

	if AGG_MAX_NUM_ENTITIES<2 or AGG_MAX_NUM_ENTITIES>255 then
		#if	AGG_DEBUG_PRINT
			agg_debugprint("ERROR: AGG_MAX_NUM_ENTITIES must be between 2 and 255, you now have '#AGG_MAX_NUM_ENTITIES "+str(AGG_MAX_NUM_ENTITIES)+"'.")
		#endif
		agg_entity_index=0
		agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
		exit function
	end if
	
	if AGG_MAX_NUM_ITEMS>255 then
		#if	AGG_DEBUG_PRINT
			agg_debugprint("ERROR: AGG_MAX_NUM_ITEMS must be between 0 and 255, you now have '#AGG_MAX_NUM_ITEMS "+str(AGG_MAX_NUM_ITEMS)+"'.")
		#endif
		agg_entity_index=0
		agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
		exit function
	end if	

	if AGG_MAX_NUM_EVENT_FIELDS<1 or AGG_MAX_NUM_EVENT_FIELDS>255 then
		#if	AGG_DEBUG_PRINT
			agg_debugprint("ERROR: AGG_MAX_NUM_EVENT_FIELDS must be between 1 and 255, you now have '#AGG_MAX_NUM_EVENT_FIELDS "+str(AGG_MAX_NUM_EVENT_FIELDS)+"'.")
		#endif
		agg_entity_index=0
		agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
		exit function
	end if
	
	if AGG_MAX_EVENT_FIELD_VAL_LEN<1 or AGG_MAX_EVENT_FIELD_VAL_LEN>255 then
		#if	AGG_DEBUG_PRINT
			agg_debugprint("ERROR: AGG_MAX_EVENT_FIELD_VAL_LEN must be between 1 and 255, you now have '#AGG_MAX_EVENT_FIELD_VAL_LEN "+str(AGG_MAX_EVENT_FIELD_VAL_LEN)+"'.")
		#endif
		agg_entity_index=0
		agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
		exit function
	end if
	
	agg_entity_index=0
	agg_item_index=0
	context_name_len=0
	item_name_len=12
	
	'read descriptor file
	romfile.open(AGG_DESCRIPTOR_FILE)				'this file is a table descriptor file
	if romfile.size=0 then
		#if AGG_DEBUG_PRINT
			agg_debugprint("ERROR: '"+AGG_DESCRIPTOR_FILE+"' is not in your project or file is empty.")
		#endif
		agg_entity_index=0 'table descriptor file is not in your project (or file is empty)
		agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
		exit function
	end if
	
	i=romfile.find(romfile.pointer,"==",1)
	while i<>0	
		'we are now at the "==" pointing at the beginning of one table descriptor line
		romfile.pointer=i+2
		
		'find the end of this table descriptor line
		line_end=romfile.find(romfile.pointer,AGG_CR_LF,1)
		if line_end=0 then
			line_end=romfile.size+1
		end if

		'extract entity type
		s=agg_get_descriptor_field(line_end,field_start_pos)
		if s="" then
			'missing entity type field
			#if AGG_DEBUG_PRINT
				agg_debugprint("ERROR (entity #"+str(agg_entity_index)+"'): entity type field not found (entity are counted from 0).")
			#endif
			agg_entity_index=0
			agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
			exit function
		end if
		
		agg_temp_entity.entity_type=agg_entity_get(s)
		if s="" then 
			#if AGG_DEBUG_PRINT
				agg_debugprint("ERROR (entity #"+str(agg_entity_index)+"'): cannot recongize the entity type.")
			#endif
			agg_entity_index=0
			agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
			exit function		
		end if
		'extract context name
		s=agg_get_descriptor_field(line_end,field_start_pos)
		if s="" then
			'missing context name field
			#if AGG_DEBUG_PRINT
				agg_debugprint("ERROR (entity #"+str(agg_entity_index)+"'): context name field not found (entity are counted from 0).")
			#endif
			agg_entity_index=0
			agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
			exit function
		end if
		
		if s="root" then s =""
		b=len(s)		
		if b>AGG_MAX_CONTEXT_NAME_LEN then
			#if AGG_DEBUG_PRINT
				agg_debugprint("ERROR (entity #"+str(agg_entity_index)+"'): context name length is "+str(len(s))+", while you have 'AGG_MAX_CONTEXT_NAME_LEN "+str(AGG_MAX_CONTEXT_NAME_LEN)+"'.")
			#endif
			agg_entity_index=0
			agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
			exit function
		end if
		agg_temp_entity.context_name=s
		
		if b>context_name_len then context_name_len=b
		
		'extract romaddr of the script
		s=agg_get_descriptor_field(line_end,field_start_pos)
		
		if s="" then
			romfile.pointer=line_end
			agg_temp_entity.romaddr_script=romfile.pointer
		else
			agg_temp_entity.romaddr_script=field_start_pos
		end if		
		
		i=romfile.find(romfile.pointer,"==",1)
		j=romfile.find(romfile.pointer,AGG_CR_LF+">>",1)+2

		while (j>2 and j<i) or (i=0 and j>2)
			romfile.pointer=j+2
			
			agg_temp_item.entity_type=agg_temp_entity.entity_type
			agg_temp_item.context_name=agg_temp_entity.context_name
			
			'find the end of this table descriptor line
			line_end=romfile.find(romfile.pointer,AGG_CR_LF,1)
			if line_end=0 then
				line_end=romfile.size+1
			end if

			'extract item name
			s=agg_get_descriptor_field(line_end,field_start_pos)
			if s="" then
				'missing item name field
				#if AGG_DEBUG_PRINT
					agg_debugprint("ERROR (item #"+str(agg_item_index)+"'): item name field not found (item are counted from 0).")
				#endif
				agg_item_index=0
				agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
				exit function
			end if
			
			b=len(s)
			if b>AGG_MAX_ITEM_NAME_LEN then
				#if AGG_DEBUG_PRINT
					agg_debugprint("ERROR (item #"+str(agg_item_index)+"'): item name length is "+str(len(s))+", while you have 'AGG_MAX_ITEM_NAME_LEN "+str(AGG_MAX_ITEM_NAME_LEN)+"'.")
				#endif
				agg_item_index=0
				agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
				exit function
			end if
			if b>item_name_len then item_name_len=b
			agg_temp_item.item_name=s
			
			if agg_temp_item.entity_type<>EN_AGG_ENTITY_FUNCTIONS then
				'extract parameter romaddr
				s=agg_get_descriptor_field(line_end,field_start_pos)
				if s="" then
					'missing parameter field
					#if AGG_DEBUG_PRINT
						agg_debugprint("ERROR (item #"+str(agg_item_index)+"'): item paramter field not found (item are counted from 0).")
					#endif
					agg_item_index=0
					agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
					exit function
				end if	
				agg_temp_item.p1=s
			else
				agg_temp_item.p1=""
			end if
			
			'extract script romaddr
			s=agg_get_descriptor_field(line_end,field_start_pos)
			if s="" then
				'missing item script
				#if AGG_DEBUG_PRINT
					agg_debugprint("ERROR (item #"+str(agg_item_index)+"'): item script not found (item are counted from 0).")
				#endif
				agg_item_index=0
				agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
				exit function
			end if			
			agg_temp_item.romaddr_script=field_start_pos

			if agg_item_index<AGG_MAX_NUM_ITEMS then
				agg_items(agg_item_index)=agg_temp_item			
			end if
			
			j=romfile.find(field_start_pos,AGG_CR_LF+">>",1)+2
			agg_item_index=agg_item_index+1
		wend
		
		if agg_entity_index<AGG_MAX_NUM_ENTITIES then
			agg_entities(agg_entity_index)=agg_temp_entity
		end if
		agg_entity_index=agg_entity_index+1
	wend
	
	if agg_item_index>AGG_MAX_NUM_ITEMS then
		#if AGG_DEBUG_PRINT
			agg_debugprint("ERROR: total number of items is "+str(agg_item_index)+" while you have 'AGG_MAX_NUM_ITEMS "+str(AGG_MAX_NUM_ITEMS)+"'.")
		#endif
		agg_item_index=0
		agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
		exit function
	end if	
	
	if agg_entity_index>AGG_MAX_NUM_ENTITIES then
		#if AGG_DEBUG_PRINT
			agg_debugprint("ERROR: total number of entities is "+str(agg_entity_index)+" while you have 'AGG_MAX_NUM_ENTITIES "+str(AGG_MAX_NUM_ENTITIES)+"'.")
		#endif
		agg_entity_index=0
		agg_init=EN_AGG_STATUS_WRONG_DESCRIPTOR
		exit function
	end if

	'check for memory wastage
	#if AGG_DEBUG_PRINT	
		if context_name_len<AGG_MAX_CONTEXT_NAME_LEN then
			agg_debugprint("YOU ARE WASTING MEMORY!!! Set AGG_MAX_CONTEXT_NAME_LEN to "+str(context_name_len)+". It is now "+str(AGG_MAX_CONTEXT_NAME_LEN)+".")
		end if
		
		if item_name_len<AGG_MAX_ITEM_NAME_LEN then
			agg_debugprint("YOU ARE WASTING MEMORY!!! Set AGG_MAX_ITEM_NAME_LEN to "+str(item_name_len)+". It is now "+str(AGG_MAX_ITEM_NAME_LEN)+".")
		end if
		
		if agg_item_index<AGG_MAX_NUM_ITEMS then
			agg_debugprint("YOU ARE WASTING MEMORY!!! Set AGG_MAX_NUM_ITEMS to "+str(agg_item_index)+". It is now "+str(AGG_MAX_NUM_ITEMS)+".")
		end if
		
		if agg_entity_index<AGG_MAX_NUM_ENTITIES then
			agg_debugprint("YOU ARE WASTING MEMORY!!! Set AGG_MAX_NUM_ENTITIES to "+str(agg_entity_index)+". It is now "+str(AGG_MAX_NUM_ENTITIES)+".")
		end if
	#endif
	agg_init_flag=AGG_INIT_SIGNATURE
	
end function

'------------------------------------------------------------------------------
public sub agg_stop()
'API procedure, close the aggregate server connection, and release the buffer.

	if agg_init_flag<>AGG_INIT_SIGNATURE then exit sub
	
	#if AGG_DEBUG_PRINT
		agg_debugprint("---STOP---")
	#endif

	#if AGG_LOGIN_CONTROL
		logout()
	#endif
	agg_sock_close()
	agg_connected=NO
	agg_sychronized=NO
	agg_first_conn_failed=NO
	sock.num=agg_sock
	sock.rxbuffrq(0)
	sock.txbuffrq(0)
	sys.buffalloc
	callback_agg_buff_released()	
end sub

'------------------------------------------------------------------------------
public sub agg_proc_timer()
'API procedure, timer events for the aggregate, check the connection periodically, and process the stored event.

	dim pw as string
	dim b as byte

	if agg_init_flag<>AGG_INIT_SIGNATURE then exit sub
	
	if agg_connected=NO then exit sub
	sock.num=agg_sock
	select case sock.statesimple
	case PL_SSTS_CLOSED:
		#if AGG_LOGIN_CONTROL
			'aggregate server does not have a logout procedure. logout has to be controled by device, connection is cut only when device logout from AGG mode.
			if login_mode<>CMD_MODE_AGGREGATE and agg_first_conn_failed<>YES then exit sub
		#endif
		if agg_timer>0 then agg_timer=agg_timer-1
		if agg_timer=0 then
			agg_rx=""
			agg_connect()
			b=asc(random(1))
			agg_timer=b mod AGG_WAIT_TIME
		end if

	case PL_SSTS_EST:
		#if AGG_LOGIN_CONTROL
			dim comp_result as login_comparison_codes
			comp_result=compare_logins(CMD_MODE_AGGREGATE,pw,agg_sock)
			if comp_result=LC_WILL_REJECT_HIGHER_IN_PROGRESS then
				agg_stop()
			end if
			agg_first_conn_failed=NO
		#endif
		#if AGG_TABLE_CONTROL
			agg_check_stored_events()
		#endif
	end select	
end sub

'------------------------------------------------------------------------------
public sub agg_proc_sock_event(sock_state as pl_sock_state, sock_state_simple as pl_sock_state_simple)
'API procedure, when connection established, set the reconnect timer to a random value. When connection closes, reset the agg_sychronized flag.

	dim b as byte

	if sock.num<>agg_sock then exit sub
	if agg_init_flag<>AGG_INIT_SIGNATURE then exit sub
	
	select case sock_state_simple
	case PL_SSTS_EST:
		b=asc(random(1))
		agg_timer=b mod AGG_WAIT_TIME
		
		#if AGG_LOGIN_CONTROL
			login(CMD_MODE_AGGREGATE,"",agg_sock)
		#endif
	
		#if AGG_DEBUG_PRINT
			agg_debugprint("connection established")
		#endif
		
		agg_link_state=EN_AGG_LINK_STATE_SYNCRONIZING
	case PL_SSTS_CLOSED:
		agg_sychronized=NO
		agg_link_state=EN_AGG_LINK_STATE_DISCONNECTED
		callback_agg_error(EN_AGG_STATUS_CONNECTION_LOST,"")
		#if AGG_DEBUG_PRINT
			agg_debug_print_status(EN_AGG_STATUS_CONNECTION_LOST)
		#endif
	end select
end sub

'------------------------------------------------------------------------------
public sub agg_proc_data()
'API procedure, process commands from AggreGate server.

	dim pos1, pos2, l as byte
	dim item_name_temp as string(AGG_ITEM_BUFF_LEN)
	dim stemp1,stemp2 as string
	dim num_agc as byte
	dim romaddr_start, romaddr_end, romaddr_mid as word
	dim err,head_found as no_yes
	dim i,stg_num as byte
	
	if sock.num<>agg_sock then exit sub
	if agg_init_flag<>AGG_INIT_SIGNATURE then exit sub
	if agg_connected=NO then exit sub
	
	head_found=NO
	romfile.open(AGG_DESCRIPTOR_FILE)
proc_data:		
	agg_rx_getdata("")
	if agg_rx="" then exit sub
	pos1=instr(1,agg_rx,chr(AGG_COMMAND_START),1)
	agg_rx_getdata(chr(AGG_COMMAND_START))
	if pos1>0 then
		head_found=YES
		goto proc_data
	else
		if len(agg_rx)=255 then 
			if head_found=NO then
				agg_rx=""
				exit sub
			else
				goto proc_cmd
			end if
		end if
	end if

	'process command
proc_cmd:
	stemp1=agg_rx_getdata(chr(AGG_COMMAND_PARAMETERS_SEPARATOR))
	if stemp1<>"" then
		agg_cmd.code=stemp1
	else
		goto proc_data
	end if

	stemp1=agg_rx_getdata(chr(AGG_COMMAND_PARAMETERS_SEPARATOR))
	if stemp1<>"" then
		agg_cmd.id=stemp1
	else
		goto proc_data
	end if
	
	stemp1=agg_rx_getdata(chr(AGG_COMMAND_PARAMETERS_SEPARATOR))
	if stemp1<>"" then
		agg_cmd.msg_code=stemp1
		select case agg_cmd.msg_code
		case "S":
			agg_start_cmd_recieved=agg_start_cmd_recieved+1
			stemp2=chr(AGG_COMMAND_START)+"R"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_cmd.id+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(AGG_COMMAND_END)
			agg_data_send(stemp2)
			if agg_start_cmd_recieved>1 then 			 'start command is recieved more than once consecutively. command is out of sync
				agg_start_cmd_recieved=0
				agg_rx=""
				agg_sock_close()
			else
				pos2=instr(1,agg_rx,chr(AGG_COMMAND_END),1)
				agg_rx_clr(pos2)				
			end if
			exit sub
		case "O":
			agg_start_cmd_recieved=0
		end select
	else
		goto proc_data
	end if
		
	stemp1=agg_rx_getdata(chr(AGG_COMMAND_PARAMETERS_SEPARATOR))
	if stemp1<>"" then
		agg_cmd.op_code=stemp1
	else
		goto proc_data
	end if

	stemp1=agg_rx_getdata(chr(AGG_COMMAND_PARAMETERS_SEPARATOR))
	agg_cmd.context_name=stemp1
	
	select case agg_cmd.op_code
	case "S":
		stemp1=agg_rx_getdata(chr(AGG_COMMAND_PARAMETERS_SEPARATOR))
	case "G":
		stemp1=agg_rx_getdata(chr(AGG_COMMAND_END))
	case "C":
		stemp1=agg_rx_getdata(chr(AGG_COMMAND_PARAMETERS_SEPARATOR))		
	end select
	
	if stemp1<>"" then
		agg_cmd.item_name=stemp1
	else
		goto proc_data
	end if

	select case agg_cmd.op_code
	case "G":
		agg_rx_getdata(chr(AGG_COMMAND_END))
		stemp2=chr(AGG_COMMAND_START)+"R"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_cmd.id+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)
		agg_data_send(stemp2)
		agg_get_items()
		exit sub
	case "S":
	
rx_read:		
		stemp2=agg_element_get("1",agg_rx,chr(AGG_ELEMENT_START),chr(AGG_ELEMENT_END))
		stemp1=chr(AGG_ELEMENT_START)+"R"+chr(AGG_ELEMENT_NAME_VALUE_SEPARATOR)
		pos1=instr(1,agg_rx,stemp1,1)
		agg_rx_clr(pos1+len(stemp2))
		
		if pos1>0 then
			select case agg_cmd.item_name
			case "date":		'set date				
				stemp2=agg_element_get("11",stemp2,chr(AGG_ELEMENT_START),chr(AGG_ELEMENT_END))
				stemp2=mid(stemp2,2,len(stemp2)-2)
				agg_systime_sg(stemp2,EN_AGG_SET)
				
			case "modtime":		'set modification time
				do
					stemp1=agg_element_get("11",stemp2,chr(AGG_ELEMENT_START),chr(AGG_ELEMENT_END))
					item_name_temp=mid(stemp1,2,len(stemp1)-2)
					stemp1=agg_element_get("12",stemp2,chr(AGG_ELEMENT_START),chr(AGG_ELEMENT_END))
					stemp1=mid(stemp1,2,len(stemp1)-2)

					for i=0 to AGG_MAX_NUM_ITEMS-1
						if agg_items(i).entity_type=EN_AGG_ENTITY_VARIABLES and agg_cmd.context_name=agg_items(i).context_name and agg_items(i).item_name=item_name_temp then
							agg_modtime_sg(agg_items(i),stemp1,EN_AGG_SET)
						end if
					next i

					stemp2=agg_element_get("1",agg_rx,chr(AGG_ELEMENT_START),chr(AGG_ELEMENT_END))
					stemp1=chr(AGG_ELEMENT_START)+"R"+chr(AGG_ELEMENT_NAME_VALUE_SEPARATOR)
					pos1=instr(1,agg_rx,stemp1,1)
					agg_rx_clr(pos1+len(stemp2))
				loop while pos1>0
				
			case "children","events":
				stemp1=agg_element_get("11",stemp2,chr(AGG_ELEMENT_START),chr(AGG_ELEMENT_END))
				stemp1=mid(stemp1,2,len(stemp1)-2)
				
			case else
				#if AGG_SETTING_CONTROL
					'cases setting modifications
					dim stg_result as en_stg_status_codes
					
					stg_get_num_members(agg_cmd.item_name,stg_num)	'get number of settings
					
					for i=0 to stg_num-1
						stemp1=agg_element_get("1"+str(i+1),stemp2,chr(AGG_ELEMENT_START),chr(AGG_ELEMENT_END))
						stemp1=mid(stemp1,2,len(stemp1)-2)
						stg_result=agg_settings_sg(agg_cmd.item_name,stemp1,i,EN_AGG_SET)
						if stg_result<>EN_STG_STATUS_OK then exit for
					next i
					if stg_result<>EN_STG_STATUS_OK then
						stemp2=agg_stg_msg(stg_result)
						stemp2=chr(AGG_COMMAND_START)+"R"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_cmd.id+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"E"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+stemp2+chr(AGG_COMMAND_END)
						callback_agg_error(EN_AGG_STATUS_SETTING_ERROR,agg_cmd.item_name)
						callback_agg_stg_error(agg_cmd.item_name,stg_result)
						agg_data_send(stemp2)
						
						#if AGG_DEBUG_PRINT
							stemp1="setting name: "+agg_cmd.item_name+" index: "+str(i)
							agg_debugprint(stemp1)						
							agg_debug_print_status(EN_AGG_STATUS_SETTING_ERROR)						
						#endif					
						exit sub
					end if
				#endif
			end select
		else
			if len(stemp2)>254 then goto rx_read
			exit sub
		end if
		stemp2=chr(AGG_COMMAND_START)+"R"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_cmd.id+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(AGG_COMMAND_END)
		agg_data_send(stemp2)
		exit sub						
	case "C":	
		stemp1=agg_element_get("1",agg_rx,chr(AGG_ELEMENT_START),chr(AGG_ELEMENT_END))
		if agg_call_function(agg_cmd.item_name,agg_cmd.context_name,stemp1, stemp2)=OK then
			stemp2=chr(AGG_COMMAND_START)+"R"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_cmd.id+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+stemp2+chr(AGG_COMMAND_END)
		else
			stemp2=chr(AGG_COMMAND_START)+"R"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_cmd.id+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"E"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+stemp2+chr(AGG_COMMAND_END)
			callback_agg_error(EN_AGG_STATUS_FUNCTION_ERROR,agg_cmd.item_name)
			#if AGG_DEBUG_PRINT
				stemp1="function: "+agg_cmd.item_name
				agg_debug_print_status(EN_AGG_STATUS_FUNCTION_ERROR)
				agg_debugprint(stemp1)
			#endif								
		end if
		agg_data_send(stemp2)
		agg_data_send(chr(AGG_COMMAND_END))
		exit sub
	end select
end sub

'------------------------------------------------------------------------------
public sub agg_add_instant_events(byref context_name as string, byref event_name as string, byref instant_event_buff as agg_instant_event_buffer, num_of_fields as byte)
'API procedure, process the aggregate instant event.  The user need to prepare the event data and put them into instant_event_buff first.
'instant_event_buff is an arrary of string, all fields of the instant event should be in readable string form.

	dim s as string
	dim stemp1 as string(8)
	dim i, j as byte
	dim rec_num as word
	
	if agg_sychronized=NO then exit sub

	for i=0 to AGG_MAX_NUM_ITEMS-1
		if context_name=agg_items(i).context_name and event_name=agg_items(i).item_name and agg_items(i).entity_type=EN_AGG_ENTITY_EVENTS and left(agg_items(i).p1,1)="I" then
			stemp1=agg_items(i).context_name
			s=chr(AGG_COMMAND_START)+"M"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"E"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+stemp1+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_items(i).item_name+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+right(agg_items(i).p1,1)+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+chr(AGG_ELEMENT_START)+"R"+chr(AGG_ELEMENT_NAME_VALUE_SEPARATOR)
			for j=0 to num_of_fields-1
				s=s+chr(AGG_ELEMENT_START)+instant_event_buff.field_value(j)+chr(AGG_ELEMENT_END)
			next j
			
			s=s+chr(AGG_ELEMENT_END)+chr(AGG_COMMAND_END)
			agg_data_send(s)
		end if
	next i	
end sub

'------------------------------------------------------------------------------
#if AGG_TABLE_CONTROL
public sub agg_proc_data_sent()
'API procedure, delete the stored event from the table, once the server confirm the arrival of the event.

	if agg_event_in_proc<>YES then exit sub
	if left(agg_items(agg_event_item_index).p1,1)="S" then
		tbl_select(agg_items(agg_event_item_index).item_name,agg_items(agg_event_item_index).item_name)
		tbl_record_delete(agg_cur_event_rec_num)
		agg_modtime_sg(agg_items(agg_event_item_index),"",EN_AGG_SET)
	end if
	agg_event_in_proc=NO
	agg_event_item_index=agg_event_item_index+1
end sub

'------------------------------------------------------------------------------
public sub agg_check_stored_events()
'API procedure, process events, and send them to aggregate server.  It is called from the agg_proc_timer() for more instant effect, user can also call this function whenever a new event is added to the table.

	dim s as string 
	dim stemp1 as string(64)
	dim j as byte
	dim rec_num as word
	dim tbl_result as en_tbl_status_codes
	dim num_of_field as byte
	dim fld_temp as tbl_field_type
	
	if agg_init_flag<>AGG_INIT_SIGNATURE then
		exit sub
	end if
	
	if agg_sychronized=NO or agg_event_in_proc=YES then exit sub

	sock.num=agg_sock
	if sock.statesimple=PL_SSTS_CLOSED then exit sub
	
	#if AGG_TABLE_CONTROL=0
		#if AGG_DEBUG_PRINT
			agg_debugprint("Table control has been disabled, it's not possible to process any strored events")
		#endif
		exit sub
		
	#else
	
	'---------- look for events ------------
		for j=agg_event_item_index to AGG_MAX_NUM_ITEMS-1
			if agg_items(j).entity_type=EN_AGG_ENTITY_EVENTS and left(agg_items(j).p1,1)="S" then
				agg_event_item_index=j
				exit for
			end if
		next j
		if j=AGG_MAX_NUM_ITEMS then 
			agg_event_item_index=0
			exit sub
		end if
		
		rec_num=1
		
		tbl_result=tbl_select(agg_items(agg_event_item_index).item_name,agg_items(agg_event_item_index).item_name)
		if tbl_result<>EN_TBL_STATUS_OK then
			goto error
		end if
		
		tbl_result=tbl_record_find(EN_TBL_RECORD_ACTIVE,"","",rec_num,EN_TBL_SEARCH_DOWN,PL_FD_FIND_EQUAL)
		if tbl_result<>EN_TBL_STATUS_OK and tbl_result<>EN_TBL_STATUS_NOT_FOUND then
			goto error
		end if
		if tbl_result=EN_TBL_STATUS_NOT_FOUND then exit sub
		
		tbl_result=tbl_record_sg(rec_num,EN_TBL_GET)
		if tbl_result<>EN_TBL_STATUS_OK and tbl_result<>EN_TBL_STATUS_NOT_FOUND then	
			goto error
		end if

		num_of_field=tbl_get_num_fields(agg_items(agg_event_item_index).item_name)
		for j=0 to num_of_field-1
			tbl_get_field_info(agg_items(agg_event_item_index).item_name,j,fld_temp)
			tbl_result=tbl_field_sg(fld_temp.field_name,stemp1,EN_TBL_GET)
			if tbl_result<>EN_TBL_STATUS_OK then
				callback_agg_error(EN_AGG_STATUS_TABLE_ERROR,agg_items(agg_event_item_index).item_name)
				callback_agg_tbl_error(agg_items(agg_event_item_index).item_name,tbl_result)			
				goto error
			end if
			callback_agg_tbl_fld_mod_sg(agg_items(agg_event_item_index).item_name,fld_temp.field_name,stemp1,EN_AGG_GET)
			if fld_temp.field_type=`T` then
				agg_date_time_formating(stemp1,fld_temp.p1,EN_AGG_GET)
				if stemp1="" then
					tbl_result=EN_TBL_STATUS_INVALID
error:			
					callback_agg_error(EN_AGG_STATUS_TABLE_ERROR,agg_items(agg_event_item_index).item_name)
					callback_agg_tbl_error(agg_items(agg_event_item_index).item_name,tbl_result)
					exit sub
				end if
			end if
			s=s+chr(AGG_ELEMENT_START)+stemp1+chr(AGG_ELEMENT_END)
		next j
		
		stemp1=agg_items(agg_event_item_index).context_name
		s=chr(AGG_COMMAND_START)+"M"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"E"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+stemp1+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_items(agg_event_item_index).item_name+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+right(agg_items(agg_event_item_index).p1,1)+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+chr(AGG_ELEMENT_START)+"R"+chr(AGG_ELEMENT_NAME_VALUE_SEPARATOR)+s+chr(AGG_ELEMENT_END)+chr(AGG_COMMAND_END)
		agg_data_send(s)
		sock.notifysent(0) 
		agg_event_in_proc=yes
		agg_cur_event_rec_num=rec_num
	#endif
end sub
#endif

'------------------------------------------------------------------------------
public sub agg_get_connection_state(byref link_state as en_agg_link_states, byref sock_state as pl_sock_state_simple)
	
	if agg_init_flag<>AGG_INIT_SIGNATURE then
		sock_state=PL_SSTS_CLOSED
		link_state=EN_AGG_LINK_STATE_IDLE
	else
		sock.num=agg_sock
		sock_state=sock.statesimple
		link_state=agg_link_state
	end if
end sub

'------------------------------------------------------------------------------
function agg_connect() as en_agg_status_codes
	dim x as byte
	
	if agg_init_flag<>AGG_INIT_SIGNATURE then
		agg_connect=EN_AGG_STATUS_NOT_STARTED
		exit function
	end if
	
	agg_connect=EN_AGG_STATUS_OK
	if agg_connected<>YES then exit function
	
	sock.num=agg_sock
	if sock.statesimple=PL_SSTS_EST then exit function
	
	'arrange buffer space
	if sock.rxbuffsize<AGG_RX_BUF_SIZE or sock.txbuffsize<AGG_TX_BUF_SIZE then
		sock.rxbuffrq(0)
		sock.txbuffrq(0)
		sys.buffalloc()

		if sys.freebuffpages<AGG_RX_BUF_SIZE+AGG_TX_BUF_SIZE then
			x=sys.freebuffpages-AGG_RX_BUF_SIZE-AGG_TX_BUF_SIZE
			callback_agg_pre_buffrq(x)
		end if
	
		sock.rxbuffrq(AGG_RX_BUF_SIZE)
		sock.txbuffrq(AGG_TX_BUF_SIZE)
		sys.buffalloc()
		
		if sock.rxbuffsize<AGG_RX_BUF_SIZE*256-17 or sock.txbuffsize<AGG_TX_BUF_SIZE*256-17 then
			#if AGG_DEBUG_PRINT
				agg_debug_print_status(EN_AGG_STATUS_INSUFFICIENT_BUFFER_SPACE)
			#endif
			agg_connect=EN_AGG_STATUS_INSUFFICIENT_BUFFER_SPACE
			exit function
		end if
	end if

	agg_link_state=EN_AGG_LINK_STATE_CONNECTING
	sock.connect()
end function

'----------------------------------------------------------------------------
sub agg_sock_close()
	dim i as word
	
	sock.num=agg_sock
	i=sys.timercount
	sock.close
	while sock.statesimple<>PL_SSTS_CLOSED and sys.timercount-i<3 and sys.timercount>=i
	wend
	if sock.statesimple=PL_SSTS_EST then sock.discard
end sub

'------------------------------------------------------------------------------
function agg_rx_getdata(byref substr as string) as string
	dim x as byte
	dim s as string
	
	sock.num=agg_sock
	s=sock.getdata(255-len(agg_rx))
	
	agg_rx=agg_rx+s
	x=instr(1,agg_rx,substr,1)
	if x>0 then
		agg_rx_getdata=left(agg_rx,x-1)
		agg_rx=right(agg_rx,len(agg_rx)-x)
	else
		agg_rx_getdata=""
	end if
end function

'-------------------------------------------------------------
function agg_get_descriptor_field(line_end_pos as word, byref field_start_pos as word) as string
'line_end_pos is an INPUT parameter, field_start_pos RETURNS the field position 
	dim i,w as word
	
	do
		if romfile.pointer>=line_end_pos then
			'the field is missing
			agg_get_descriptor_field=""
			field_start_pos=0
			exit function
		end if
		
		i=romfile.find(romfile.pointer,chr(AGG_SCRIPT_FIELD_SEPARATOR),1)
		field_start_pos=romfile.pointer
		if i=0 or i>line_end_pos then
			'no next field separator found on this line, so we assume the field goes to the end of the line
			i=line_end_pos
			w=i-romfile.pointer
			if w>255 then goto proc_long_string
			agg_get_descriptor_field=romfile.getdata(w)
			romfile.pointer=line_end_pos+1
		else
			w=i-romfile.pointer
			if w>255 then goto proc_long_string
			agg_get_descriptor_field=romfile.getdata(w)
			romfile.pointer=i+1
		end if
	loop while agg_get_descriptor_field=""
	exit function
proc_long_string:	
	w=255
	agg_get_descriptor_field=romfile.getdata(w)
end function

'------------------------------------------------------------------------------
sub agg_send_script()
	dim i, j as byte
	dim s as string
	dim line_end, next_line, item_end, k, w as word
	
	for i=0 to AGG_MAX_NUM_ENTITIES-1
		if agg_entity_get(agg_cmd.item_name)=agg_entities(i).entity_type and agg_cmd.context_name=agg_entities(i).context_name then
		
			'find the end of this descriptor line
			romfile.open(AGG_DESCRIPTOR_FILE)
			romfile.pointer=agg_entities(i).romaddr_script

			line_end=romfile.find(romfile.pointer,AGG_CR_LF,1)
			if line_end=0 then
				line_end=romfile.size+1
			end if
			
			'extract descriptor line
			s=agg_get_descriptor_field(line_end,w)
			if s<>"" then 
				agg_invisible_separators(s)
				agg_data_send(s)
			end if
			
			'find the end of current item
			item_end=romfile.find(romfile.pointer,"==",1)
			if item_end=0 then
				item_end=romfile.size+1
			end if
			
			'find next line of current item
			next_line=romfile.find(romfile.pointer,"~~",1)
			k=romfile.find(romfile.pointer,AGG_CR_LF+">>",1)
			
			if k=0 or k>item_end then k=item_end
			
			while next_line>0 and next_line<item_end and next_line<k
				romfile.pointer=next_line+2
				
				'find the end of this table descriptor line
				line_end=romfile.find(romfile.pointer,AGG_CR_LF,1)
				if line_end=0 then
					line_end=romfile.size+1
				end if

send_script1:
				s=agg_get_descriptor_field(line_end,w)
				agg_invisible_separators(s)
				agg_data_send(s)
				if len(s)=255 then goto send_script1
				next_line=romfile.find(romfile.pointer,"~~",1)
			wend
sub_item:
			'find sub item
			for j=0 to AGG_MAX_NUM_ITEMS-1
				if agg_entity_get(agg_cmd.item_name)=agg_items(j).entity_type and agg_cmd.context_name=agg_items(j).context_name then
					next_line=agg_items(j).romaddr_script
					k=romfile.find(next_line,AGG_CR_LF+">>",1)
					while next_line>0 and next_line<item_end and (next_line<k or k=0)
						romfile.pointer=next_line
						
						'find the end of this table descriptor line
						line_end=romfile.find(romfile.pointer,AGG_CR_LF,1)
						if line_end=0 then
							line_end=romfile.size+1
						end if
send_script2:
						s=agg_get_descriptor_field(line_end,w)
						agg_invisible_separators(s)
						agg_data_send(s)
						if len(s)=255 then goto send_script2
						next_line=romfile.find(romfile.pointer,"~~",1)
						if next_line>0 then next_line=next_line+2
					wend
				end if	
			next j	
		end if
	next i
end sub

'------------------------------------------------------------------------------
function agg_modtime_sg(selected_item as agg_item, byref date_time as string, op as en_agg_rdwr) as ok_ng
	agg_modtime_sg=OK
	
	#if AGG_SETTING_CONTROL
		if selected_item.p1="S" then
			if op=EN_AGG_SET then
				if stg_sg(selected_item.item_name,0,"",EN_STG_GET)=EN_STG_STATUS_OK then
					if date_time="" then
						callback_agg_rtc_sg(stg_timestamp.ts_daycount,stg_timestamp.ts_mincount,stg_timestamp.ts_seconds,stg_timestamp.ts_milsec,EN_AGG_GET)
					else
						td_str_date_time_reformat(date_time,TD_STR_REMOVE_FORMATTING,TD_DATE_FORMAT_YYYYMMDD)
						td_from_str(date_time,stg_timestamp.ts_daycount,stg_timestamp.ts_mincount,stg_timestamp.ts_seconds,stg_timestamp.ts_milsec)
					end if
					stg_set_ts(selected_item.item_name)
					exit function
				end if
			else
				if stg_sg(selected_item.item_name,0,"",EN_STG_GET)=EN_STG_STATUS_OK then
					td_to_str(date_time,stg_timestamp.ts_daycount, stg_timestamp.ts_mincount,stg_timestamp.ts_seconds,stg_timestamp.ts_milsec)
					td_str_date_time_reformat(date_time,TD_STR_ADD_FORMATTING,TD_DATE_FORMAT_YYYYMMDD)
					exit function
				end if
			end if
		end if
	#endif

	#if AGG_TABLE_CONTROL
		dim tbl_ts as struct_tbl_timestamp
		if selected_item.p1="T" then
			if op=EN_AGG_SET then
				if tbl_select(selected_item.item_name,selected_item.item_name)=EN_TBL_STATUS_OK then
					if date_time="" then
						callback_agg_rtc_sg(tbl_ts.ts_daycount,tbl_ts.ts_mincount,tbl_ts.ts_seconds,tbl_ts.ts_milsec,EN_AGG_GET)
					else
						td_str_date_time_reformat(date_time,TD_STR_REMOVE_FORMATTING,TD_DATE_FORMAT_YYYYMMDD)
						td_from_str(date_time,tbl_ts.ts_daycount,tbl_ts.ts_mincount,tbl_ts.ts_seconds,tbl_ts.ts_milsec)
					end if
					tbl_timestamp_sg(tbl_ts,EN_TBL_SET)
					exit function
				end if
			else
				if tbl_select(selected_item.item_name,selected_item.item_name)=EN_TBL_STATUS_OK then
					tbl_timestamp_sg(tbl_ts,EN_TBL_GET)
					td_to_str(date_time,tbl_ts.ts_daycount, tbl_ts.ts_mincount,tbl_ts.ts_seconds,tbl_ts.ts_milsec)
					td_str_date_time_reformat(date_time,TD_STR_ADD_FORMATTING,TD_DATE_FORMAT_YYYYMMDD)
					exit function
				end if
			end if
		end if
	#endif
	agg_modtime_sg=NG
end function

'------------------------------------------------------------------------------
sub agg_get_items()
	dim s as string
	dim stemp as string(64)
	dim i as byte
	dim j,stg_num as byte
	
	select case agg_cmd.item_name
	case "info","children","variables","functions","events":
		agg_send_script()
		s=chr(AGG_COMMAND_END)
		agg_data_send(s)
		
	case "modtime":
		s=chr(AGG_COMMAND_START)+"R"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_cmd.id+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)
		agg_data_send(s)
		for i=0 to AGG_MAX_NUM_ITEMS-1
			if agg_items(i).entity_type=EN_AGG_ENTITY_VARIABLES and agg_cmd.context_name=agg_items(i).context_name then
				if agg_modtime_sg(agg_items(i),s,EN_AGG_GET)<>OK then goto not_found

				s=chr(AGG_ELEMENT_START)+"R"+chr(AGG_ELEMENT_NAME_VALUE_SEPARATOR)+chr(AGG_ELEMENT_START)+agg_items(i).item_name+chr(AGG_ELEMENT_END)+chr(AGG_ELEMENT_START)+s+chr(AGG_ELEMENT_END)+chr(AGG_ELEMENT_END)
				agg_data_send(s)
			end if
		next i
		s=chr(AGG_COMMAND_END)
		agg_data_send(s)
	
	case "version":
		s=FIRMWARE_VERSION
		s=mid(s,2,len(s)-2)
		s=chr(AGG_COMMAND_START)+"R"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_cmd.id+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+chr(AGG_ELEMENT_START)+"R"+chr(AGG_ELEMENT_NAME_VALUE_SEPARATOR)+chr(AGG_ELEMENT_START)+s+chr(AGG_ELEMENT_END)+chr(AGG_ELEMENT_END)+chr(AGG_COMMAND_END)
		agg_data_send(s)
	
	case "date":
		agg_systime_sg(s,EN_AGG_GET)
		s=chr(AGG_COMMAND_START)+"R"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_cmd.id+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+chr(AGG_ELEMENT_START)+"R"+chr(AGG_ELEMENT_NAME_VALUE_SEPARATOR)+chr(AGG_ELEMENT_START)+s+chr(AGG_ELEMENT_END)+chr(AGG_ELEMENT_END)+chr(AGG_COMMAND_END)
		agg_data_send(s)
	
	case else
		for i=0 to AGG_MAX_NUM_ITEMS-1
			if agg_items(i).entity_type=EN_AGG_ENTITY_VARIABLES and agg_cmd.context_name=agg_items(i).context_name and agg_cmd.item_name=agg_items(i).item_name then
				#if AGG_TABLE_CONTROL
					if agg_items(i).p1="T" then
						if agg_send_all_record(agg_cmd.item_name)<>OK then goto not_found
						agg_data_send(chr(AGG_COMMAND_END))
						exit sub				
					end if
				#endif
				
				#if AGG_SETTING_CONTROL
					dim stg_result as en_stg_status_codes
					if agg_items(i).p1="S" then
						s=""
						stg_result=stg_get_num_members(agg_items(i).item_name,stg_num)
						if  stg_result=EN_STG_STATUS_OK then
							for j=0 to stg_num-1
								stg_result=agg_settings_sg(agg_items(i).item_name,stemp,j,EN_STG_GET)
								if stg_result=EN_STG_STATUS_OK then
									s=s+chr(AGG_ELEMENT_START)+stemp+chr(AGG_ELEMENT_END)
								else
									exit for
								end if
							next j
						end if
						
						if stg_result=EN_STG_STATUS_OK then
							s=chr(AGG_COMMAND_START)+"R"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_cmd.id+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+chr(AGG_ELEMENT_START)+"R"+chr(AGG_ELEMENT_NAME_VALUE_SEPARATOR)+s+chr(AGG_ELEMENT_END)+chr(AGG_COMMAND_END)
						else
							s=chr(AGG_COMMAND_START)+"R"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_cmd.id+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"E"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_stg_msg(stg_result)+chr(AGG_COMMAND_END)
							callback_agg_stg_error(agg_cmd.item_name,stg_result)
						end if
						agg_data_send(s)
						exit sub
					end if
				#endif
			end if
		next i		
		goto not_found
	
	end select
	exit sub
not_found:
	s=chr(AGG_COMMAND_START)+"R"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_cmd.id+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"E"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"Unable to find the item."+chr(AGG_COMMAND_END)
	agg_data_send(s)
	callback_agg_error(EN_AGG_STATUS_ITEM_NOT_FOUND,agg_cmd.item_name)			
	#if AGG_DEBUG_PRINT
		agg_debug_print_status(EN_AGG_STATUS_ITEM_NOT_FOUND)
		s="context name: "+agg_cmd.context_name
		agg_debugprint(s)
	#endif
	
end sub

'------------------------------------------------------------------------------
function agg_element_get(byref element_level as string, byref element_str as string, byref opening_chr as string, byref closing_chr as string ) as string
	dim level_len, lvl_count, temp,i as byte
	dim pos1, pos2,pos3 as byte

	if element_level="" then
		agg_element_get=""
		exit function
	end if
	pos1=0
	
	'locate the target opening chr
	do
		temp=val(left(element_level,1))
		if temp=0 then goto not_found
		
		if temp>1 then
			pos1=instr(pos1+1,element_str,opening_chr,1)
			if pos1=0 then goto not_found		
			for i=1 to temp-1
				pos2=pos1
				pos3=pos1
				do
					pos2=instr(pos2+1,element_str,opening_chr,1)
					pos3=instr(pos3+1,element_str,closing_chr,1)
				loop while pos2<pos3 and pos2>0
				pos1=pos2
			next i
		else
			pos2=instr(pos1+1,element_str,closing_chr,1)
			pos1=instr(pos1+1,element_str,opening_chr,1)
			if pos1=0 or pos2<pos1 then goto not_found		
		end if
		
		level_len=len(element_level)
		element_level=right(element_level,level_len-1)
		level_len=len(element_level)
	loop while level_len>0
	
	if pos1=0 then
not_found:
		agg_element_get=""
		exit function
	end if
	pos2=pos1
	pos3=pos1
	do
		pos2=instr(pos2+1,element_str,opening_chr,1)
		pos3=instr(pos3+1,element_str,closing_chr,1)
	loop while pos2<pos3 and pos2>0	
	agg_element_get=mid(element_str,pos1,pos3-pos1+1)
end function

'------------------------------------------------------------------------------
sub agg_systime_sg(byref date_time as string(23), op as en_agg_rdwr)
'set or get the rtc time by aggregate command.
	dim syear as string(4)
	dim smonth, sdate, shour, smin, ssec as string(2)
	dim wdaycount, wmincount, wmilsec as word
	dim bsec as byte
	
'GET the RTC time
	if op=EN_AGG_GET then
		callback_agg_rtc_sg(wdaycount,wmincount,bsec,wmilsec,op) 
		td_to_str(date_time,wdaycount,wmincount,bsec,wmilsec)
		td_str_date_time_reformat(date_time,TD_STR_ADD_FORMATTING,TD_DATE_FORMAT_YYYYMMDD)	
	else
'Set the RTC time
		td_str_date_time_reformat(date_time,TD_STR_REMOVE_FORMATTING,TD_DATE_FORMAT_YYYYMMDD)
		td_from_str(date_time,wdaycount,wmincount,bsec,wmilsec)
		callback_agg_rtc_sg(wdaycount,wmincount,bsec,wmilsec,op)	
	end if
end sub

'------------------------------------------------------------------------------
function agg_entity_get(byref s as string) as en_agg_entity
	select case s
	case "info":
		agg_entity_get=EN_AGG_ENTITY_INFO
	case "variables":
		agg_entity_get=EN_AGG_ENTITY_VARIABLES
	case "functions":
		agg_entity_get=EN_AGG_ENTITY_FUNCTIONS
	case "events":
		agg_entity_get=EN_AGG_ENTITY_EVENTS
	case else
		s=""
	end select
end function

'------------------------------------------------------------------------------
#if AGG_SETTING_CONTROL
function agg_settings_sg(byref setting_name as string, byref setting_val as string, index as byte, rw as en_stg_rdwr) as en_stg_status_codes
	dim i as byte
	
	agg_settings_sg=EN_STG_STATUS_OK
	for i=0 to AGG_MAX_NUM_ITEMS-1
		if agg_items(i).entity_type=EN_AGG_ENTITY_VARIABLES and agg_cmd.context_name=agg_items(i).context_name and agg_items(i).item_name=setting_name then
			goto item_found
		end if
		
	next i
	goto fail
item_found:
	if rw=EN_STG_SET then
		if agg_modtime_sg(agg_items(i),"",EN_AGG_SET)<>OK then goto fail
		callback_agg_stg_mod_sg(setting_name,index,setting_val,EN_STG_SET)
		agg_settings_sg=stg_sg(setting_name,index,setting_val,EN_STG_SET)
		if agg_settings_sg=EN_STG_STATUS_OK then
			callback_agg_setting_saved(setting_name, setting_val)
		end if
	else
		agg_settings_sg=stg_sg(setting_name,index,setting_val,EN_STG_GET)
		callback_agg_stg_mod_sg(setting_name,index,setting_val,EN_AGG_GET)
	end if
	exit function
fail:
	agg_settings_sg=EN_STG_STATUS_FAILURE
end function

'------------------------------------------------------------------------------
function agg_stg_msg(stg_result as en_stg_status_codes) as string
'returns error msg according to the table status

	select case stg_result
		case EN_STG_STATUS_UNKNOWN:
			agg_stg_msg=AGG_MSG_STG_STATUS_UNKNOWN
		case EN_STG_STATUS_INVALID:
			agg_stg_msg=AGG_MSG_STG_STATUS_INVALID
		case else
			agg_stg_msg=AGG_MSG_STG_STATUS_FAILURE
	end select
end function

#endif

'----------------------------------------------------------------------------
#if AGG_TABLE_CONTROL
function agg_send_all_record(byref tbl_name as string) as ok_ng
	dim tbl_temp as tbl_type
	dim fld_temp as tbl_field_type
	dim j, dt_len as byte
	dim rec_num as word
	dim s as string
	dim num_of_field as byte
	dim tbl_result as en_tbl_status_codes
	
	agg_send_all_record=NG
	tbl_result=tbl_select(tbl_name,tbl_name)
	if tbl_result<>EN_TBL_STATUS_OK then 
		callback_agg_error(EN_AGG_STATUS_TABLE_ERROR,tbl_name)
		callback_agg_tbl_error(tbl_name,tbl_result)
		exit function
	end if
	rec_num=0
	
	agg_data_send(chr(AGG_COMMAND_START)+"R"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+agg_cmd.id+chr(AGG_COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(AGG_COMMAND_PARAMETERS_SEPARATOR))
	do
		if tbl_record_read_active(rec_num)<>EN_TBL_STATUS_OK then exit do
		if tbl_field_sg("UID",s,EN_TBL_GET)<>EN_TBL_STATUS_OK then exit do
		
		s=chr(AGG_ELEMENT_START)+"R"+chr(AGG_ELEMENT_NAME_VALUE_SEPARATOR)+chr(AGG_ELEMENT_START)+"I"+chr(AGG_ELEMENT_NAME_VALUE_SEPARATOR)+s+chr(AGG_ELEMENT_END)
		agg_data_send(s)
		num_of_field=tbl_get_num_fields(tbl_name)
		for j=0 to num_of_field-1
			tbl_get_field_info(tbl_name,j,fld_temp)
			tbl_result=tbl_field_sg(fld_temp.field_name,s,EN_TBL_GET)
			if tbl_result<>EN_TBL_STATUS_OK then 
				callback_agg_error(EN_AGG_STATUS_TABLE_ERROR,tbl_name)
				callback_agg_tbl_error(tbl_name,tbl_result)
				exit for
			end if
			callback_agg_tbl_fld_mod_sg(tbl_name,fld_temp.field_name,s,EN_AGG_GET)
			if fld_temp.field_type=`T` then
				agg_date_time_formating(s,fld_temp.p1,EN_AGG_GET)
				if s="" then 
					callback_agg_error(EN_AGG_STATUS_TABLE_ERROR,tbl_name)
					callback_agg_tbl_error(tbl_name,EN_TBL_STATUS_INVALID)
					exit for
				end if
			end if
			s=chr(AGG_ELEMENT_START)+s+chr(AGG_ELEMENT_END)
			agg_data_send(s)
		next j

		s=chr(AGG_ELEMENT_END)
		agg_data_send(s)
		rec_num=rec_num+1
	loop while true
	agg_data_send(chr(AGG_COMMAND_END))
	agg_send_all_record=OK
end function

'------------------------------------------------------------------------------
function agg_tbl_hash(byref contain as string, byref msg as string)as ok_ng 
'extact the table name from the contain, and return proper response string which contents the hash of the target table.
	dim stemp1 as string(64)
	dim pos1,pos2 as byte
	dim tbl_result as en_tbl_status_codes
	dim tbl_name as string(AGG_MAX_ITEM_NAME_LEN)
	
	pos1=instr(1,contain,chr(AGG_ELEMENT_START),3)
	pos2=instr(pos1,contain,chr(AGG_ELEMENT_END),1)
	tbl_name=mid(contain,pos1+1,pos2-pos1-1)
	tbl_result=tbl_select(tbl_name,tbl_name)
	if tbl_result<>EN_TBL_STATUS_OK then
		msg=chr(AGG_ELEMENT_START)+agg_tbl_msg(tbl_result)+chr(AGG_ELEMENT_END)
		agg_tbl_hash=NG
		callback_agg_error(EN_AGG_STATUS_TABLE_ERROR,tbl_name)
		callback_agg_tbl_error(tbl_name,tbl_result)
		exit function
	end if
	stemp1=tbl_get_hash()
	msg=chr(AGG_ELEMENT_START)+"R"+chr(AGG_ELEMENT_NAME_VALUE_SEPARATOR)+chr(AGG_ELEMENT_START)+stemp1+chr(AGG_ELEMENT_END)+chr(AGG_ELEMENT_END)
	agg_tbl_hash=OK
end function

'------------------------------------------------------------------------------
function agg_tbl_add_record(byref contain as string, byref msg as string)as ok_ng 
'extract the table name and record from the context, add the record the table and 
'returns the proper response string which contents the result of the add record operation
	dim s as string(64)
	dim pos1,pos2 as byte
	dim tbl_result as en_tbl_status_codes
	dim i as byte
	dim uid_string as string(10)
	dim fld_temp as tbl_field_type
	dim num_of_field as byte
	dim tbl_name as string(AGG_MAX_ITEM_NAME_LEN)
	
	pos1=instr(1,contain,chr(AGG_ELEMENT_START),3)
	pos2=instr(pos1,contain,chr(AGG_ELEMENT_END),1)
	tbl_name=mid(contain,pos1+1,pos2-pos1-1)
	tbl_result=tbl_select(tbl_name,tbl_name)
	
	if tbl_result<>EN_TBL_STATUS_OK then goto err

	pos1=instr(pos2,contain,"%<I%=",1)+5
	pos2=instr(pos1,contain,"%>",1)
	uid_string=mid(contain,pos1,pos2-pos1)
	num_of_field=tbl_get_num_fields(tbl_name)
	
	for i=0 to num_of_field-1
		tbl_get_field_info(tbl_name,i,fld_temp)
		
		pos1=instr(pos2,contain,"%<",1)
		pos2=instr(pos1,contain,"%>",1)
		if pos1>0 and pos2>0 then
			s=mid(contain,pos1+2,pos2-pos1-2)
			if fld_temp.field_type=`T` then
				agg_date_time_formating(s,fld_temp.p1,EN_AGG_SET)
				if s="" then exit for
			end if
			
			callback_agg_tbl_fld_mod_sg(tbl_name,fld_temp.field_name,s,EN_TBL_SET)
			tbl_result=tbl_field_sg(fld_temp.field_name,s,EN_TBL_SET)
			if tbl_result<>EN_TBL_STATUS_OK then
				if tbl_result=EN_TBL_STATUS_INVALID then
					if fld_temp.field_type=`S` then
						msg=chr(AGG_ELEMENT_START)+"Field length invalid"+"("+fld_temp.field_name+")"+chr(AGG_ELEMENT_END)
					else
						msg=chr(AGG_ELEMENT_START)+"Field value is not within vaild range"+"("+fld_temp.field_name+")"+chr(AGG_ELEMENT_END)
					end if
				else
					msg=chr(AGG_ELEMENT_START)+agg_tbl_msg(tbl_result)+chr(AGG_ELEMENT_END)
				end if
				msg=chr(AGG_ELEMENT_START)+agg_tbl_msg(tbl_result)+"("+fld_temp.field_name+")"+chr(AGG_ELEMENT_END)
				agg_tbl_add_record=NG
				callback_agg_error(EN_AGG_STATUS_TABLE_ERROR,tbl_name)
				callback_agg_tbl_error(tbl_name,tbl_result)
				exit function
			end if
		else 
			exit for
		end if
	next i
	tbl_result=tbl_record_add(uid_string)
	if tbl_result<>EN_TBL_STATUS_OK then
err:
		msg=chr(AGG_ELEMENT_START)+agg_tbl_msg(tbl_result)+chr(AGG_ELEMENT_END)
		callback_agg_error(EN_AGG_STATUS_TABLE_ERROR,tbl_name)
		callback_agg_tbl_error(tbl_name,tbl_result)
		agg_tbl_add_record=NG
		exit function
	end if
	agg_tbl_add_record=OK
	msg=""
end function

'------------------------------------------------------------------------------
function agg_tbl_put_record(byref contain as string, byref msg as string)as ok_ng 
'extract the table name and record from the context, add the record the table and 
'returns the proper response string which contents the result of the add record operation
'instead of editing one record, whole table need to be replaced, because we are currently unable to do index in the table library

	dim s as string(64)
	dim pos1,pos2 as byte
	dim tbl_result as en_tbl_status_codes
	dim i as byte
	dim uid_string as string(10)
	dim fld_temp as tbl_field_type
	dim num_of_field as byte
	dim tbl_name as string(AGG_MAX_ITEM_NAME_LEN)

	tbl_result=tbl_select(agg_selected_tbl_info,AGG_TBL_TEMP)
	if tbl_result<>EN_TBL_STATUS_OK then goto err
	
	pos1=instr(1,contain,"%<I%=",1)
	
	if pos1=0 then
		pos2=instr(1,contain,"R\x1E\x1C",1)
		uid_string=""
	else
		pos1=pos1+5
		pos2=instr(pos1,contain,"%>",1)
		uid_string=mid(contain,pos1,pos2-pos1)		
	end if

	num_of_field=tbl_get_num_fields(agg_selected_tbl_info)
	
	for i=0 to num_of_field-1
		tbl_get_field_info(agg_selected_tbl_info,i,fld_temp)
		
		pos1=instr(pos2,contain,"%<",1)
		pos2=instr(pos1,contain,"%>",1)
		if pos1>0 and pos2>0 then
			s=mid(contain,pos1+2,pos2-pos1-2)
			if fld_temp.field_type=`T` then
				agg_date_time_formating(s,fld_temp.p1,EN_AGG_SET)
				if s="" then exit for
			end if
			
			callback_agg_tbl_fld_mod_sg(tbl_name,fld_temp.field_name,s,EN_AGG_SET)
			tbl_result=tbl_field_sg(fld_temp.field_name,s,EN_TBL_SET)
			if tbl_result<>EN_TBL_STATUS_OK then
				if tbl_result=EN_TBL_STATUS_INVALID then
					if fld_temp.field_type=`S` then
						msg=chr(AGG_ELEMENT_START)+"Field length invalid"+"("+fld_temp.field_name+")"+chr(AGG_ELEMENT_END)
					else
						msg=chr(AGG_ELEMENT_START)+"Field value is not within vaild range"+"("+fld_temp.field_name+")"+chr(AGG_ELEMENT_END)
					end if
				else
					msg=chr(AGG_ELEMENT_START)+agg_tbl_msg(tbl_result)+chr(AGG_ELEMENT_END)
				end if
				msg=chr(AGG_ELEMENT_START)+agg_tbl_msg(tbl_result)+"("+fld_temp.field_name+")"+chr(AGG_ELEMENT_END)
				agg_tbl_put_record=NG
				callback_agg_error(EN_AGG_STATUS_TABLE_ERROR,agg_selected_tbl_info)
				callback_agg_tbl_error(tbl_name,tbl_result)
				exit function
			end if
		else 
			exit for
		end if
	next i
	
	if uid_string="" then
		tbl_result=tbl_record_add("")	'supply empty uid_string with cause auto id generation, so instead we use a empty string(0) constant
	else
		tbl_result=tbl_record_add(uid_string)
	end if
	
	if tbl_result<>EN_TBL_STATUS_OK then 
err:
		msg=chr(AGG_ELEMENT_START)+agg_tbl_msg(tbl_result)+chr(AGG_ELEMENT_END)
		callback_agg_error(EN_AGG_STATUS_TABLE_ERROR,agg_selected_tbl_info)
		callback_agg_tbl_error(tbl_name,tbl_result)
		agg_tbl_put_record=NG
		exit function
	end if
	agg_tbl_put_record=OK
	msg=""
end function

'------------------------------------------------------------------------------
function agg_tbl_update_record(byref contain as string, byref msg as string)as ok_ng 
	dim s as string(64)
	dim pos1,pos2 as byte
	dim tbl_result as en_tbl_status_codes
	dim i as byte
	dim uid_string as string(10)
	dim fld_temp as tbl_field_type
	dim num_of_field as byte
	dim tbl_name as string(AGG_MAX_ITEM_NAME_LEN)
	dim rec_num as word
	
	pos1=instr(1,contain,chr(AGG_ELEMENT_START),3)
	pos2=instr(pos1,contain,chr(AGG_ELEMENT_END),1)
	tbl_name=mid(contain,pos1+1,pos2-pos1-1)
	tbl_result=tbl_select(tbl_name,tbl_name)
	
	if tbl_result<>EN_TBL_STATUS_OK then goto err
	
	pos1=instr(pos2,contain,"%<I%=",1)+5
	pos2=instr(pos1,contain,"%>",1)
	uid_string=mid(contain,pos1,pos2-pos1)
	num_of_field=tbl_get_num_fields(tbl_name)
	
	rec_num=1
	tbl_result=tbl_record_find(EN_TBL_RECORD_ACTIVE,uid_string,"UID",rec_num,EN_TBL_SEARCH_DOWN,PL_FD_FIND_EQUAL)
	if tbl_result<>EN_TBL_STATUS_OK then goto err

	tbl_result=tbl_record_sg(rec_num,EN_TBL_GET)
	if tbl_result<>EN_TBL_STATUS_OK then goto err
	
	for i=0 to num_of_field-1
		tbl_get_field_info(tbl_name,i,fld_temp)
		
		pos1=instr(pos2,contain,"%<",1)
		pos2=instr(pos1,contain,"%>",1)
		if pos1>0 and pos2>0 then
			s=mid(contain,pos1+2,pos2-pos1-2)
			if fld_temp.field_type=`T` then
				agg_date_time_formating(s,fld_temp.p1,EN_AGG_SET)
				if s="" then exit for
			end if
			
			callback_agg_tbl_fld_mod_sg(tbl_name,fld_temp.field_name,s,EN_AGG_SET)
			tbl_result=tbl_field_sg(fld_temp.field_name,s,EN_TBL_SET)
			if tbl_result<>EN_TBL_STATUS_OK then
				if tbl_result=EN_TBL_STATUS_INVALID then
					if fld_temp.field_type=`S` then
						msg=chr(AGG_ELEMENT_START)+"Field length invalid"+"("+fld_temp.field_name+")"+chr(AGG_ELEMENT_END)
					else
						msg=chr(AGG_ELEMENT_START)+"Field value is not within vaild range"+"("+fld_temp.field_name+")"+chr(AGG_ELEMENT_END)
					end if
				else
					msg=chr(AGG_ELEMENT_START)+agg_tbl_msg(tbl_result)+chr(AGG_ELEMENT_END)
				end if
				msg=chr(AGG_ELEMENT_START)+agg_tbl_msg(tbl_result)+"("+fld_temp.field_name+")"+chr(AGG_ELEMENT_END)
				agg_tbl_update_record=NG
				callback_agg_error(EN_AGG_STATUS_TABLE_ERROR,tbl_name)
				callback_agg_tbl_error(tbl_name,tbl_result)
				exit function
			end if
		else 
			exit for
		end if
	next i

	tbl_result=tbl_record_edit(rec_num)
	if tbl_result<>EN_TBL_STATUS_OK then
err:
		msg=chr(AGG_ELEMENT_START)+agg_tbl_msg(tbl_result)+chr(AGG_ELEMENT_END)
		callback_agg_error(EN_AGG_STATUS_TABLE_ERROR,tbl_name)
		callback_agg_tbl_error(tbl_name,tbl_result)
		agg_tbl_update_record=NG
		exit function
	end if
	agg_tbl_update_record=OK
	msg=""
end function

'------------------------------------------------------------------------------
function agg_tbl_remove_record(byref contain as string, byref msg as string)as ok_ng 
	dim s as string(64)
	dim pos1,pos2 as byte
	dim i as byte
	dim tbl_result as en_tbl_status_codes
	dim tbl_name as string(AGG_MAX_ITEM_NAME_LEN)
	dim rec_num as word
	
	pos1=instr(1,contain,chr(AGG_ELEMENT_START),3)
	pos2=instr(pos1,contain,chr(AGG_ELEMENT_END),1)
	tbl_name=mid(contain,pos1+1,pos2-pos1-1)
	tbl_result=tbl_select(tbl_name,tbl_name)
	if tbl_result<>EN_TBL_STATUS_OK then goto err

	pos1=instr(pos2,contain,chr(AGG_ELEMENT_START),1)
	pos2=instr(pos1,contain,chr(AGG_ELEMENT_END),1)
	s=mid(contain,pos1+1,pos2-pos1-1)
	rec_num=1
	tbl_result=tbl_record_find(EN_TBL_RECORD_ACTIVE,s,"UID",rec_num,EN_TBL_SEARCH_DOWN,PL_FD_FIND_EQUAL)
	if tbl_result=EN_TBL_STATUS_OK then
		tbl_result=tbl_record_delete(rec_num)
		if tbl_result<>EN_TBL_STATUS_OK then goto err
	else
err:
		msg=chr(AGG_ELEMENT_START)+agg_tbl_msg(tbl_result)+chr(AGG_ELEMENT_END)
		callback_agg_error(EN_AGG_STATUS_TABLE_ERROR,agg_selected_tbl_info)
		callback_agg_tbl_error(tbl_name,tbl_result)
		agg_tbl_remove_record=NG
		exit function
	end if
	msg=""
	agg_tbl_remove_record=OK
end function

'------------------------------------------------------------------------------
function agg_tbl_start_table(byref contain as string, byref msg as string)as ok_ng 
'	dim stemp1 as string(64)
	dim pos1,pos2 as byte
	dim tbl_result as en_tbl_status_codes
	dim tbl_name as string(AGG_MAX_ITEM_NAME_LEN)
	
	pos1=instr(1,contain,chr(AGG_ELEMENT_START),3)
	pos2=instr(pos1,contain,chr(AGG_ELEMENT_END),1)
	tbl_name=mid(contain,pos1+1,pos2-pos1-1)
	
	tbl_result=tbl_select(tbl_name,AGG_TBL_TEMP)
	if tbl_result<>EN_TBL_STATUS_OK then goto err
	tbl_result=tbl_clear()
	if tbl_result<>EN_TBL_STATUS_OK then
err:
		msg=chr(AGG_ELEMENT_START)+agg_tbl_msg(tbl_result)+chr(AGG_ELEMENT_END)
		callback_agg_error(EN_AGG_STATUS_TABLE_ERROR,tbl_name)
		callback_agg_tbl_error(tbl_name,tbl_result)
		agg_tbl_start_table=NG
		exit function
	end if
	
	msg=""
	agg_selected_tbl_info=tbl_name
	agg_tbl_start_table=OK
end function

'------------------------------------------------------------------------------
function agg_tbl_finish_table(byref contain as string, byref msg as string)as ok_ng 
	dim tbl_result as en_tbl_status_codes
	dim pos1,pos2 as byte
	dim tbl_name as string(AGG_MAX_ITEM_NAME_LEN)
	
	pos1=instr(1,contain,chr(AGG_ELEMENT_START),3)
	pos2=instr(pos1,contain,chr(AGG_ELEMENT_END),1)
	tbl_name=mid(contain,pos1+1,pos2-pos1-1)
	
	tbl_result=tbl_replace(tbl_name,AGG_TBL_TEMP)
	if tbl_result<>EN_TBL_STATUS_OK then
		msg=chr(AGG_ELEMENT_START)+agg_tbl_msg(tbl_result)+chr(AGG_ELEMENT_END)
		callback_agg_error(EN_AGG_STATUS_TABLE_ERROR,tbl_name)
		callback_agg_tbl_error(tbl_name,tbl_result)
		agg_tbl_finish_table=NG
		exit function
	end if
	msg=""
	agg_tbl_finish_table=OK
end function

'------------------------------------------------------------------------------
sub agg_date_time_formating(byref td_str as string, tbl_date_time_format as en_tbl_date_time_format, op as en_agg_rdwr)
	dim td_len as byte
	
	if op=EN_AGG_GET then
		select case tbl_date_time_format
		case EN_TBL_DT_DATE:					'YYYYMMDD (year,month,date)
			td_len=8
			goto date_time_add_formating
		case EN_TBL_DT_TIME1:					'hhmm (hour,minutes)
			td_len=4
			goto time_add_formating
		case EN_TBL_DT_TIME2:					'hhmmss (hour,minutes,second)
			td_len=6
			goto time_add_formating				
		case EN_TBL_DT_TIME3:					'hhmmssmls (hour,minutes,second,milsecond)
			td_len=9
time_add_formating:
			if len(td_str)>td_len then
				td_str=left(td_str,td_len)
			else
				td_str=td_str+strgen(td_len-len(td_str),"0")
			end if
			td_str_time_reformat(td_str,TD_STR_ADD_FORMATTING)
		case EN_TBL_DT_DATE_TIME1:				'YYYYMMDDhhmm (year,month,date,hour,minutes)
			td_len=12
			goto date_time_add_formating				
		case EN_TBL_DT_DATE_TIME2:				'YYYYMMDDhhmmss (year,month,date,hour,minutes,second)
			td_len=14
			goto date_time_add_formating				
		case EN_TBL_DT_ALL:						'YYYYMMDDhhmmssmls (year,month,date,hour,minutes,second,milsecond)
			td_len=17
date_time_add_formating:
			if len(td_str)>td_len then
				td_str=left(td_str,td_len)
			else
				td_str=td_str+strgen(td_len-len(td_str),"0")
			end if
			td_str_date_time_reformat(td_str,TD_STR_ADD_FORMATTING,TD_DATE_FORMAT_YYYYMMDD)
		case else
			td_str=""
		end select
	else
		select case tbl_date_time_format
		case EN_TBL_DT_DATE:						'YYYYMMDD (year,month,date)
			td_len=10
			goto date_time_remove_formating
		case EN_TBL_DT_TIME1:					'hhmm (hour,minutes)
			td_len=5
			goto time_remove_formating
		case EN_TBL_DT_TIME2:					'hhmmss (hour,minutes,second)
			td_len=8
			goto time_remove_formating				
		case EN_TBL_DT_TIME3:					'hhmmssmls (hour,minutes,second,milsecond)
			td_len=12
time_remove_formating:
			if len(td_str)>td_len then
				td_str=left(td_str,td_len)
			else
				td_str=td_str+strgen(td_len-len(td_str),"0")
			end if
			td_str_time_reformat(td_str,TD_STR_REMOVE_FORMATTING)
		case EN_TBL_DT_DATE_TIME1:				'YYYYMMDDhhmm (year,month,date,hour,minutes)
			td_len=16
			goto date_time_remove_formating				
		case EN_TBL_DT_DATE_TIME2:				'YYYYMMDDhhmmss (year,month,date,hour,minutes,second)
			td_len=19
			goto date_time_remove_formating				
		case EN_TBL_DT_ALL:						'YYYYMMDDhhmmssmls (year,month,date,hour,minutes,second,milsecond)
			td_len=23
date_time_remove_formating:
			if len(td_str)>td_len then
				td_str=left(td_str,td_len)
			else
				td_str=td_str+strgen(td_len-len(td_str),"0")
			end if
			td_str_date_time_reformat(td_str,TD_STR_REMOVE_FORMATTING,TD_DATE_FORMAT_YYYYMMDD)
		case else
			td_str=""
		end select
	end if
end sub

'------------------------------------------------------------------------------
function agg_tbl_msg(tbl_result as en_tbl_status_codes) as string
'returns error msg according to the table status

	select case tbl_result
		case EN_TBL_STATUS_OK: 
			agg_tbl_msg=""
		case EN_TBL_STATUS_FAILURE: 
			agg_tbl_msg=AGG_MSG_TBL_STATUS_FAILURE
		case EN_TBL_STATUS_UNKNOWN_TABLE: 
			agg_tbl_msg=AGG_MSG_TBL_STATUS_UNKNOWN_TABLE
		case EN_TBL_STATUS_UNKNOWN_FIELD: 
			agg_tbl_msg=AGG_MSG_TBL_STATUS_UNKNOWN_FIELD
		case EN_TBL_STATUS_INVALID: 
			agg_tbl_msg=AGG_MSG_TBL_STATUS_INVALID
		case EN_TBL_STATUS_FULL: 
			agg_tbl_msg=AGG_MSG_TBL_STATUS_FULL
		case EN_TBL_STATUS_KEY_VIOLATION
			agg_tbl_msg=AGG_MSG_TBL_STATUS_KEY_VIOLATION
	end select
end function

#endif
'----------------------------------------------------------------------------
function agg_call_function(byref op as string ,byref context_name as string, byref func_input as string, byref msg as string) as ok_ng
	
	if context_name="" then	'root operations
		select case op
		case "synchronized":
			agg_sychronized=YES
			msg=""
			agg_call_function=OK
			#if AGG_DEBUG_PRINT
				agg_debugprint("aggregate server syncronized")
			#endif
			agg_link_state=EN_AGG_LINK_STATE_ESTABLISHED
			callback_agg_ok()
		case "login":
			msg=agg_root_login(func_input)
			agg_call_function=ok
		case "register":
			if agg_auto_register=YES then
				msg=chr(AGG_ELEMENT_START)+"R"+chr(AGG_ELEMENT_NAME_VALUE_SEPARATOR)+chr(AGG_ELEMENT_START)+agg_password+chr(AGG_ELEMENT_END)+chr(AGG_ELEMENT_END)
				agg_call_function=OK
			else
				msg=chr(AGG_ELEMENT_START)+"Auto register disabled."+chr(AGG_ELEMENT_END)
				agg_call_function=NG
			end if
#if AGG_TABLE_CONTROL
		case "hash":
			'returns hash value of the table
			agg_call_function=agg_tbl_hash(func_input,msg)
		case "startTable":
			'start table synchronization, this function call info device to start replace the whole table
			agg_call_function=agg_tbl_start_table(func_input, msg)
		case "finishTable":
			'this function call notify the device that the table synchronization is done.
			agg_call_function=agg_tbl_finish_table(func_input,msg)
			if agg_call_function<>OK then exit function
			agg_call_function=agg_tbl_hash(func_input,msg)
		case "addRecord":
			'adding single record to the target table
			agg_call_function=agg_tbl_add_record(func_input,msg)
		case "removeRecord":
			'remove single record from the target table
			agg_call_function=agg_tbl_remove_record(func_input,msg)
		case "updateRecord":
			'modify a single record which is pointed by the table record pointer.
			agg_call_function=agg_tbl_update_record(func_input,msg)						
		case "putRecords":
			'this is the function call used to add records to device during total table synchronization.
			agg_call_function=agg_tbl_put_record(func_input,msg)

#endif
		case else				'device specific operations
			agg_call_function=callback_agg_device_specific_operation(op,context_name,func_input, msg)
		end select
	else						'device specific operations
		agg_call_function=callback_agg_device_specific_operation(op,context_name,func_input, msg) 
	end if

end function

'------------------------------------------------------------------------------
function agg_root_login(byref function_input as string) as string
	dim stemp1,stemp2,stemp3 as string(128)

	stemp1=agg_element_get("11",function_input,chr(AGG_ELEMENT_START),chr(AGG_ELEMENT_END))
	stemp2=chr(AGG_ELEMENT_START)+agg_owner_name+chr(AGG_ELEMENT_END)	
	stemp2=stemp2+chr(AGG_ELEMENT_START)+agg_device_name+chr(AGG_ELEMENT_END)
	stemp3=mid(stemp1,2,len(stemp1)-2)
	stemp3=stemp3+agg_password
	stemp1=md5(stemp3,"",MD5_FINISH,len(stemp3))
	stemp3=agg_hex_to_hexstr(stemp1)
	stemp2=chr(AGG_ELEMENT_START)+"R"+chr(AGG_ELEMENT_NAME_VALUE_SEPARATOR)+stemp2+chr(AGG_ELEMENT_START)+stemp3+chr(AGG_ELEMENT_END)+chr(AGG_ELEMENT_END)
	agg_root_login=stemp2
	#if AGG_LOGIN_CONTROL
		login(CMD_MODE_AGGREGATE,"",agg_sock)
	#endif
end function

'------------------------------------------------------------------------------
sub agg_data_send(s as string)
	dim w as word

	w=sys.timercount
	sock.num=agg_sock
	while sock.txfree<len(s) and sock.statesimple=PL_SSTS_EST
		if sys.timercount<w then w=0
		if sys.timercount>w+AGG_SEND_WAIT_TIME then exit while
	wend
	sock.setdata(s)
	sock.send
end sub

'----------------------------------------------------------------------------
sub agg_rx_clr(l as byte)

	if l>0 then 
		sock.num=agg_sock
		agg_rx=right(agg_rx,len(agg_rx)+1-l)
		agg_rx=agg_rx+sock.getdata(255-len(agg_rx))
	end if
end sub

'------------------------------------------------------------------------------
sub agg_invisible_separators(byref s as string)

	agg_replace_chr(s,"<",chr(AGG_ELEMENT_START))
	agg_replace_chr(s,">",chr(AGG_ELEMENT_END))
	agg_replace_chr(s,"=",chr(AGG_ELEMENT_NAME_VALUE_SEPARATOR))
	agg_replace_chr(s,"^",chr(AGG_NULL))
	agg_replace_chr(s,"%3E%",">")
	agg_replace_chr(s,"%3D%","=")
end sub

'------------------------------------------------------------------------------
sub agg_replace_chr(byref s as string, byref a as string, byref b as string)
'replace sub-string a with sub-string b in the target string s

	dim pos as byte
	
	pos=instr(1,s,a,1)
	while pos>0
		insert(s,pos,b)
		pos=instr(pos+1,s,a,1)
	wend
end sub

'------------------------------------------------------------------------------
function agg_hex_to_hexstr(byref is as string) as string
	dim ss as string(4)
	dim f as byte

	agg_hex_to_hexstr=""
	for f=1 to len(is)
		ss=hex(asc(mid(is,f,1)))
		ss=right(ss,len(ss)-2)
		if len(ss)<2 then
			ss="0"+ss
		end if
		agg_hex_to_hexstr=agg_hex_to_hexstr+ss
	next f
end function

'----------------------------------------------------------------------------
#if AGG_DEBUG_PRINT
sub agg_debug_print_status(status as en_agg_status_codes)
	dim s as string(64)

	select case status
	case EN_AGG_STATUS_OK:
		exit sub
	case EN_AGG_STATUS_NOT_STARTED:
		s="agg_start() wasn't used or failed."
	case EN_AGG_STATUS_OUT_OF_SOCKETS:
		s="out of sockets."
	case EN_AGG_STATUS_INVALID_INTERFACE:
		s="Invalid interface."
	case EN_AGG_STATUS_INSUFFICIENT_BUFFER_SPACE:
		s="insufficient buffer space."
	case EN_AGG_STATUS_CONNECTION_LOST:
		s="device has been disconnected from the server."
	case EN_AGG_STATUS_SETTING_ERROR:
		s="setting error."
	case EN_AGG_STATUS_TABLE_ERROR:
		s="table error."
	case EN_AGG_STATUS_FUNCTION_ERROR:
		s="function error."
	case EN_AGG_STATUS_ITEM_NOT_FOUND:
		s="item not found."
	end select
	agg_debugprint("ERROR: "+s)
end sub
#endif

'------------------------------------------------------------------------------
#if AGG_DEBUG_PRINT
sub agg_debugprint(byref print_data as string)
	dim s as string(16)
	
agg_debugprint_1:	
	sys.debugprint(AGG_STAMP1+s+AGG_STAMP2+print_data+AGG_CR_LF)
end sub
#endif