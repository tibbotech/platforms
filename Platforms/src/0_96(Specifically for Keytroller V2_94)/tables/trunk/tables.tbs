'*********************************************************************************
'			TABLES LIBRARY
'	Table library requires a tables structure definition file(filename is defined 
'	by 'TABLE_STRUCTURE_FILE'. This file contains some properies of all tables, and
'	it should follow the format below:
'
'	1			2		3		4			5		6		
'	TableName	Minrecs Maxrecs	TableStruct	Hash	Numkeyf
'	>>user		0		1024	TABLE		Y		1
'	>>log		0		8000	LIST		N		0
'
'	Each table also has their own definition file, and the filename should be
'	the TableName follow by file extention of '.txt'.
'	for exampe:
'
'	user.txt contains following data:
'	1				2		3		4		5
'	FieldName		Type 	Param1	Param2	Defval
'	>>user_id		S		1		14		^
'	>>name			S		0		31		^
'	>>category		B		0		2		0
'	>>exp_date		D		0		0		20150101
'
'	log.txt contains following data:
'	1				2		3		4			5
'	FieldName		Type 	Param1	Param2		Defval
'	>>event_id		B		0		157			0	
'	>>date			D		0		0			20000101
'	>>time			D		2		0			000000
'	>>user_id		S		0		14			0
'	>>mach_num		S		1		2			0
'	>>value			W		0		65535		0
'
'*********************************************************************************

include "global.tbh"

'------------------------------------------------------------------------------
declare sub tbl_check_for_missing_fields(curr_pos as word, line_end_pos as word)
declare function tbl_active_rc_sg(byref rec_count as word,op as en_tbl_rdwr) as pl_fd_status_codes
declare function tbl_field_find(field_name as string, byref fld_num as byte) as en_tbl_status
declare sub tbl_mod_HASH(byref d as dword)
declare function tbl_gen_UID(byref id_string as string(10)) as en_tbl_status
declare function tbl_check_key_violation(byref key_ptr as word) as no_yes
declare function tbl_adjust_size() as en_tbl_status

'------------------------------------------------------------------------------
public dim tbl_record_string as string(MAX_RECORD_SIZE) 'the largest record allowed is 128 bytes
dim tbl_suspend_flushing as no_yes
dim tbl_num as byte
dim fld_offset as byte
dim tbl_info as tbl_type(MAX_NUM_TABLES)
dim selected_tbl_name as string(MAX_TBL_NAME_LEN)
dim selected_tbl_RecSize as byte
dim selected_tbl_Maxrecs as word
dim selected_tbl_Numkeyf as byte
dim selected_tbl_Struct as en_tbl_struct
dim selected_tbl_active_rc as word
dim selected_tbl_all_rc as word

'=========================================================================
public function tbl_select(tbl_name as string(MAX_TBL_NAME_LEN)) as en_tbl_status
'Selecting the table that is used in following table operations, the table name can 
'also be a number with is the index of the selecting table in the table arrary 'table_info[]'

	if fd.ready=NO then goto tbl_fail
	'find table
	if tbl_find(tbl_name)<>EN_TBL_STATUS_OK then goto tbl_unknown_tbl
	
	'skip if the table is already selected.
	if selected_tbl_name=tbl_info(tbl_num).TableName and fd.fileopened=YES then goto tbl_ok
	selected_tbl_name =""
	selected_tbl_RecSize=0
	'open table
	fd.filenum=tbl_info(tbl_num).fnum
	if fd.fileopened=NO then
		if fd.open(tbl_info(tbl_num).TableName)<>PL_FD_STATUS_OK then goto fd_error
	end if
	
	'update the memory for the properties of selecting table
	selected_tbl_name=tbl_info(tbl_num).TableName
	selected_tbl_RecSize=tbl_info(tbl_num).RecSize
	selected_tbl_Maxrecs=tbl_info(tbl_num).Maxrecs
	selected_tbl_Numkeyf=tbl_info(tbl_num).Numkeyf
	selected_tbl_Struct=tbl_info(tbl_num).Struct
	tbl_record_number_get(selected_tbl_all_rc,yes)
	
	if fd.transactionstart()<>PL_FD_STATUS_OK then goto fd_error
	if tbl_active_rc_sg(selected_tbl_active_rc,EN_TBL_GET)<>PL_FD_STATUS_OK then goto fd_error
	tbl_select=tbl_adjust_size()
	if tbl_select<>EN_TBL_STATUS_OK then goto finish
	if fd.transactioncommit()<>PL_FD_STATUS_OK then goto fd_error
	goto tbl_ok

fd_error:
	select case fd.laststatus
	case PL_FD_STATUS_OK: goto tbl_ok
	case PL_FD_STATUS_ALREADY_OPENED: goto tbl_ok
	case PL_FD_STATUS_DUPLICATE_NAME: goto tbl_ok
	case PL_FD_STATUS_NOT_FOUND: goto tbl_unknown_tbl
	case PL_FD_STATUS_NOT_OPENED: goto tbl_unknown_tbl
	case else goto tbl_fail
	end select
	
tbl_ok:
	tbl_select=EN_TBL_STATUS_OK
	goto finish
tbl_fail:
	tbl_select=EN_TBL_STATUS_FAILURE
	goto finish
tbl_unknown_tbl:
	tbl_select=EN_TBL_STATUS_UNKNOWN_TABLE
	goto finish
finish:
	if fd.ready=NO then tbl_select=EN_TBL_STATUS_FAILURE
	if tbl_select=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function

'------------------------------------------------------------------------------
function tbl_attributes_sg(byref tbl_name as string(MAX_TBL_NAME_LEN), attri_name as string(4),byref attri_val as string(7),op as en_tbl_rdwr) as pl_fd_status_codes
	dim s as string(13)
	dim sHash as string(4)
	dim sTs as string(7)
	dim sRC as string(2)
	s=fd.getattributes(tbl_name)
	sHash=mid(s,1,4)
	sTs=mid(s,5,7)
	sRC=mid(s,12,2)
	if op=EN_TBL_GET then
		select case attri_name
		case "HASH":
			attri_val=sHash
		case "TS":
			attri_val=sTs
		case "RC":
			attri_val=sRC
		case else
			attri_val=s
		end select
	else
		select case attri_name
		case "HASH":
			s=attri_val+sTs+sRC
		case "TS":
			s=sHash+attri_val+sRC
		case "RC":
			s=sHash+sTs+attri_val
		case else
			s=strgen(13,chr(NULL))
		end select
		tbl_attributes_sg=fd.setattributes(tbl_name,s)
	end if
end function
'------------------------------------------------------------------------------
function tbl_active_rc_sg(byref rec_count as word,op as en_tbl_rdwr) as pl_fd_status_codes
	dim s as string(2)
	dim msb, lsb as byte
	if op=EN_TBL_GET then
		tbl_active_rc_sg=tbl_attributes_sg(selected_tbl_name,"RC",s,EN_TBL_GET)
		if tbl_active_rc_sg<>PL_FD_STATUS_OK then exit function
		msb=asc(left(s,1))
		lsb=asc(right(s,1))
		rec_count=msb*256+lsb
	else
		msb=rec_count/256
		lsb=rec_count mod 256
		s=chr(msb)+chr(lsb)
		tbl_active_rc_sg=tbl_attributes_sg(selected_tbl_name,"RC",s,EN_TBL_SET)
	end if
end function
'------------------------------------------------------------------------------
public function tbl_init() as en_tbl_status
'Intitalize the table, prepare the table structure variables. 
	dim s as string
	dim i,j,k,c,line_end as word
	dim f as byte
	dim fd_status as pl_fd_status_codes
	
	if fd.ready=NO then goto tbl_fail
	
	for f=0 to fd.maxopenedfiles-1
		fd.filenum=f
		fd.close()
	next f
	
	fld_offset=0
#if TABLE_HASH_ENABLED=1
	fld_offset=fld_offset+1
#endif	
#if GEN_UID_ENABLED=1
	fld_offset=fld_offset+1
#endif
	s=strgen(127,chr(NULL))
	tbl_record_string=ACTIVE_FLAG+s
	tbl_suspend_flushing=NO
	tbl_num=0 'will count settings (starting from 0)
	selected_tbl_name=""
	romfile.open(TABLE_STRUCTURE_FILE)				'this file is a tables descriptor file
	i=romfile.find(romfile.pointer,">>",1)

	while i<>0	
		'we are now at the ">>" pointing at the beginning of one setting descriptor line
		romfile.pointer=i+2
		
		'find the end of this setting descriptor line
		line_end=romfile.find(romfile.pointer,chr(TBL_END_OF_LINE),1)
		
		'extract table name
		do 
			i=romfile.find(romfile.pointer,chr(TBL_FIELD_SEPARATOR),1) 
			tbl_check_for_missing_fields(i,line_end)			
			s=romfile.getdata(i-romfile.pointer)
			romfile.pointer=i+1
		loop while s="" 		
		'name too long?
		if len(s)>MAX_TBL_NAME_LEN then
			sys.halt
			tbl_num=0 'you need to increase MAX_TBL_NAME_LEN!
		end if
		tbl_info(tbl_num).TableName=s

		'extract the minimum of records
		do
			i=romfile.find(romfile.pointer,chr(TBL_FIELD_SEPARATOR),1) 
			tbl_check_for_missing_fields(i,line_end)			
			s=romfile.getdata(i-romfile.pointer)
			romfile.pointer=i+1
		loop while s="" 		
		
		'we do not need to check word
		tbl_info(tbl_num).Minrecs=val(s)

		'extract the maximum of records
		do
			i=romfile.find(romfile.pointer,chr(TBL_FIELD_SEPARATOR),1) 
			tbl_check_for_missing_fields(i,line_end)			
			s=romfile.getdata(i-romfile.pointer)
			romfile.pointer=i+1
		loop while s="" 		

		tbl_info(tbl_num).Maxrecs=val(s)

		if tbl_info(tbl_num).Maxrecs<tbl_info(tbl_num).Minrecs then
			sys.halt
			tbl_num=0	'Maxrecs parameter cannot be smaller than Minrecs parameter
		end if
		
		'extract the structure type of tables
		do
			i=romfile.find(romfile.pointer,chr(TBL_FIELD_SEPARATOR),1) 
			tbl_check_for_missing_fields(i,line_end)			
			s=romfile.getdata(i-romfile.pointer)
			romfile.pointer=i+1
		loop while s="" 		
		
		select case s
			case "LIST":tbl_info(tbl_num).Struct=EN_TBL_STRUCT_LIST
			case "TABLE": tbl_info(tbl_num).Struct=EN_TBL_STRUCT_TABLE
		end select
		
		'extract if the table uses Hash
		do
			i=romfile.find(romfile.pointer,chr(TBL_FIELD_SEPARATOR),1) 
			tbl_check_for_missing_fields(i,line_end)			
			s=romfile.getdata(i-romfile.pointer)
			romfile.pointer=i+1
		loop while s="" 		
		if s="Y" then 
			tbl_info(tbl_num).hash=YES
		else
			tbl_info(tbl_num).hash=NO
		end if
		'extract number of keys	
		do
			s=romfile.getdata(1)
		loop while s=chr(TBL_FIELD_SEPARATOR)
		
		tbl_info(tbl_num).Numkeyf=val(s)
		romfile.pointer=romfile.pointer-1
		i=romfile.pointer
		s=romfile.getdata(line_end-i)
		
		'exceeded the max number of settings?
		if tbl_num>=MAX_NUM_TABLES and i<>0 then
			sys.halt
			tbl_num=0 'you need to increase MAX_NUM_SETTINGS!
		end if
		i=romfile.find(romfile.pointer,">>",1)
		tbl_num=tbl_num+1		
	wend
	
	for j =0 to MAX_NUM_TABLES-1
		k=0
		s=tbl_info(j).TableName+".txt"
		romfile.open(s)				
		i=romfile.find(romfile.pointer,">>",1)
#if TABLE_HASH_ENABLED=1
		tbl_info(j).Fields(k).FieldName ="MD5"
		tbl_info(j).Fields(k).FieldType=asc("Z")
		tbl_info(j).Fields(k).key=no
		tbl_info(j).Fields(k).p1=0
		tbl_info(j).Fields(k).p2=4294967295 
		tbl_info(j).Fields(k).romaddr_def=0
		k=k+1
#endif
#if GEN_UID_ENABLED=1
		tbl_info(j).Fields(k).FieldName ="UID"
		tbl_info(j).Fields(k).FieldType=asc("Z")
		tbl_info(j).Fields(k).key=yes
		tbl_info(j).Fields(k).p1=0
		tbl_info(j).Fields(k).p2=2147483647 
		tbl_info(j).Fields(k).romaddr_def=0
		k=k+1	
#endif		
		f=1 'including the 1 byte active flag
		while i<>0
			romfile.pointer=i+2
			'find the end of this setting descriptor line
			line_end=romfile.find(romfile.pointer,chr(TBL_END_OF_LINE),1)
			
			'extract field name
			do
				i=romfile.find(romfile.pointer,chr(TBL_FIELD_SEPARATOR),1) 
				tbl_check_for_missing_fields(i,line_end)			
				s=romfile.getdata(i-romfile.pointer)
				romfile.pointer=i+1
			loop while s="" 		
			'name too long?
			
			if len(s)>MAX_FLD_NAME_LEN then
				sys.halt	'you need to increase MAX_FLD_NAME_LEN!
			end if
			tbl_info(j).Fields(k).FieldName=s

			'extract setting type
			do
				i=romfile.find(romfile.pointer,chr(TBL_FIELD_SEPARATOR),1) 
				tbl_check_for_missing_fields(i,line_end)			
				s=romfile.getdata(i-romfile.pointer)
				romfile.pointer=i+1
			loop while s="" 		
			select case s
			case "S","B","W","I","L","Y","D":
			case else
				sys.halt'unknown setting type
			end select
			tbl_info(j).Fields(k).FieldType=asc(s)

			'extract p1
			do
				i=romfile.find(romfile.pointer,chr(TBL_FIELD_SEPARATOR),1) 
				tbl_check_for_missing_fields(i,line_end)			
				s=romfile.getdata(i-romfile.pointer)
				romfile.pointer=i+1
			loop while s="" 		
			
			select case tbl_info(j).Fields(k).FieldType
			case `B`,`S`:
				if val(s)>255 then
					sys.halt
					'minimum value (p1 param) for byte settings can't exceed 255
					'minimum length (p1 param) for string and dot-decimal settings can't exceed 255
				end if
			end select
			'we do not need to check word
			tbl_info(j).Fields(k).p1=val(s)

			'extract p2
			do
				i=romfile.find(romfile.pointer,chr(TBL_FIELD_SEPARATOR),1) 
				tbl_check_for_missing_fields(i,line_end)			
				s=romfile.getdata(i-romfile.pointer)
				romfile.pointer=i+1
			loop while s="" 		

			select case tbl_info(j).Fields(k).FieldType
			case `B`,`S`:
				if val(s)>255 then
					sys.halt
					'maximum value (p1 param) for byte settings can't exceed 255
					'maximum length (p1 param) for string and dot-decimal settings can't exceed 255
				end if
			
			end select
			'we do not need to check word
			tbl_info(j).Fields(k).p2=val(s)

			if tbl_info(j).Fields(k).FieldType<>`D` and tbl_info(j).Fields(k).p2<tbl_info(j).Fields(k).p1 then
				sys.halt	'p2 parameter cannot be smaller than p1 parameter
			end if
			
			'memorize the offset of the default value
			do
			s=romfile.getdata(1)
			loop while s=chr(TBL_FIELD_SEPARATOR)
			'are we at the end of the string?
			if s=chr(TBL_FIELD_SEPARATOR) then
				sys.halt 'default value field is missing in the descriptor
			end if
			tbl_info(j).Fields(k).romaddr_def=romfile.pointer-1
			
			f=f+tbl_get_field_size(j,k)
	
			i=romfile.find(romfile.pointer,">>",1)
			k=k+1
		wend
		
		f=f+8

		if tbl_info(j).Struct=EN_TBL_STRUCT_LIST then
			i=2
			while 128 mod f >0 and f < 128 and f > 0
				if f > i then 
					i=i*2
				else
					f=i
				end if
			wend
		end if
		
		if f>MAX_RECORD_SIZE then
			sys.halt	'record size is too big
		end if
		tbl_info(j).RecSize=f
		s=tbl_info(j).TableName
		tbl_info(j).fnum=TBL_START_FNUM+j
		fd.filenum=tbl_info(j).fnum
		fd_status=fd.open(s)
		select case fd_status
		case PL_FD_STATUS_NOT_FOUND
			'need to create this file
			fd_status=fd.create(s)
			tbl_attributes_sg(s,"","",EN_TBL_SET)
			if fd_status<>PL_FD_STATUS_OK then
				tbl_info(j).RecPointer=0
				goto fd_error
			end if
			fd_status=fd.open(s)
			if fd_status<>PL_FD_STATUS_OK then
				tbl_info(j).RecPointer=0
				goto fd_error
			end if
		case PL_FD_STATUS_OK
			'all is good -- just reset the file size to 0
			tbl_info(j).RecPointer=1
		case else
			'some other problem
			tbl_info(j).RecPointer=0
			goto fd_error
		end select
	next j
	goto tbl_ok

fd_error:
	select case fd.laststatus
	case PL_FD_STATUS_OK: goto tbl_ok
	case PL_FD_STATUS_ALREADY_OPENED: goto tbl_ok
	case PL_FD_STATUS_DUPLICATE_NAME: goto tbl_ok
	case else goto tbl_fail
	end select
	
tbl_ok:
	tbl_init=EN_TBL_STATUS_OK
	goto finish
tbl_fail:
	tbl_init=EN_TBL_STATUS_FAILURE	'fd errors, and other errors
	goto finish
finish:
	tbl_num=0
	if fd.ready=NO then tbl_init=EN_TBL_STATUS_FAILURE
	if tbl_init=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function

'------------------------------------------------------------------------------
sub tbl_mod_HASH(byref d as dword)
'Update the hash value that is stored in the file attribute.
	dim pos as byte
	dim msw, lsw as word
	dim hash_val as dword
	dim hash as string(4)
	dim rec_num as word
	
	'read the current table hash from the file attribute
	tbl_attributes_sg(selected_tbl_name,"HASH",hash,EN_TBL_GET)

	'calculating new hash value
	msw=asc(left(hash,1))*256+asc(mid(hash,2,1))
	lsw=asc(mid(hash,3,1))*256+asc(mid(hash,4,1))
	hash_val=msw*65536+lsw
	hash_val=hash_val xor d
	msw=hash_val/65536
	lsw=hash_val mod 65536
	hash=chr(msw/256)+chr(msw mod 256)+chr(lsw/256)+chr(lsw mod 256)
	
	'store the new hash value to the file attribute
	tbl_attributes_sg(selected_tbl_name,"HASH",hash,EN_TBL_SET)
end sub

'------------------------------------------------------------------------------
#if TABLE_HASH_ENABLED=1
public function tbl_set_md5() as dword
'Calculate the MD5 of tbl_record_string, store it in the table, and also modify the table hash.
	dim temp as string
	dim sFldVal as string(TBL_MAX_FIELD_LEN)
	dim i as byte
	dim d as dword
	dim msw, lsw as word
	dim start_index as byte
	start_index=0
#if GEN_UID_ENABLED=1
	tbl_field_sg("UID",sFldVal,EN_TBL_GET)
	temp=chr(ELEMENT_START)+"I"+chr(ELEMENT_NAME_VALUE_SEPARATOR)+sFldVal+chr(ELEMENT_END)
	start_index=start_index+1
#endif
	for i=start_index+1 to MAX_NUM_FIELD-1
		if tbl_info(tbl_num).Fields(i).FieldName="" then exit for
		if tbl_field_sg(tbl_info(tbl_num).Fields(i).FieldName,sFldVal,EN_TBL_GET)=EN_TBL_STATUS_OK then
			if tbl_info(tbl_num).Fields(i).FieldType=`D` then 
				select case tbl_info(tbl_num).Fields(i).p1
				case EN_TBL_DT_DATE:
				case EN_TBL_DT_TIME1:
				case EN_TBL_DT_TIME2:
				case EN_TBL_DT_TIME3:
				case EN_TBL_DT_DATE_TIME1:
				case EN_TBL_DT_DATE_TIME2:
				case EN_TBL_DT_ALL:
					time_style_format(sFldVal,3,0)
				end select
			end if
			temp=temp+chr(ELEMENT_START)+sFldVal+chr(ELEMENT_END)
		end if
	next i
	sFldVal=md5(temp,"",MD5_FINISH,len(temp))
	msw=asc(left(sFldVal,1))*256+asc(mid(sFldVal,2,1))
	lsw=asc(mid(sFldVal,3,1))*256+asc(mid(sFldVal,4,1))
	d=msw*65536 + lsw
	sFldVal=lstr(d)
	tbl_field_sg("MD5",sFldVal,EN_TBL_SET)
	tbl_set_md5=lval(sFldVal)
end function

'------------------------------------------------------------------------------
public function tbl_get_hash() as string(10)
'Returns the current hash value of the table which is store in the attribute of the file.
	dim hash as string(4)
	dim msw, lsw as word
	dim hash_val as dword
	if selected_tbl_active_rc=0 then 
		hash_val=0
	else
		tbl_attributes_sg(selected_tbl_name,"HASH",hash,EN_TBL_GET)
		msw=asc(left(hash,1))*256+asc(mid(hash,2,1))
		lsw=asc(mid(hash,3,1))*256+asc(mid(hash,4,1))
		hash_val=msw*65536 + lsw
	end if
	tbl_get_hash=lstri(hash_val)
end function
#endif

'------------------------------------------------------------------------------
public function tbl_record_number_get(byref num_of_records as word, include_deleted as no_yes) as en_tbl_status
'Gets total number of records (both active and inactive)
	dim fz as dword
	'calculate the number of records
	
	if selected_tbl_RecSize=0 then 
		tbl_record_number_get=EN_TBL_STATUS_UNKNOWN_TABLE
		goto finish
	end if
	if include_deleted=yes then
		fz=fd.filesize
		num_of_records=fz/selected_tbl_RecSize
	else
		num_of_records=selected_tbl_active_rc
	end if
	tbl_record_number_get=EN_TBL_STATUS_OK
finish:
	if fd.ready=NO then tbl_record_number_get=EN_TBL_STATUS_FAILURE
	if tbl_record_number_get=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function

'------------------------------------------------------------------------------
public function tbl_record_ptr_sg(byref record_num as word,op as en_tbl_rdwr) as en_tbl_status
'Sets the record pointer for a record
	dim dPtr as dword
	
	if fd.ready=NO then goto tbl_fail
	if op=EN_TBL_GET then
		record_num=tbl_info(tbl_num).RecPointer
		goto tbl_ok		
	else
		if record_num > selected_tbl_all_rc then
			dPtr=fd.filesize+1
			tbl_info(tbl_num).RecPointer=selected_tbl_all_rc+1
			if fd.pointer <> dPtr then fd.setpointer(dPtr)
		else
			tbl_info(tbl_num).RecPointer=record_num
			dPtr=(tbl_info(tbl_num).RecPointer-1)*selected_tbl_RecSize+1
			if fd.pointer <> dPtr then fd.setpointer(dPtr)
			goto tbl_ok
		end if
	end if
tbl_ok:
	tbl_record_ptr_sg=EN_TBL_STATUS_OK
	goto finish
tbl_unknown_tbl:
	tbl_record_ptr_sg=EN_TBL_STATUS_UNKNOWN_TABLE
	goto finish
tbl_fail:
	tbl_record_ptr_sg=EN_TBL_STATUS_FAILURE	'fd errors, and other errors
finish:
	if fd.ready=NO then tbl_record_ptr_sg=EN_TBL_STATUS_FAILURE
	if tbl_record_ptr_sg=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function

'------------------------------------------------------------------------------
public function tbl_record_add(byref tbl_uid_string as string(10)) as en_tbl_status
'Add a record, record data is from tbl_record_string
	dim temp as string(MAX_RECORD_SIZE)
	dim daddr1,dwtemp as dword
	dim w as word
	dim add_to_deleted_position as no_yes
	
	if fd.ready=NO then goto tbl_fail	
#if GEN_UID_ENABLED=1			
	dim result as en_tbl_status
	result=tbl_gen_UID(tbl_uid_string)
	if result=EN_TBL_STATUS_OK then
	else
		tbl_record_add=result
	goto finish
	end if
#endif
#if TABLE_HASH_ENABLED=1	
	dim md5_val as dword
	md5_val=tbl_set_md5()
#endif

	if tbl_check_key_violation(w)=YES then goto tbl_key_violate
	
	'check if table is full
	if selected_tbl_active_rc>selected_tbl_Maxrecs-1 then goto tbl_full
	
	'find the first deleted record, if not found move the pointer to the end of file and set data
	if selected_tbl_Struct=EN_TBL_STRUCT_LIST then
		daddr1=fd.filesize+1
		add_to_deleted_position=NO
	else
		daddr1=fd.find(1,DELETE_FLAG,1,FORWARD,selected_tbl_RecSize,PL_FD_FIND_EQUAL)
		if daddr1=0 then 
			daddr1=fd.filesize+1
			add_to_deleted_position=NO
		else
			add_to_deleted_position=YES
		end if
	end if
	fd.setpointer(daddr1)
	tbl_record_string=mid(tbl_record_string,2,selected_tbl_RecSize-1)
	tbl_record_string=ACTIVE_FLAG+tbl_record_string
	temp=strgen(selected_tbl_RecSize-len(tbl_record_string),chr(NULL))
	tbl_record_string=tbl_record_string+temp

	if fd.transactionstart<>PL_FD_STATUS_OK then goto fd_error
	if fd.setdata(tbl_record_string)<>PL_FD_STATUS_OK then goto fd_error 
	selected_tbl_active_rc=selected_tbl_active_rc+1
	if add_to_deleted_position<>YES then selected_tbl_all_rc=selected_tbl_all_rc+1
	if tbl_active_rc_sg(selected_tbl_active_rc,EN_TBL_SET)<>PL_FD_STATUS_OK then goto fd_error
	if fd.transactioncommit<>PL_FD_STATUS_OK then goto fd_error
	goto tbl_ok

fd_error:	
	select case fd.laststatus
	case PL_FD_STATUS_OK: goto tbl_ok
	case PL_FD_STATUS_ALREADY_OPENED: goto tbl_ok
	case PL_FD_STATUS_DUPLICATE_NAME: goto tbl_ok
	case PL_FD_STATUS_NOT_FOUND: goto tbl_unknown_tbl
	case PL_FD_STATUS_NOT_OPENED: goto tbl_unknown_tbl
	case PL_FD_STATUS_DATA_FULL: goto tbl_full
	case else goto tbl_fail
	end select
tbl_ok:
	#if TABLE_HASH_ENABLED=1					
		tbl_mod_HASH(md5_val)
	#endif
	tbl_info(tbl_num).RecPointer=fd.pointer/selected_tbl_RecSize
	tbl_record_add=EN_TBL_STATUS_OK
	goto finish
tbl_unknown_tbl:
	tbl_record_add=EN_TBL_STATUS_UNKNOWN_TABLE
	goto finish
tbl_fail:
	tbl_record_add=EN_TBL_STATUS_FAILURE	'fd errors, and other errors
	goto finish
tbl_full:
	tbl_record_add=EN_TBL_STATUS_FULL
	goto finish
tbl_key_violate:
	tbl_record_add=EN_TBL_STATUS_KEY_VIOLATION
	goto finish
finish:
	if fd.transactionstarted=YES then fd.transactioncommit
	if fd.ready=NO then tbl_record_add=EN_TBL_STATUS_FAILURE		
	if tbl_record_add=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function
 
'------------------------------------------------------------------------------
public function tbl_record_edit() as en_tbl_status
'Changes the current record (tbl_record_ptr) by data from tbl_record_string
	dim tbl_result as en_tbl_status
	dim w as word
	dim key_violation_found as no_yes
	
#if TABLE_HASH_ENABLED=1
	dim md5_val,md5_val_old as dword
	dim md5_string as string(16)
	tbl_result=tbl_field_sg("MD5",md5_string,EN_TBL_GET)
	if tbl_result<>EN_TBL_STATUS_OK then goto finish
	md5_val_old=lval(md5_string)
	md5_val=tbl_set_md5()
#endif
	key_violation_found=tbl_check_key_violation(w)
	if key_violation_found=YES and w<>tbl_info(tbl_num).RecPointer then 
		tbl_result=EN_TBL_STATUS_KEY_VIOLATION
	else
		tbl_result=tbl_record_sg(EN_TBL_SET)
	end if
	if tbl_result=EN_TBL_STATUS_OK then
#if TABLE_HASH_ENABLED=1
	tbl_mod_HASH(md5_val_old)
	tbl_mod_HASH(md5_val)
#endif
	end if
finish:
	tbl_record_edit=tbl_result
end function

'------------------------------------------------------------------------------
public function tbl_record_delete() as en_tbl_status
'Deletes (marks as unused) current record (tbl_record_ptr)
	dim dPtr as dword
	
	if fd.ready=NO then goto tbl_fail
	
	'examine if the record is deleted
	if selected_tbl_Struct=EN_TBL_STRUCT_LIST then
		dPtr=fd.find(1,ACTIVE_FLAG,1,FORWARD,selected_tbl_RecSize,PL_FD_FIND_EQUAL)
	else
		dPtr=(tbl_info(tbl_num).RecPointer-1)*selected_tbl_RecSize+1
	end if
	fd.setpointer(dPtr)
	if fd.getdata(1)=DELETE_FLAG then goto tbl_deleted
	if fd.laststatus<>PL_FD_STATUS_OK then goto fd_error
	fd.setpointer(dPtr)
	'delete record
	if selected_tbl_active_rc>0 then	
		if fd.transactionstart<>PL_FD_STATUS_OK then goto fd_error
			selected_tbl_active_rc=selected_tbl_active_rc-1
			if tbl_active_rc_sg(selected_tbl_active_rc,EN_TBL_SET)<>PL_FD_STATUS_OK then goto fd_error
			if fd.setdata(DELETE_FLAG)<>PL_FD_STATUS_OK then goto fd_error
			if tbl_adjust_size()<>EN_TBL_STATUS_OK then goto fd_error
		if fd.transactioncommit<>PL_FD_STATUS_OK then goto fd_error	
	else
		goto tbl_deleted
	end if
	goto tbl_ok
	
fd_error:
	select case fd.laststatus
	case PL_FD_STATUS_OK: goto tbl_ok
	case PL_FD_STATUS_ALREADY_OPENED: goto tbl_ok
	case PL_FD_STATUS_DUPLICATE_NAME: goto tbl_ok
	case PL_FD_STATUS_NOT_OPENED: goto tbl_unknown_tbl
	case PL_FD_STATUS_NOT_FOUND: goto tbl_deleted
	case else goto tbl_fail
	end select
	
tbl_ok:
#if TABLE_HASH_ENABLED=1
	tbl_set_md5()
#endif
	tbl_record_delete=EN_TBL_STATUS_OK
	goto finish
tbl_fail:
	tbl_record_delete=EN_TBL_STATUS_FAILURE
	goto finish
tbl_unknown_tbl:
	tbl_record_delete=EN_TBL_STATUS_UNKNOWN_TABLE
	goto finish
tbl_deleted:
	tbl_record_delete=EN_TBL_STATUS_DELETED
	goto finish
finish:
	if fd.transactionstarted=YES then fd.transactioncommit
	if fd.ready=NO then tbl_record_delete=EN_TBL_STATUS_FAILURE
	if tbl_record_delete=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function

'------------------------------------------------------------------------------
public function tbl_timestamp_sg(byref timestamp as struct_tbl_timestamp,op as en_tbl_rdwr) as en_tbl_status
'Sets gets the timestamp for the table
	dim ts as string(7)

	if fd.ready=NO then goto tbl_fail
	
	if op=EN_TBL_GET then 
		if tbl_attributes_sg(selected_tbl_name,"TS",ts,EN_TBL_GET)<>PL_FD_STATUS_OK then goto fd_error

		timestamp.ts_daycount=256*asc(mid(ts,1,1))+asc(mid(ts,2,1))
		timestamp.ts_mincount=256*asc(mid(ts,3,1))+asc(mid(ts,4,1))
		timestamp.ts_seconds=asc(mid(ts,5,1))
		timestamp.ts_milsec=256*asc(mid(ts,6,1))+asc(mid(ts,7,1))
	else
		ts=chr(timestamp.ts_daycount/256)
		ts=ts+chr(timestamp.ts_daycount and &hFF)
		ts=ts+chr(timestamp.ts_mincount/256)
		ts=ts+chr(timestamp.ts_mincount and &hFF)
		ts=ts+chr(timestamp.ts_seconds)
		ts=ts+chr(timestamp.ts_milsec/256)
		ts=ts+chr(timestamp.ts_milsec and &hFF)
		tbl_attributes_sg(selected_tbl_name,"TS",ts,EN_TBL_SET)
	end if
	goto tbl_ok

fd_error:
	select case fd.laststatus
	case PL_FD_STATUS_OK: goto tbl_ok
	case PL_FD_STATUS_ALREADY_OPENED: goto tbl_ok
	case PL_FD_STATUS_DUPLICATE_NAME: goto tbl_ok
	case PL_FD_STATUS_NOT_FOUND: goto tbl_unknown_tbl
	case PL_FD_STATUS_NOT_OPENED: goto tbl_unknown_tbl
	case else goto tbl_fail
	end select
	
tbl_ok:
	tbl_timestamp_sg=EN_TBL_STATUS_OK
	goto finish
tbl_fail:
	tbl_timestamp_sg=EN_TBL_STATUS_FAILURE
	goto finish
tbl_unknown_tbl:
	tbl_timestamp_sg=EN_TBL_STATUS_UNKNOWN_TABLE
	goto finish
finish:
	if fd.ready=NO then tbl_timestamp_sg=EN_TBL_STATUS_FAILURE
	if tbl_timestamp_sg=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function

'------------------------------------------------------------------------------
public function tbl_record_find(
		include_deleted as no_yes,  						'If the search includes the records that are marked as deleted.
		byref search_data as string, 						'Searching criteria data.
		byref starting_field as string(MAX_FLD_NAME_LEN), 	'Searching criteria name.
		byref num_records as word, 							'Starting record number, also returns the first found record number
		direction as en_tbl_search_direction, 				'Searching direction
		find_method as pl_fd_find_modes) as en_tbl_status	'find method (equal, greater, lesser, etc.)
'Searches through records, looks for "search_data" pattern (starting at "starting_field")
'Search starts at current (tbl_record_ptr) record, goes until the edge of table or for num_records
'Serach direction depends on "direction"
'Search stops at the first matching record found, tbl_record_ptr is set to this record's number
	
	dim i as byte
	dim daddr,daddr_temp,daddr_offset as dword
	dim fld_num as byte
	dim s as string
	dim w1, w2 as word
	dim temp1 as string(3)
	
	if fd.ready=NO then goto tbl_fail

	if num_records=0 or num_records>selected_tbl_all_rc then goto tbl_not_found
	daddr=(num_records-1)
	daddr=daddr*selected_tbl_RecSize+1
	
	if search_data<>"" then
		if tbl_field_find(starting_field, fld_num)=EN_TBL_STATUS_UNKNOWN_FIELD then goto tbl_unknown_fld
		select case tbl_info(tbl_num).Fields(fld_num).FieldType
			case `D`:
				select case tbl_info(tbl_num).Fields(fld_num).p1
				case EN_TBL_DT_DATE:
					s=search_data+"000000"
					time_type_convert(s,"","","",STR_TO_BYTESTR)
					s=left(s,2)
				case EN_TBL_DT_TIME1:
					s="20000101"+search_data+"00"
					time_type_convert(s,"","","",STR_TO_BYTESTR)
					s=mid(s,3,2)
				case EN_TBL_DT_TIME2:
					s="20000101"+search_data
					time_type_convert(s,"","","",STR_TO_BYTESTR)
					s=mid(s,3,3)
				case EN_TBL_DT_TIME3:
					s="20000101"+left(search_data,6)
					temp1=mid(search_data,7,3)
					time_type_convert(s,"","","",STR_TO_BYTESTR)
					w1=val(temp1)/256
					w2=val(temp1) mod 256
					s=mid(s,3,3)+chr(w1)+chr(w2)
				case EN_TBL_DT_DATE_TIME1:
					s=search_data+"00"
					time_type_convert(s,"","","",STR_TO_BYTESTR)
					s=left(s,4)
				case EN_TBL_DT_DATE_TIME2:
					s=search_data
					time_type_convert(s,"","","",STR_TO_BYTESTR)
				case EN_TBL_DT_ALL:
					s=left(search_data,14)
					temp1=mid(search_data,15,3)
					time_type_convert(s,"","","",STR_TO_BYTESTR)
					w1=val(temp1)/256
					w2=val(temp1) mod 256
					s=s+chr(w1)+chr(w2)
				end select
			case `B`,`Y`:
				s=chr(val(search_data))
			case `W`,`I`:
				w1=val(search_data)/256
				w2=val(search_data) mod 256
				s=chr(w1)+chr(w2)
			case `S`:
				s=chr(len(search_data))+search_data
			case `L`:
				w1=lval(search_data)/65536
				w2=lval(search_data) mod 65536
				s=chr(w1/256)+chr(w1 mod 256)+chr(w2/256)+chr(w2 mod 256)
			case `Z`:
				w1=lval(search_data)/65536
				w2=lval(search_data) mod 65536
				s=chr(w1/256)+chr(w1 mod 256)+chr(w2/256)+chr(w2 mod 256)
		end select

		for i=0 to fld_num
			if i=0 then 
				daddr_offset= 1
			else
				daddr_offset=daddr_offset + tbl_get_field_size(tbl_num,i-1)
			end if
		next i
		daddr=daddr + daddr_offset		
query:
		daddr_temp=fd.find(daddr,s,1,direction,selected_tbl_RecSize,find_method)
		if daddr_temp=0 then
			goto tbl_not_found
		else 
			daddr=daddr_temp-daddr_offset
		end if
	end if
	if include_deleted=NO then
		daddr_temp=fd.find(daddr,ACTIVE_FLAG,1,direction,selected_tbl_RecSize,PL_FD_FIND_EQUAL)
		if daddr_temp=0 then
			goto tbl_not_found
		end if
		if daddr_temp<>daddr then 
			if search_data<>"" then goto query
			daddr=daddr_temp
		end if
	end if
	num_records=daddr/selected_tbl_RecSize+1
	tbl_info(tbl_num).RecPointer=num_records

tbl_ok:
	tbl_record_find=EN_TBL_STATUS_OK
	goto finish
tbl_fail:
	tbl_info(tbl_num).RecPointer=0
	num_records=0
	tbl_record_find=EN_TBL_STATUS_FAILURE
	goto finish
tbl_unknown_tbl:
	tbl_info(tbl_num).RecPointer=0
	num_records=0
	tbl_record_find=EN_TBL_STATUS_UNKNOWN_TABLE
	goto finish
tbl_unknown_fld:
	tbl_info(tbl_num).RecPointer=0
	num_records=0
	tbl_record_find=EN_TBL_STATUS_UNKNOWN_FIELD
	goto finish
tbl_not_found:
	tbl_info(tbl_num).RecPointer=0
	num_records=0
	tbl_record_find=EN_TBL_STATUS_NOT_FOUND
finish:
	if fd.ready=NO then tbl_record_find=EN_TBL_STATUS_FAILURE
	if tbl_record_find=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function

'------------------------------------------------------------------------------
public function tbl_field_sg(byref field_name as string(MAX_FLD_NAME_LEN),byref field_value as string,op as en_tbl_rdwr) as en_tbl_status
'Extract the field from tbl_record_string or puts the field into the tbl_record_string
	dim i,fld_pos,fld_sz,b1,lsb,msb as byte
	dim s,temp1,temp2 as string(MAX_RECORD_SIZE)
	dim w1,w2,w3 as word
	dim d as dword
	dim l as long
	dim bp1, bp2 as byte
	dim wp1, wp2 as word
	dim dp1, dp2 as dword
	dim fld_num as byte
	'find field
	if tbl_field_find(field_name, fld_num)<>EN_TBL_STATUS_OK then goto tbl_unknown_fld
	fld_pos=2
	for i=1 to fld_num
		fld_pos=fld_pos+tbl_get_field_size(tbl_num,i-1)
	next i
	fld_sz=tbl_get_field_size(tbl_num,fld_num)
	if op=EN_TBL_GET then
		s=mid(tbl_record_string,fld_pos,fld_sz) 
		select case tbl_info(tbl_num).Fields(fld_num).FieldType
			case `D`:
				select case tbl_info(tbl_num).Fields(fld_num).p1
				case EN_TBL_DT_DATE:
					s=s+chr(0)+chr(0)+chr(0)
					time_type_convert(s,w1,w2,b1,BYTESTR_TO_STR)
					field_value=left(s,8)
					if w1>36524 then goto tbl_invalid
				case EN_TBL_DT_TIME1:
					s=chr(0)+chr(0)+s+chr(0)
					time_type_convert(s,w1,w2,b1,BYTESTR_TO_STR)
					field_value=mid(s,9,4)
					if w2>1439 then goto tbl_invalid
				case EN_TBL_DT_TIME2:
					s=chr(0)+chr(0)+s
					time_type_convert(s,w1,w2,b1,BYTESTR_TO_STR)
					field_value=right(s,6)
					if w2>1439 or b1>60 then goto tbl_invalid
				case EN_TBL_DT_TIME3:
					w1=asc(mid(s,4,1))*256+asc(mid(s,5,1))
					temp1=str(w1)
					s=chr(0)+chr(0)+left(s,3)
					time_type_convert(s,w1,w2,b1,BYTESTR_TO_STR)
					field_value=mid(s,9,6)+temp1
					if w2>1439 or b1>60 or val(temp1)>999 then goto tbl_invalid
				case EN_TBL_DT_DATE_TIME1:
					s=s+chr(0)
					time_type_convert(s,w1,w2,b1,BYTESTR_TO_STR)
					field_value=left(s,12)
					if w1>36524 or w2>1439 then goto tbl_invalid
				case EN_TBL_DT_DATE_TIME2:
					time_type_convert(s,w1,w2,b1,BYTESTR_TO_STR)
					field_value=s
					if w1>36524 or b1>60 or w2>1439 then goto tbl_invalid
				case EN_TBL_DT_ALL:
					w1=asc(mid(s,6,1))*256+asc(mid(s,7,1))
					temp1=str(w1)
					time_type_convert(s,w1,w2,b1,BYTESTR_TO_STR)
					field_value=s+temp1
					if w1>36524 or b1>60 or w2>1439 or val(temp1)>999 then goto tbl_invalid
				end select
			case `B`,`Y`:
				field_value=str(asc(s))
				bp1=tbl_info(tbl_num).Fields(fld_num).p1
				bp2=tbl_info(tbl_num).Fields(fld_num).p2
				if val(field_value) < bp1 then goto tbl_invalid
				if val(field_value) > bp2 then goto tbl_invalid				
			case `W`:
				w1=asc(left(s,1))*256+asc(mid(s,2,1))
				field_value=str(w1)
				wp1=tbl_info(tbl_num).Fields(fld_num).p1
				wp2=tbl_info(tbl_num).Fields(fld_num).p2
				if lval(field_value)<wp1 then goto tbl_invalid
				if lval(field_value)>wp2 then goto tbl_invalid				
			case `S`:
				b1=asc(left(s,1))
				field_value=mid(s,2,b1)
				bp1=tbl_info(tbl_num).Fields(fld_num).p1
				bp2=tbl_info(tbl_num).Fields(fld_num).p2
				if b1 < bp1 then goto tbl_invalid
				if b1 > bp2 then goto tbl_invalid				
			case `I`:
				w1=asc(left(s,1))*256+asc(mid(s,2,1))
				field_value=stri(w1)
				wp1=tbl_info(tbl_num).Fields(fld_num).p1
				wp2=tbl_info(tbl_num).Fields(fld_num).p2
				if lval(field_value)<wp1 then goto tbl_invalid
				if lval(field_value)>wp2 then goto tbl_invalid						
			case `L`:
				w2=asc(left(s,1))*256+asc(mid(s,2,1))
				w3=asc(mid(s,3,1))*256+asc(mid(s,4,1))
				l=w2*65536+w3
				field_value =lstri(l)
				dp1=tbl_info(tbl_num).Fields(fld_num).p1
				dp2=tbl_info(tbl_num).Fields(fld_num).p2			
				if lval(field_value) < dp1 then goto tbl_invalid
				if lval(field_value) > dp2 then goto tbl_invalid				
			case `Z`:
				w2=asc(left(s,1))*256+asc(mid(s,2,1))
				w3=asc(mid(s,3,1))*256+asc(mid(s,4,1))
				d=w2*65536+w3
				field_value=lstr(d)
				dp1=tbl_info(tbl_num).Fields(fld_num).p1
				dp2=tbl_info(tbl_num).Fields(fld_num).p2
				if lval(field_value)<dp1 then goto tbl_invalid
				if lval(field_value)>dp2 then goto tbl_invalid				
		end select	
		goto tbl_ok
	else
		select case tbl_info(tbl_num).Fields(fld_num).FieldType
			case `D`:
				select case tbl_info(tbl_num).Fields(fld_num).p1
				case EN_TBL_DT_DATE:
					s=field_value+"000000"
					time_type_convert(s,w1,w2,b1,STR_TO_BYTESTR)
					s=left(s,2)
					if w1>36524 then goto tbl_invalid
				case EN_TBL_DT_TIME1:
					s="20000101"+field_value+"00"
					time_type_convert(s,w1,w2,b1,STR_TO_BYTESTR)
					s=mid(s,3,2)
					if w2>1439 then goto tbl_invalid
				case EN_TBL_DT_TIME2:
					s="20000101"+field_value
					time_type_convert(s,w1,w2,b1,STR_TO_BYTESTR)
					s=mid(s,3,3)
					if w2>1439 or b1>60 then goto tbl_invalid
				case EN_TBL_DT_TIME3:
					s="20000101"+left(field_value,6)
					temp1=mid(field_value,7,3)
					time_type_convert(s,w1,w2,b1,STR_TO_BYTESTR)
					msb=val(temp1)/256
					lsb=val(temp1) mod 256
					s=mid(s,3,3)+chr(msb)+chr(lsb)
					if w2>1439 or b1>60 or val(temp1)>999 then goto tbl_invalid
				case EN_TBL_DT_DATE_TIME1:
					s=field_value+"00"
					time_type_convert(s,w1,w2,b1,STR_TO_BYTESTR)
					s=left(s,4)
					if w1>36524 or w2>1439 then goto tbl_invalid
				case EN_TBL_DT_DATE_TIME2:
					s=field_value
					time_type_convert(s,w1,w2,b1,STR_TO_BYTESTR)
					if w1>36524 or b1>60 or w2>1439 then goto tbl_invalid
				case EN_TBL_DT_ALL:
					s=left(field_value,14)
					temp1=mid(field_value,15,3)
					time_type_convert(s,w1,w2,b1,STR_TO_BYTESTR)
					msb=val(temp1)/256
					lsb=val(temp1) mod 256
					s=s+chr(msb)+chr(lsb)
					if w1>36524 or b1>60 or w2>1439 or val(temp1)>999 then goto tbl_invalid
				end select
			case `B`,`Y`:
				bp1=tbl_info(tbl_num).Fields(fld_num).p1
				bp2=tbl_info(tbl_num).Fields(fld_num).p2
				if val(field_value) < bp1 then goto tbl_invalid
				if val(field_value) > bp2 then goto tbl_invalid
				s=chr(val(field_value))
			case `W`,`I`:
				wp1=tbl_info(tbl_num).Fields(fld_num).p1
				wp2=tbl_info(tbl_num).Fields(fld_num).p2
				if lval(field_value)<wp1 then goto tbl_invalid
				if lval(field_value)>wp2 then goto tbl_invalid
				msb=val(field_value)/256
				lsb=val(field_value) mod 256
				s=chr(msb)+chr(lsb)
			case `S`:
				bp1=tbl_info(tbl_num).Fields(fld_num).p1
				bp2=tbl_info(tbl_num).Fields(fld_num).p2
				if len(field_value) < bp1 then goto tbl_invalid
				if len(field_value) > bp2 then goto tbl_invalid
				s=chr(len(field_value))+field_value+strgen(fld_sz-len(field_value)-1,chr(NULL))
			case `L`:
				dp1=tbl_info(tbl_num).Fields(fld_num).p1
				dp2=tbl_info(tbl_num).Fields(fld_num).p2			
				if lval(field_value) < dp1 then goto tbl_invalid
				if lval(field_value) > dp2 then goto tbl_invalid
				w2=lval(field_value)/65536
				w3=lval(field_value) mod 65536
				s=chr(w2/256)+chr(w2 mod 256)+chr(w3/256)+chr(w3 mod 256)
			case `Z`:
				dp1=tbl_info(tbl_num).Fields(fld_num).p1
				dp2=tbl_info(tbl_num).Fields(fld_num).p2
				if lval(field_value)<dp1 then goto tbl_invalid
				if lval(field_value)>dp2 then goto tbl_invalid
				w2=lval(field_value)/65536
				w3=lval(field_value) mod 65536
				s=chr(w2/256)+chr(w2 mod 256)+chr(w3/256)+chr(w3 mod 256)
		end select
		temp1=left(tbl_record_string, fld_pos-1)
		temp2=right(tbl_record_string,len(tbl_record_string)-fld_pos-fld_sz+1)
		tbl_record_string=temp1+s+temp2
		goto tbl_ok
	end if
tbl_ok:
	tbl_field_sg=EN_TBL_STATUS_OK
	goto finish
tbl_unknown_tbl:
	tbl_field_sg=EN_TBL_STATUS_UNKNOWN_TABLE
	goto finish
tbl_unknown_fld:
	tbl_field_sg=EN_TBL_STATUS_UNKNOWN_FIELD
	goto finish
tbl_invalid:
	tbl_field_sg=EN_TBL_STATUS_INVALID
finish:
	if fd.ready=NO then tbl_field_sg=EN_TBL_STATUS_FAILURE
	if tbl_field_sg=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function

'------------------------------------------------------------------------------
public function tbl_record_sg(op as en_tbl_rdwr) as en_tbl_status
'Loads the record pointed at by tbl_record_ptr to tbl_record_string
	dim dPtr as dword

	if fd.ready=NO then goto tbl_fail
	
	'set pointer
	dPtr=(tbl_info(tbl_num).RecPointer-1)
	dPtr=dPtr*selected_tbl_RecSize+1
	if fd.pointer<>dPtr then fd.setpointer(dPtr)
	if op=EN_TBL_GET then
	'get data
		if fd.pointer>fd.filesize or fd.filesize=0 then goto tbl_not_found
		tbl_record_string=fd.getdata(selected_tbl_RecSize)
		if fd.laststatus<>PL_FD_STATUS_OK then goto fd_error
	else
	'set data
		if fd.transactionstart()<>PL_FD_STATUS_OK then goto fd_error
		if fd.setdata(tbl_record_string)<>PL_FD_STATUS_OK then goto fd_error
		if fd.transactioncommit()<>PL_FD_STATUS_OK then goto fd_error
	end if
	goto tbl_ok

fd_error:
	select case fd.laststatus
	case PL_FD_STATUS_OK: goto tbl_ok
	case PL_FD_STATUS_ALREADY_OPENED: goto tbl_ok
	case PL_FD_STATUS_DUPLICATE_NAME: goto tbl_ok
	case PL_FD_STATUS_NOT_FOUND: goto tbl_unknown_tbl
	case PL_FD_STATUS_NOT_OPENED: goto tbl_unknown_tbl
	case else goto tbl_fail
	end select
tbl_ok:
	tbl_record_sg=EN_TBL_STATUS_OK
	goto finish
tbl_not_found:
	tbl_record_sg=EN_TBL_STATUS_NOT_FOUND
	goto finish
tbl_unknown_tbl:
	tbl_record_sg=EN_TBL_STATUS_UNKNOWN_TABLE
	goto finish	
tbl_fail:
	tbl_record_sg=EN_TBL_STATUS_FAILURE
	goto finish
finish:
	if fd.transactionstarted=YES then fd.transactioncommit
	if fd.ready=NO then tbl_record_sg=EN_TBL_STATUS_FAILURE
	if tbl_record_sg=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function

'------------------------------------------------------------------------------
public function tbl_field_get_def(byref field_name as string(MAX_FLD_NAME_LEN), byref def_value as string) as en_tbl_status
'Loads default value for a field
	dim i, def_len as byte
	dim pos1, pos2 as word
	romfile.open(selected_tbl_name+".txt")
	
	for i=0 to MAX_NUM_FIELD-1
		if tbl_info(tbl_num).Fields(i).FieldName=field_name then
			pos1=tbl_info(tbl_num).Fields(i).romaddr_def
			pos2=romfile.find(pos1,chr(CR),1)
			romfile.pointer=pos1
			def_value=romfile.getdata(pos2-pos1)
			if def_value="^" then 
				def_value=""
			end if
			goto tbl_ok
		end if
	next i
	goto tbl_unknown_fld
tbl_ok:
	tbl_field_get_def=EN_TBL_STATUS_OK 
	goto finish
tbl_unknown_tbl:
	tbl_field_get_def=EN_TBL_STATUS_UNKNOWN_TABLE
	goto finish
tbl_unknown_fld:
	tbl_field_get_def=EN_TBL_STATUS_UNKNOWN_FIELD
finish:
	if fd.ready=NO then tbl_field_get_def=EN_TBL_STATUS_FAILURE
	if tbl_field_get_def=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function

'------------------------------------------------------------------------------
sub tbl_check_for_missing_fields(curr_pos as word, line_end_pos as word)
	if curr_pos=0 or curr_pos>line_end_pos then
		sys.halt
		'one of your descriptor lines has missing fields
	end if
end sub

'------------------------------------------------------------------------------
public function tbl_find(tbl_name as string(MAX_TBL_NAME_LEN)) as en_tbl_status
'Looking for the table in the table_info array, the table name can also be the index
	dim i as byte	
	i=asc(tbl_name)
	if i>=&h30 and i<=&h39 then
		i=val(tbl_name)
		goto check_index
	else
		for i=0 to MAX_NUM_TABLES - 1
			if tbl_info(i).TableName=tbl_name then
				goto check_index
			end if
		next i
	end if
	goto tbl_not_found
check_index:
	if i<MAX_NUM_TABLES then
		tbl_num=i
		tbl_find=EN_TBL_STATUS_OK
	else
tbl_not_found:
		tbl_num=0
		tbl_find=EN_TBL_STATUS_UNKNOWN_TABLE
	end if
end function

'------------------------------------------------------------------------------
function tbl_field_find(field_name as string, byref fld_num as byte) as en_tbl_status
	dim i as byte
	for i=0 to MAX_NUM_FIELD-1
		if tbl_info(tbl_num).Fields(i).FieldName=field_name then 
			fld_num=i
			tbl_field_find=EN_TBL_STATUS_OK
			exit function
		end if
	next i
	tbl_field_find=EN_TBL_STATUS_UNKNOWN_FIELD
end function

'------------------------------------------------------------------------------
public function tbl_get_field_size(tbl_index as byte, fld_index as byte) as byte
'Returns the size of the field (number of bytes)
	dim sz as byte
	select case tbl_info(tbl_index).Fields(fld_index).FieldType 
		case `D`:
			select case tbl_info(tbl_index).Fields(fld_index).p1
			case EN_TBL_DT_DATE: sz=2
			case EN_TBL_DT_TIME1: sz=2
			case EN_TBL_DT_TIME2: sz=3
			case EN_TBL_DT_TIME3: sz=5
			case EN_TBL_DT_DATE_TIME1: sz=4
			case EN_TBL_DT_DATE_TIME2: sz=5
			case EN_TBL_DT_ALL: sz=7
			end select
		case `B`,`Y`: sz=1
		case `W`,`I`: sz=2
		case `S`: sz=tbl_info(tbl_index).Fields(fld_index).p2+1
		case `L`,`Z`: sz=4 
		case else: sz =0
	end select
	tbl_get_field_size=sz
end function

'------------------------------------------------------------------------------
public function tbl_get_max_fld_sz(tbl_index as byte) as byte
'Returns the size of the largest field in the table.
	dim i, temp, sz as byte
	sz=0
	for i=0 to MAX_NUM_FIELD-1
		temp=tbl_get_field_size(tbl_index,i)>sz 
		if temp > sz then sz=temp
	next i
end function

'------------------------------------------------------------------------------
public function tbl_delete() as en_tbl_status
'Sets the file size to 0
	
	'if fd.transactionstart()<>PL_FD_STATUS_OK then goto tbl_fail <<<<<<<<< TEMPORARY
	if fd.setfilesize(0)<>PL_FD_STATUS_OK then goto tbl_fail
	if fd.transactionstart()<>PL_FD_STATUS_OK then goto tbl_fail '<<<<<<<<< TEMPORARY
	if tbl_attributes_sg(selected_tbl_name,"","",EN_TBL_SET)<>PL_FD_STATUS_OK then goto tbl_fail
	tbl_delete=tbl_record_number_get(selected_tbl_all_rc,yes)
	if tbl_delete<>EN_TBL_STATUS_OK then goto finish
	if tbl_active_rc_sg(selected_tbl_active_rc,EN_TBL_GET)<>PL_FD_STATUS_OK then goto tbl_fail
	if fd.transactioncommit()<>PL_FD_STATUS_OK then goto tbl_fail
	goto tbl_ok
	
tbl_ok:
	tbl_delete=EN_TBL_STATUS_OK
	goto finish
tbl_fail:
	tbl_delete=EN_TBL_STATUS_FAILURE
	goto finish
finish:
	if fd.transactionstarted=YES then fd.transactioncommit
	if fd.ready=NO then tbl_delete=EN_TBL_STATUS_FAILURE
	if tbl_delete=EN_TBL_STATUS_FAILURE then device_disk_error_detected()	
end function

'------------------------------------------------------------------------------
public function tbl_adjust_size() as en_tbl_status
'Look through the deleted record, if all record in 1 sector are deleted, then free the sector.
	dim deleted_record, record_per_sector, deleted_sector as word
	
	if fd.ready=NO then goto tbl_fail
	
	if selected_tbl_Struct<>EN_TBL_STRUCT_LIST then goto tbl_ok
	record_per_sector=256/selected_tbl_RecSize
	deleted_record=selected_tbl_all_rc-selected_tbl_active_rc
	deleted_sector=deleted_record/record_per_sector

	if deleted_sector>0 then
		tbl_info(tbl_num).RecPointer=1
		while deleted_sector>0
			if deleted_sector>2 then
				if fd.cutfromtop(2)<>PL_FD_STATUS_OK then goto tbl_fail
				deleted_sector=deleted_sector-2
				if deleted_sector>0 then
					if fd.transactioncommit<>PL_FD_STATUS_OK then goto tbl_fail
					if fd.transactionstart<>PL_FD_STATUS_OK then goto tbl_fail
				end if
			else
				if fd.cutfromtop(deleted_sector)<>PL_FD_STATUS_OK then goto tbl_fail
				deleted_sector=0
			end if
		wend
		tbl_record_number_get(selected_tbl_all_rc,yes)
	end if
	
tbl_ok:
	tbl_adjust_size=EN_TBL_STATUS_OK
	goto finish
tbl_fail:
	tbl_adjust_size=EN_TBL_STATUS_FAILURE
	goto finish
finish:
	if fd.ready=NO then tbl_adjust_size=EN_TBL_STATUS_FAILURE
	if tbl_adjust_size=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function

'------------------------------------------------------------------------------
public function tbl_get_tbl_info(byref tbl as tbl_type) as en_tbl_status
'Returns the table info structure
	dim tbl_temp as tbl_type
	dim i as byte
	tbl_temp=tbl_info(tbl_num)
	for i=0 to MAX_NUM_FIELD-1
		tbl_temp.Fields(i)=tbl_info(tbl_num).Fields(i)
	next i
	tbl=tbl_temp
tbl_ok:
	tbl_get_tbl_info=EN_TBL_STATUS_OK
	exit function
tbl_unknown_tbl:
	tbl_get_tbl_info=EN_TBL_STATUS_UNKNOWN_TABLE
end function

'------------------------------------------------------------------------------
function tbl_gen_UID(byref id_string as string(10)) as en_tbl_status
	dim result as en_tbl_status
	dim msw, lsw as word
	dim l as long
	if len(id_string)=0 then
		do
			id_string=random(4)
			msw=asc(left(id_string,1))*256+asc(mid(id_string,2,1))
			lsw=asc(mid(id_string,3,1))*256+asc(mid(id_string,4,1))
			l=msw*65536 + lsw
			if l < 0 then l=l*-1
			id_string=lstri(l)
			result=tbl_field_sg("UID",id_string,EN_TBL_SET)
		loop while result=EN_TBL_STATUS_KEY_VIOLATION
	else
		result=tbl_field_sg("UID",id_string,EN_TBL_SET)
	end if
	tbl_gen_UID=result
end function

'------------------------------------------------------------------------------
public function tbl_copy_info(source_tbl_name as string(MAX_TBL_NAME_LEN), target_tbl_name as string(MAX_TBL_NAME_LEN) ) as en_tbl_status
'Copys all the tables info(number of fields, field size, type, etc.) to another table.  The propose of the function is when you need to modify
'table contains while operating with it.(ex. uploading a new user data table while the old table is still accisible. You can define a dummy table
'and copy the table info to the dummy table, so you will have two tables that has the exact same structure. store data in the dummy table and
'replace the old table with the dummy table using 'tbl_replace()' after all record received.

	dim tbl_temp as tbl_type
	dim result as pl_fd_status_codes
	dim fnum as byte
	if tbl_find(source_tbl_name)<>EN_TBL_STATUS_OK then goto tbl_unknown_tbl
	tbl_temp=tbl_info(tbl_num)
	if tbl_find(target_tbl_name)=EN_TBL_STATUS_OK then
		fd.filenum=tbl_info(tbl_num).fnum
		fd.open(target_tbl_name)
		if fd.fileopened=NO then 
			if fd.transactionstart()<>PL_FD_STATUS_OK then goto tbl_fail
			if fd.create(target_tbl_name)<>PL_FD_STATUS_OK then goto tbl_fail
			if fd.transactioncommit()<>PL_FD_STATUS_OK then goto tbl_fail
			fd.open(target_tbl_name)
		end if
	else
		goto tbl_unknown_tbl
	end if
	fnum=tbl_info(tbl_num).fnum
	tbl_info(tbl_num)=tbl_temp
	tbl_info(tbl_num).fnum=fnum
	tbl_info(tbl_num).TableName=target_tbl_name
tbl_ok:
	tbl_copy_info=EN_TBL_STATUS_OK
	goto finish
tbl_unknown_tbl:
	tbl_copy_info=EN_TBL_STATUS_UNKNOWN_TABLE
	goto finish:
tbl_fail:
	tbl_copy_info=EN_TBL_STATUS_FAILURE
	goto finish
finish:
	if fd.transactionstarted=YES then fd.transactioncommit
	if fd.ready=NO then tbl_copy_info=EN_TBL_STATUS_FAILURE
	if tbl_copy_info=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function

'------------------------------------------------------------------------------
public function tbl_replace(old_tbl_name as string(MAX_TBL_NAME_LEN), new_tbl_name as string(MAX_TBL_NAME_LEN) ) as en_tbl_status
'Swaping table names of two tables.
	dim i, fnum as byte
	dim tbl as tbl_type
	
	if fd.ready=NO then goto tbl_fail
	
	tbl_find(old_tbl_name)
	i=tbl_num
	tbl_find(new_tbl_name)
	fnum=tbl_info(i).fnum
	tbl_info(i).fnum=tbl_info(tbl_num).fnum
	tbl_info(tbl_num).fnum=fnum
	
	if fd.transactionstart()<>PL_FD_STATUS_OK then goto fd_error
	if fd.delete(old_tbl_name)<>PL_FD_STATUS_OK then goto fd_error
	if fd.rename(new_tbl_name,old_tbl_name)<>PL_FD_STATUS_OK then goto fd_error
	if fd.transactioncommit()<>PL_FD_STATUS_OK then goto fd_error
	
	fd.filenum=tbl_info(i).fnum
	fd.open(old_tbl_name)
	
	if fd.fileopened=NO then 
		if fd.transactionstart()<>PL_FD_STATUS_OK then goto fd_error
		if fd.create(old_tbl_name)<>PL_FD_STATUS_OK then goto fd_error
		if fd.transactioncommit()<>PL_FD_STATUS_OK then goto fd_error
	end if
	
	fd.filenum=tbl_info(tbl_num).fnum
	if fd.transactionstart()<>PL_FD_STATUS_OK then goto fd_error
	if fd.create(new_tbl_name)<>PL_FD_STATUS_OK then goto fd_error
	if fd.transactioncommit()<>PL_FD_STATUS_OK then goto fd_error
	fd.open(new_tbl_name)
	goto tbl_ok

fd_error:
	select case fd.laststatus
	case PL_FD_STATUS_OK: goto tbl_ok
	case PL_FD_STATUS_ALREADY_OPENED: goto tbl_ok
	case PL_FD_STATUS_DUPLICATE_NAME: goto tbl_ok
	case PL_FD_STATUS_NOT_FOUND: goto tbl_unknown_tbl
	case PL_FD_STATUS_NOT_OPENED: goto tbl_unknown_tbl		
	case else goto tbl_fail
	end select

tbl_ok:
	tbl_replace=EN_TBL_STATUS_OK
	goto finish
tbl_fail:
	tbl_replace=EN_TBL_STATUS_FAILURE
	goto finish
tbl_unknown_tbl:
	tbl_replace=EN_TBL_STATUS_UNKNOWN_TABLE
	goto finish
finish:
	if fd.transactionstarted=YES then fd.transactioncommit
	if fd.ready=NO then tbl_replace=EN_TBL_STATUS_FAILURE
	if tbl_replace=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function

'------------------------------------------------------------------------------
public function tbl_check() as en_tbl_status
'A fast check of the file data integrating of the all table by reading the last record
	dim i as byte
	dim tbl_result as en_tbl_status
	
	for i = 0 to MAX_NUM_TABLES-1
		if tbl_info(i).TableName<>"" then tbl_result=tbl_select(tbl_info(i).TableName)
		if tbl_result<>EN_TBL_STATUS_OK then exit for
		if selected_tbl_all_rc>0 then
			tbl_result=tbl_record_ptr_sg(selected_tbl_all_rc,EN_TBL_SET)
			if tbl_result<>EN_TBL_STATUS_OK then exit for
			tbl_result=tbl_record_sg(EN_TBL_GET)
			if tbl_result<>EN_TBL_STATUS_OK then exit for
		end if
	next i
	tbl_check=tbl_result
	if fd.ready=NO then tbl_check=EN_TBL_STATUS_FAILURE
	if tbl_check=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function

'------------------------------------------------------------------------------
public function tbl_close(tbl_name as string(MAX_TBL_NAME_LEN)) as en_tbl_status
'A fail safe way to close the table.

	dim i as byte
	
	if fd.ready=NO then goto tbl_fail
	if tbl_name="" then
		for i=0 to MAX_NUM_TABLES - 1
			fd.filenum=tbl_info(i).fnum
			if fd.fileopened = YES then
				if fd.transactionstart()<>PL_FD_STATUS_OK then goto tbl_ok
				if fd.close()<>PL_FD_STATUS_OK then goto tbl_ok
				if fd.transactioncommit()<>PL_FD_STATUS_OK then goto tbl_ok
			end if
		next i	
	else
		if tbl_find(tbl_name)<>EN_TBL_STATUS_OK then goto tbl_unknown_tbl
		fd.filenum=tbl_info(tbl_num).fnum
		if fd.fileopened = YES then
			if fd.transactionstart()<>PL_FD_STATUS_OK then goto tbl_ok
			if fd.close()<>PL_FD_STATUS_OK then goto tbl_ok
			if fd.transactioncommit()<>PL_FD_STATUS_OK then goto tbl_ok
		end if
	end if
	goto tbl_ok

fd_error:
	select case fd.laststatus
	case PL_FD_STATUS_OK: goto tbl_ok
	case PL_FD_STATUS_ALREADY_OPENED: goto tbl_ok
	case PL_FD_STATUS_DUPLICATE_NAME: goto tbl_ok
	case PL_FD_STATUS_NOT_FOUND: goto tbl_unknown_tbl
	case PL_FD_STATUS_NOT_OPENED: goto tbl_unknown_tbl		
	case else goto tbl_fail
	end select	

tbl_ok:
	tbl_close=EN_TBL_STATUS_OK
	goto finish
tbl_fail:
	tbl_close=EN_TBL_STATUS_FAILURE
	goto finish
tbl_unknown_tbl:
	tbl_close=EN_TBL_STATUS_UNKNOWN_TABLE
finish:
	if fd.transactionstarted=YES then fd.transactioncommit
	if fd.ready=NO then tbl_close=EN_TBL_STATUS_FAILURE
	if tbl_close=EN_TBL_STATUS_FAILURE then device_disk_error_detected()
end function

'------------------------------------------------------------------------------
public function tbl_get_tbl_name() as string(MAX_TBL_NAME_LEN)
'Returns the name of the current selected table.
	tbl_get_tbl_name=selected_tbl_name
end function

'------------------------------------------------------------------------------
function tbl_check_key_violation(byref key_ptr as word) as no_yes
	dim temp as string(MAX_RECORD_SIZE)
	dim sKeyField, sFldVal as string(TBL_MAX_FIELD_LEN)
	dim i, sz, b, daddr_offset as byte
	dim daddr1,daddr2,dtemp as dword
	
	key_ptr=0
	sKeyField=""
	'construct key
	if selected_tbl_Numkeyf > 0 then
		for i=0 to selected_tbl_Numkeyf-1
			sz=tbl_get_field_size(tbl_num,i)
			temp=strgen(sz,chr(val(NULL)))
			tbl_field_sg(tbl_info(tbl_num).Fields(i+fld_offset).FieldName,sFldVal,EN_TBL_GET)
			if tbl_info(tbl_num).Fields(i+fld_offset).FieldType=`S` then 
				b=len(sFldVal)
				sFldVal=chr(b)+sFldVal
			end if
			if sFldVal="" or sFldVal=temp then goto tbl_key_violate
			sKeyField=sKeyField+sFldVal
		next i

		'search for same key
		daddr_offset=1	'offset for active_flag(1byte)
#if GEN_UID_ENABLED=1
	daddr_offset=daddr_offset+4		'offset for uid(4bytes)
#endif
#if TABLE_HASH_ENABLED=1
	daddr_offset=daddr_offset+4		'offset for md5(4bytes)
#endif
	daddr1=1+daddr_offset
find_key:	
		daddr1=fd.find(daddr1,sKeyField,1,FORWARD,selected_tbl_RecSize,PL_FD_FIND_EQUAL)
		if daddr1 > 0 then 'check if it's a deleted record
			daddr2=fd.find(daddr1-daddr_offset,ACTIVE_FLAG,1,FORWARD,selected_tbl_RecSize,PL_FD_FIND_EQUAL)
			if daddr2=daddr1-daddr_offset then 
				goto tbl_key_violate
			else
				daddr1=daddr1+selected_tbl_RecSize
				goto find_key
			end if
		end if
	end if
	tbl_check_key_violation=NO
	exit function
tbl_key_violate:
	dtemp=tbl_info(tbl_num).RecSize
	dtemp=daddr1/dtemp+1
	key_ptr=dtemp
	tbl_check_key_violation=YES
end function