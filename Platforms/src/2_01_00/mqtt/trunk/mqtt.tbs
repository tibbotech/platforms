include "global.tbh"



const MQTT_INIT_SIGNATURE=&h1688

const MQTT_STAMP="MQTT> "

const MQTT_CR_LF=chr(13)+chr(10)



'Message Types

const CONNECT		=&h10

const CONNACK		=&h20

const PUBLISH		=&h30

const PUBACK		=&h40

const PUBREC 		=&h50

const PUBREL		=&h60

const PUBCOMP 		=&h70

const SUBSCRIBE		=&h80

const SUBACK		=&h90

const UNSUBSCRIBE 	=&hA0

const UNSUBACK 		=&hB0

const PINGREQ 		=&hC0

const PINGRESP 		=&hD0

const DISCONNECT 	=&hE0



'mqtt protocol string

const MQTT_PROTOCOL="MQTT"

const MQTT_CLIENT_ID="Tibbo_mqtt_library"


enum mqtt_state

	ms_idle				=0,

	ms_connected		=1

end enum



dim mqtt_init_flag as word

dim mqtt_sock_num as byte

dim mqtt_cur_state as mqtt_state

dim mqtt_keep_alive_timer as word

dim mqtt_timer_record as word

dim mqtt_server_port as word

dim mqtt_server_ip as string

dim mqtt_user as string

dim mqtt_pw	as string



#if MQTT_DEBUG_PRINT=1

	declare sub mqtt_debug_print(data as string)

#endif



'-------------------------------------------------------------

sub mqtt_start()

'API procedure, starts the MQTT library.

'MUST be called first, before any other procedure in this library is used.

	

	if mqtt_init_flag=MQTT_INIT_SIGNATURE then

		#if MQTT_DEBUG_PRINT=1

			mqtt_debug_print("MQTT library already initialized.")

		#endif

		exit sub

	end if



	#if MQTT_DEBUG_PRINT=1

		mqtt_debug_print("---START---")

	#endif



	mqtt_init_flag=MQTT_INIT_SIGNATURE

	mqtt_cur_state=ms_idle

	mqtt_keep_alive_timer=0

	'TODO : mqtt socket pool management

	mqtt_sock_num=sock_get("MQTT")

	sock.num=mqtt_sock_num

	sock.protocol=PL_SOCK_PROTOCOL_TCP

	sock.splittcppackets=YES

	sock.gendataarrivalevent=YES

	if sys.freebuffpages<MQTT_RX_BUFF+MQTT_TX_BUFF then

		#if MQTT_DEBUG_PRINT=1

			mqtt_debug_print("Insufficient buffer memory.")

		#endif

		exit sub

	end if

	sock.rxbuffrq(MQTT_RX_BUFF)

	sock.txbuffrq(MQTT_TX_BUFF)

	sys.buffalloc

end sub



function mqtt_connect(byref dst_ip as string,dst_port as word,byref user as string,byref password as string,keep_alive as byte) as ok_ng

'Returns OK if executed successfully.

	

	const WAIT_CONNECT_TIMEOUT=10

	dim tmr as word



	mqtt_connect=NG

	if mqtt_init_flag<>MQTT_INIT_SIGNATURE then

		#if MQTT_DEBUG_PRINT=1

			mqtt_debug_print("ERROR: mqtt_start() wasn't called.")

		#endif

		exit function

	end if



	mqtt_server_port=dst_port

	mqtt_server_ip=dst_ip

	mqtt_user=user

	mqtt_pw=password



	mqtt_keep_alive_timer=keep_alive*2  ' half second * 2



	sock.num=mqtt_sock_num

	sock.targetip=mqtt_server_ip

	sock.targetport=mqtt_server_port

	sock.connect

	tmr=sys.timercount

	while sys.timercount-tmr<WAIT_CONNECT_TIMEOUT and sock.statesimple<>PL_SSTS_EST

		doevents

	wend

	if sock.statesimple<>PL_SSTS_EST then exit function



	dim buf as string

	'buf=chr(CONNECT)+chr(12+1+18+len(mqtt_user)+len(mqtt_pw))+chr(&h0)+chr(&h4)+MQTT_PROTOCOL+chr(&h4)+chr(&h2)+chr(0)+chr(&h3c)+chr(0)+chr(&h12)+ MQTT_CLIENT_ID + mqtt_user+chr(&h2f)+mqtt_pw

	buf=chr(CONNECT)+chr(12+18)+chr(&h0)+chr(&h4)+MQTT_PROTOCOL+chr(&h4)+chr(&h2)+chr(0)+chr(&h3c)+chr(0)+chr(&h12)+ MQTT_CLIENT_ID
	sock.setdata(buf)

	sock.send

	

	mqtt_connect=OK

end function



function mqtt_reconnect() as ok_ng

'API function, instructs the library to reconnect to the MQTT server (broker) using connection parameters previously supplied with mqtt_connect().<br>

'Returns OK if executed successfully.

	

	const WAIT_CONNECT_TIMEOUT=10

	dim tmr as word

	mqtt_reconnect=NG

	if mqtt_init_flag<>MQTT_INIT_SIGNATURE then

		#if MQTT_DEBUG_PRINT=1

			mqtt_debug_print("ERROR: mqtt_start() wasn't called.")

		#endif

		exit function

	end if



	sock.num=mqtt_sock_num

	if sock.statesimple<>PL_SSTS_CLOSED then exit function

	

	sock.close

	sock.targetip=mqtt_server_ip

	sock.targetport=mqtt_server_port



	sock.connect

	tmr=sys.timercount

	while sys.timercount-tmr<WAIT_CONNECT_TIMEOUT and sock.statesimple<>PL_SSTS_EST

		doevents

	wend

	if sock.statesimple<>PL_SSTS_EST then exit function



	dim buf as string

	buf=chr(CONNECT)+chr(14+len(mqtt_user)+len(mqtt_pw)+1)+chr(&h0)+chr(&h6)+MQTT_PROTOCOL+chr(&h3)+chr(&h2)+chr(0)+chr(&h3c)+chr(0)+chr(&h11)+mqtt_user+chr(&h2f)+mqtt_pw

	sock.setdata(buf)

	sock.send

	mqtt_reconnect=OK

end function



sub mqtt_disconnect()

'API procedure, disconnects the device from the MQTT server (broker).	

	

	if mqtt_init_flag<>MQTT_INIT_SIGNATURE then

		#if MQTT_DEBUG_PRINT=1

			mqtt_debug_print("ERROR: mqtt_start() wasn't called.")

		#endif

		exit sub

	end if

	if mqtt_cur_state<>ms_connected then exit sub



	dim buf as string

	buf=chr(DISCONNECT)+chr(0)

	sock.setdata(buf)

	sock.send

end sub



sub mqtt_publish(byref topic as string, byref data as string)

'API procedure, publishes a <b>topic</b> and its <b>data</b> to the MQTT server (broker).

	

	if mqtt_init_flag<>MQTT_INIT_SIGNATURE then

		#if MQTT_DEBUG_PRINT=1

			mqtt_debug_print("ERROR: mqtt_start() wasn't called.")

		#endif

		exit sub

	end if

	if mqtt_cur_state<>ms_connected then exit sub



	dim buf as string

	dim remaining_length as byte



	#if MQTT_DEBUG_PRINT=1

		mqtt_debug_print("Publishing: topic="+topic+", data="+data)

	#endif



	remaining_length=len(topic)+len(data)

	buf=chr(PUBLISH+1)+chr(remaining_length+2)+chr(0)+chr(len(topic))+topic+data



	sock.num=mqtt_sock_num

	sock.setdata(buf)

	sock.send

end sub



sub mqtt_sub(byref topic as string,qos as en_qos_choices)

'API procedure, subscribes the device to the specified topic on the MQTT server (broker).<br><br>

'<b>topic</b>- the topic to subscribe to,<br>

'<b>qos</b>- requested quality of service, according to the en_qos_choices enum.

	

	if mqtt_init_flag<>MQTT_INIT_SIGNATURE then

		#if MQTT_DEBUG_PRINT=1

			mqtt_debug_print("ERROR: mqtt_start() wasn't called.")

		#endif

		exit sub

	end if

	if mqtt_cur_state<>ms_connected then exit sub



	dim buf as string



	#if MQTT_DEBUG_PRINT=1

		mqtt_debug_print("Subscribing to: data="+topic)

	#endif

	

	buf=chr(SUBSCRIBE+2)+chr(2+2+len(topic)+1)+chr(0)+chr(1)+chr(0)+chr(len(topic))+topic+chr(qos)



	sock.num=mqtt_sock_num

	sock.setdata(buf)

	sock.send

end sub



sub mqtt_unsub(byref topic as string)

'API procedure, unsubscribes the device from the specified topic.<br><br>

'<b>topic</b>- message to unsubscribe from.

	

	if mqtt_init_flag<>MQTT_INIT_SIGNATURE then

		#if MQTT_DEBUG_PRINT=1

			mqtt_debug_print("ERROR: mqtt_start() wasn't called.")

		#endif

		exit sub

	end if

	if mqtt_cur_state<>ms_connected then exit sub



	dim buf as string

	

	#if MQTT_DEBUG_PRINT=1

		mqtt_debug_print("Unsubscribing from: data="+topic)

	#endif

	

	buf=chr(UNSUBSCRIBE+2)+chr(2+2+len(topic)+1)+chr(0)+chr(1)+chr(0)+chr(len(topic))+topic+chr(1)

	sock.num=mqtt_sock_num

	sock.setdata(buf)

	sock.send

end sub



sub mqtt_proc_timer()

'Event procedure, call it from the on_sys_timer() event handler.

	

	if mqtt_init_flag<>MQTT_INIT_SIGNATURE then exit sub

	sock.num=mqtt_sock_num

	if mqtt_cur_state=ms_connected then

		mqtt_timer_record=mqtt_timer_record+1

		if mqtt_timer_record>=mqtt_keep_alive_timer then

			sock.num=mqtt_sock_num

			if sock.rxlen=0 then

				#if MQTT_DEBUG_PRINT=1

					mqtt_debug_print("Ping.")

				#endif



				sock.setdata(chr(PINGREQ)+chr(0))

				sock.send

				mqtt_timer_record=0

			end if

		end if

		if sock.statesimple<>PL_SSTS_EST then

			mqtt_cur_state=ms_idle

			#if MQTT_DEBUG_PRINT=1

				mqtt_debug_print("Lost server connection.")

			#endif

			callback_mqtt_connect_lost()

		end if

	end if

end sub



sub mqtt_proc_data()

'Event procedure, call it from the on_sock_data_arrival event handler.

	

	if mqtt_init_flag<>MQTT_INIT_SIGNATURE then exit sub

	if sock.num<>mqtt_sock_num then exit sub

	

	dim head,data_length as byte

	dim buf as string

	dim publish_length as word



	sock.num=mqtt_sock_num

	head=asc(sock.getdata(1))

	data_length=asc(sock.getdata(1))

	buf=sock.getdata(data_length)



	if (head and &hF0)= CONNACK then

		#if MQTT_DEBUG_PRINT=1

			mqtt_debug_print("Connected to server.")

		#endif

		mqtt_timer_record=0

		mqtt_cur_state=ms_connected

		callback_mqtt_connect_ok()

	else if (head and &hF0)= PUBLISH then

		publish_length=asc(mid(buf,1,1))*256 +asc(mid(buf,2,1))

		#if MQTT_DEBUG_PRINT=1

			mqtt_debug_print("Notification: topic="+mid(buf,3,publish_length)+", data="+mid(buf,publish_length+3,len(buf)-3-publish_length+1))

		#endif

		callback_mqtt_notif(mid(buf,3,publish_length),mid(buf,publish_length+3,len(buf)-3-publish_length+1))

	else if (head and &hF0)= PUBACK then

		#if MQTT_DEBUG_PRINT=1

			mqtt_debug_print("Publish ack.")

		#endif

	else if (head and &hF0)= SUBACK then

		#if MQTT_DEBUG_PRINT=1

			mqtt_debug_print("Subscribe ack.")

		#endif

		callback_mqtt_sub_ok()

	else if (head and &hF0)= PINGRESP then

		#if MQTT_DEBUG_PRINT=1

			mqtt_debug_print("Ping response.")

		#endif

	end if

end sub



#if MQTT_DEBUG_PRINT=1

sub mqtt_debug_print(data as string)

	sys.debugprint(MQTT_STAMP+data+MQTT_CR_LF)

end sub

#endif

