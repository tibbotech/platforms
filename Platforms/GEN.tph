'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'			COMMON PLATFORM STUFF
'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#define EM1000 0
#define EM1202 1
#define EM110 2
#define DS1206 3
#define EM1206 4
#define DS1202 5
#define T1000W 6
#define KLM601 7
#define EM500 8 'unused
#define NB1010 9
#define NB1010W 10
#define EM1000W 11
#define EM1202W 12
#define EM1206W 13
#define EM202 14
#define EM500W 15
#define DS1102W 16
#define DS1100 17
#define DS1101W 18

#define LCD_DISABLED 0
#define LCD_ENABLED 1

#define SAMSUNG_S6B0108 0
#define HIMAX_HX8309 1
#define SOLOMON_SSD1329 2
#define SOLOMON_SSD1963 3
#define SOLOMON_SSD1963_FIXED_IO 4
#define SOLOMON_SSD1305 5
#define HIMAX_HX8347 6

'55x -- "driver" TDL (low-level stuff like setpixel, etc. but without getpixel)
'56x -- "info" TDL (LCD dimensions, colors, etc.)
'75x -- initialization (except LCD_TYPE=SAMSUNG_S6B0108 where it is combined with 55.TDL)
'79x -- getpixel

#if LCD_TYPE=SAMSUNG_S6B0108
	#define LCD_DRIVER_TDL "55.TDL"+ 
	#define LCD_DRIVER_TDL2 "56.TDL"+ 
	#define LCD_DRIVER_TDL3 "55.TDL"+
	#define LCD_DRIVER_TDL4 "79.TDL"+ 
#elif LCD_TYPE=HIMAX_HX8309
	#define LCD_DRIVER_TDL "55b.TDL"+ 
	#define LCD_DRIVER_TDL2 "56b.TDL"+ 
	#define LCD_DRIVER_TDL3 "75b.TDL"+ 
	#define LCD_DRIVER_TDL4 "79b.TDL"+
#elif LCD_TYPE=SOLOMON_SSD1329
	#define LCD_DRIVER_TDL "55c.TDL"+ 
	#define LCD_DRIVER_TDL2 "56c.TDL"+ 
	#define LCD_DRIVER_TDL3 "55c.TDL"+ 
	#define LCD_DRIVER_TDL4 "79c.TDL"+
#elif LCD_TYPE=SOLOMON_SSD1963
	#define LCD_DRIVER_TDL "55d.TDL"+ 
	#define LCD_DRIVER_TDL2 "56d.TDL"+ 
	#define LCD_DRIVER_TDL3 "75d.TDL"+ 
	#define LCD_DRIVER_TDL4 "79d.TDL"+
#elif LCD_TYPE=SOLOMON_SSD1963_FIXED_IO
	#define LCD_DRIVER_TDL "55d2.TDL"+ 
	#define LCD_DRIVER_TDL2 "56d.TDL"+ 
	#define LCD_DRIVER_TDL3 "75d.TDL"+ 
	#define LCD_DRIVER_TDL4 "79d.TDL"+
#elif LCD_TYPE=SOLOMON_SSD1305
	#define LCD_DRIVER_TDL "55e.TDL"+
	#define LCD_DRIVER_TDL2 "56e.TDL"+
	#define LCD_DRIVER_TDL3 "55e.TDL"+
	#define LCD_DRIVER_TDL4 "79e.TDL"+
#elif LCD_TYPE=HIMAX_HX8347
	#define LCD_DRIVER_TDL "55f.TDL"+ 
	#define LCD_DRIVER_TDL2 "56f.TDL"+ 
	#define LCD_DRIVER_TDL3 "75f.TDL"+ 
	#define LCD_DRIVER_TDL4 "79f.TDL"+
#endif

#if PLATFORM_ID=7
	#define FD_DRIVER_TDL "64b.TDL"+
	#define FD_COPYFIRMWARE "76b.TDL"+
#else
	#define FD_DRIVER_TDL "64.TDL"+
	#define FD_COPYFIRMWARE "76.TDL"+
#endif

#define KP_DISABLED 0
#define KP_ENABLED 1

#define FD_DISABLED 0
#define FD_ENABLED 1

#define WLN_DISABLED 0
#define WLN_ENABLED 1


'**************************************************************************************************
'		GENERIC PLATFORM CONSTANTS
'**************************************************************************************************

enum off_on 
	PL_OFF,			'<b>GENERIC PLATFORM CONSTANT. </b>
	PL_ON			'<b>GENERIC PLATFORM CONSTANT. </b>
end enum

enum no_yes 
	NO,			'<b>GENERIC PLATFORM CONSTANT. </b>
	YES			'<b>GENERIC PLATFORM CONSTANT. </b>
end enum

enum dis_en 
	DISABLED,		'<b>GENERIC PLATFORM CONSTANT. </b>
	ENABLED			'<b>GENERIC PLATFORM CONSTANT. </b>
end enum

enum low_high 
	LOW,			'<b>GENERIC PLATFORM CONSTANT. </b>
	HIGH			'<b>GENERIC PLATFORM CONSTANT. </b>
end enum

enum ok_ng 
	OK,			'<b>GENERIC PLATFORM CONSTANT. </b>
	NG			'<b>GENERIC PLATFORM CONSTANT. </b>
end enum

enum wln_ok_ng_rej 
	WLN_OK,			'<b>GENERIC PLATFORM CONSTANT. </b>
	WLN_NG,			'<b>GENERIC PLATFORM CONSTANT. </b>
	WLN_REJ			'<b>GENERIC PLATFORM CONSTANT. </b>
end enum


enum valid_invalid 
	VALID,			'<b>GENERIC PLATFORM CONSTANT. </b>
	INVALID			'<b>GENERIC PLATFORM CONSTANT. </b>
end enum

enum accepted_rejected 
	ACCEPTED,		'<b>GENERIC PLATFORM CONSTANT. </b>
	REJECTED		'<b>GENERIC PLATFORM CONSTANT. </b>
end enum

enum forward_back 
	FORWARD,		'<b>GENERIC PLATFORM CONSTANT. </b>
	BACK		'<b>GENERIC PLATFORM CONSTANT. </b>
end enum

enum ver_hor 
	PL_VERTICAL,	'PLATFORM CONSTANT. Vertical.
	PL_HORIZONTAL	'PLATFORM CONSTANT. Horizontal.
end enum


'**************************************************************************************************
'		INTER-OBJECT CONSTANTS
'**************************************************************************************************

enum pl_redir
'ENUM. Contains the list of constants that define redirection of data (buffer shorting) between two objects of current
'platform that support buffers: the ser object and the sock object. Buffer shorting is enabled/disabled through the
'ser.redir and sock.redir methods.
	PL_REDIR_NONE=0,	'INTER-OBJECT CONSTANT. Cancels redirection for the serial port or socket.
	PL_REDIR_SER,		'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of the serial port 0.
	PL_REDIR_SER0=1,	'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of the serial port 0.
	PL_REDIR_SER1,		'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of the serial port 1.
	PL_REDIR_SER2,		'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of the serial port 2.
	PL_REDIR_SER3,		'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of the serial port 3.
	PL_REDIR_SOCK0=6,	'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 0. This constant can be used as a "base" for all other sockets i.e. in
				'expressions like sock.redir=PL_REDIR_SOCK0+f.
	PL_REDIR_SOCK1,		'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 1.
	PL_REDIR_SOCK2,		'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 2.
	PL_REDIR_SOCK3,		'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 3.
	PL_REDIR_SOCK4,		'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 4.
	PL_REDIR_SOCK5,		'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 5.
	PL_REDIR_SOCK6,		'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 6.
	PL_REDIR_SOCK7,		'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 7.
	PL_REDIR_SOCK8,		'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 8.
	PL_REDIR_SOCK9,		'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 9.
	PL_REDIR_SOCK10,	'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 10.
	PL_REDIR_SOCK11,	'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 11.
	PL_REDIR_SOCK12,	'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 12.
	PL_REDIR_SOCK13,	'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 13.
	PL_REDIR_SOCK14,	'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 14.
	PL_REDIR_SOCK15		'INTER-OBJECT CONSTANT. Redirects RX data of the serial port or socket to the TX buffer
				'of socket 15.
end enum


'**************************************************************************************************
'		BUILT-IN FUNCTIONS
'**************************************************************************************************

syscall(510,"69.TDL")  !gotohtml(offset as word)
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(60,"69.TDL")  !finalgotohtml(offset as word)
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(511,"20.TDL")  !strload(byref dststr as string, byref sourcestr as string)
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(505,"87.TDL")  !load(byref dest, byref src, len as word)
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(512,"21.TDL")  !strcpy(byref deststr as string, byref sourcestr as string)
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(513,"22.TDL")  !strcat(byref dst as string, byref src as string)
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(514,"02.TDL")  val(byref sourcestr as string) as word
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>
'Converts string representation of a value into 16-bit value (word or short). Recognizes &b (binary) and &h (hexadecimal) prefixes. 
'Can be invoked implicitly, through the word_var=string_var expression. <br><br>
'Compiler is smart enough to pre-calculate constant-only expressions involving implicit use of <font color="teal"><b>val()
'</b></font>function.

'--------------------------------------------------------------------
syscall(515,"69.TDL"+)  !httpoutput
'<b>INTRINSIC PLATFORM SYSCALL.</b><br><br>

'--------------------------------------------------------------------
syscall(294,"54.TDL") lval(byref sourcestr as string) as dword
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>
'Converts string representation of a value into 32-bit value (dword or long). Recognizes &b (binary) and &h (hexadecimal) prefixes.
'Can be invoked implicitly, through the dword_var=string_var expression. <br><br>
'Compiler is smart enough to pre-calculate constant-only expressions involving implicit use of <font color="teal"><b>lval()
'</b></font>function.

'--------------------------------------------------------------------
syscall(516,"03.TDL")  str(num as integer) as string
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>
'Converts unsigned 16-bit numeric value (word) into its decimal string representation.Can be invoked implicitly, through the 
'string_var=word_var expression. <br><br>
'Compiler is smart enough to pre-calculate constant-only expressions involving implicit use of <font color="teal"><b>str()
'</b></font>function.

'--------------------------------------------------------------------
syscall(283,"48.TDL") lstr(byref num as dword) as string
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>
'Converts unsigned 32-bit numeric value (dword) into its decimal string representation. Can be invoked implicitly, through the 
'string_var=dword_var expression. <br><br>
'Compiler is smart enough to pre-calculate constant-only expressions involving implicit use of <font color="teal"><b>lstr()
'</b></font>function.

'--------------------------------------------------------------------
syscall(517,"03.TDL")  stri(num as integer) as string
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>
'Converts signed 16-bit numeric value (short) into its decimal string representation. Can be invoked implicitly, through the
'string_var=short_var expression. <br><br>
'Compiler is smart enough to pre-calculate constant-only expressions involving implicit use of <font color="teal"><b>stri() 
'</b></font>function.

'--------------------------------------------------------------------
syscall(284,"48.TDL") lstri(byref num as long) as string
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>
'Converts signed 32-bit numeric value (long) into its decimal string representation. Can be invoked implicitly, through the 
'string_var=long_var expression.<br><br>
'Compiler is smart enough to pre-calculate constant-only expressions involving implicit use of <font color="teal"><b>lstri()
'</b></font>function.

'--------------------------------------------------------------------
syscall(518,"03.TDL")  hex(num as word) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Converts unsigned 16-bit numeric value (word) into its HEX string representation.
'Standard "&h" prefix is added at the beginning of the string.

'--------------------------------------------------------------------
syscall(285,"48.TDL") lhex(byref num as dword) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Converts unsigned 32-bit numeric value (dword) into its HEX string representation.
'Standard "&h" prefix is added at the beginning of the string.

'--------------------------------------------------------------------
syscall(519,"03.TDL")  bin(num as word) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Converts unsigned 16-bit numeric value (word) into its binary string representation.
'Standard "&b" prefix is added at the beginning of the string.

'--------------------------------------------------------------------
syscall(286,"48.TDL") lbin(byref num as dword) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Converts unsigned 32-bit numeric value (dword) into its binary string representation.
'Standard "&b" prefix is added at the beginning of the string.

'--------------------------------------------------------------------
syscall(520,"01.TDL") left(byref sourcestr as string, len as byte) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns len leftmost characters of a string sourcestring. Example of use: s=<font color="teal"><b>left("ABCDE",3)</b></font>,
'result will be "ABC". 

'--------------------------------------------------------------------
syscall(521,"01.TDL") right(byref sourcestr as string, len as byte) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns len rightmost characters of a string sourcestr. Example of use: s=<font color="teal"><b>right("ABCDE",3)</b></font>,
'result will be "CDE".

'--------------------------------------------------------------------
syscall(522,"01.TDL") mid(byref sourcestr as string, frompos as byte, len as byte) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns len characters from a string sourcestr starting from position pos. The leftmost string character is counted to be at position 1.
'Example of use:<br><br>
's=<font color="teal"><b>mid("ABCDE",2,3)</b></font>, result will be "BCD".

'--------------------------------------------------------------------
syscall(523,"23.TDL") !strcmp(byref string1 as string, byref string2 as string) as integer
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br> 

'--------------------------------------------------------------------
syscall(524,"04.TDL") len(byref sourcestr as string) as byte
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns the length of (number of characters in) the string sourcestr. Example of use: <br><br>
'x=<font color="teal"><b>len("ABC")</b></font>, result will be 3.

'--------------------------------------------------------------------
syscall(525,"05.TDL") instr(frompos as byte,byref sourcestr as string,byref substr as string,num as byte) as byte
'<b>PLATFORM SYSCALL. </b><br><br>
'Finds the Nth occurrence (defined by num, counting from 1) of a substring substr in a string sourcestr.<br><br>
'Search is conducted from position frompos (leftmost character has position 1). This function returns position in a string or zero if the
'Nth occurrence of the substring is not found. Example of use:<br><br>
'x=<font color="teal"><b>instr(3,"ABCABCDEABC12","BC",2)</b></font>, result will be 10.

'--------------------------------------------------------------------
syscall(526,"06.TDL") asc(byref sourcestr as string) as byte
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns the ASCII code of the leftmost character of the string. Example: <br><br>
'x=<font color="teal"><b>asc("123")</b></font>, result will be 49 (ASCII code of '1').

'--------------------------------------------------------------------
syscall(527,"07.TDL") chr(asciicode as byte) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns the string that consists of a single character with ASCII code asciicode. Example of use: <br><br>
's=<font color="teal"><b>chr(49)</b></font>, result will be "1". 	

'--------------------------------------------------------------------
syscall(528,"39.TDL") ddstr(byref str as string) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Converts "dot-decimal value" in <b>str </b>into "dot-decimal string". Returns a dot-separated string consisting of decimal representations of all binary values in the input string.
'Each decimal value will be in the 0-255 range.
'<br><br>
'This function is convenient for converting groups of bytes representing binary data (such as IP or MAC addresses) into their string representation.
'<br><br>
'See also:
'<font color="teal"><b>ddval</b</font>.

'--------------------------------------------------------------------
syscall(529,"40.TDL") ddval (byref str as string) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Converts "dot-decimal string" in <b>str </b>into "dot-decimal value".
'<br><br>
'The contents of <b>str </b>should comprise one or more dot-separated decimal values in the 0-255 range.
'Values that exceed 255 will produce an overflow, so result will be incorrect.
'If any other character other than "0"-"9" or "." is encountered then all digits after this character and up to the next "." (if any) will be ignored.
'Leading spaces before each decimal value are allowed.
'<br><br>
'This function is convenient for converting string representation of groups of bytes (such as IP or MAC addresses) into their binary form.
'<br><br>
'See also:
'<font color="teal"><b>ddstr</b</font>.

'--------------------------------------------------------------------
syscall(24,"09.TDL") strgen(len as byte,byref substr as string) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Generates a string of len length consisting of repeating substrings substr. Example: <br><br>
's=<font color="teal"><b>strgen(10,"ABC")</b></font>, result will be "ABCABCABCA". <br><br>
'Notice that len parameter specifies total resulting string length in bytes so the last substring will be truncated if necessary to
'achieve exact required length. <br><br>
'This function is an expanded version of the STRING$ function commonly found in other BASICs. 

'--------------------------------------------------------------------
syscall(22,"08.TDL") strsum(byref sourcestr as string) as word
'<b>PLATFORM SYSCALL. </b><br><br>
'Calculates 16-bit (word) sum of ASCII codes of all characters in a string sourcestr. This function is useful for checksum
'calculation. Example: <br><br>
'<font color="teal"><b>strgen("012") </b></font>will return 147 (48+49+50).

'--------------------------------------------------------------------
syscall(135) !doevents
'<b>INTRINSIC SYSCALL. </b><br><br>

'--------------------------------------------------------------------
enum pl_days_of_week
	PL_DOW_MONDAY=1,	'<b>PLATFORM CONSTANT. </b><br><br> Monday.
	PL_DOW_TUESDAY,		'<b>PLATFORM CONSTANT. </b><br><br> Tuesday.
	PL_DOW_WEDNESDAY,	'<b>PLATFORM CONSTANT. </b><br><br> Wednesday.
	PL_DOW_THURSDAY,	'<b>PLATFORM CONSTANT. </b><br><br> Thursday.
	PL_DOW_FRIDAY,		'<b>PLATFORM CONSTANT. </b><br><br> Friday.
	PL_DOW_SATURDAY,	'<b>PLATFORM CONSTANT. </b><br><br> Saturday.
	PL_DOW_SUNDAY		'<b>PLATFORM CONSTANT. </b><br><br> Sunday.
end enum

syscall(25,"10.TDL") weekday(daycount as word) as pl_days_of_week
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns the day of the week for a given day number. Base date for the day count is 1-JAN-2000 (this is day #0).<br><br>
'See also <font color="teal"><b>year</b></font>, <font color="teal"><b>month</b></font>, 
'<font color="teal"><b>date</b></font>, <font color="teal"><b>hours</b></font>, 
'<font color="teal"><b>minutes</b></font>, <font color="teal"><b>daycount</b></font>, and 
'<font color="teal"><b>mincount </b></font>syscalls.

'--------------------------------------------------------------------
syscall(26,"11.TDL") year(daycount as word) as byte
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns the year for a given day number. Base date for the day count is 1-JAN-2000 (this is day #0). Only last two
'digits of the year are returned, so 0 means 2000, 1- 2001, and so on. <br><br>
'See also <font color="teal"><b>weekday</b></font>, <font color="teal"><b>month</b></font>, 
'<font color="teal"><b>date</b></font>, <font color="teal"><b>hours</b></font>, 
'<font color="teal"><b>minutes</b></font>, <font color="teal"><b>daycount</b></font>, and 
'<font color="teal"><b>mincount </b></font>syscalls.

'--------------------------------------------------------------------
enum pl_months
	PL_MONTH_JANUARY=1,	'<b>PLATFORM CONSTANT. </b><br><br> January.
	PL_MONTH_FEBRUARY,	'<b>PLATFORM CONSTANT. </b><br><br> February.
	PL_MONTH_MARCH,		'<b>PLATFORM CONSTANT. </b><br><br> March.
	PL_MONTH_APRIL,		'<b>PLATFORM CONSTANT. </b><br><br> April.
	PL_MONTH_MAY,		'<b>PLATFORM CONSTANT. </b><br><br> May.
	PL_MONTH_JUNE,		'<b>PLATFORM CONSTANT. </b><br><br> June.
	PL_MONTH_JULY,		'<b>PLATFORM CONSTANT. </b><br><br> July.
	PL_MONTH_AUGUST,	'<b>PLATFORM CONSTANT. </b><br><br> August.
	PL_MONTH_SEPTEMBER,	'<b>PLATFORM CONSTANT. </b><br><br> September.
	PL_MONTH_OCTOBER,	'<b>PLATFORM CONSTANT. </b><br><br> October.
	PL_MONTH_NOVEMBER,	'<b>PLATFORM CONSTANT. </b><br><br> November.
	PL_MONTH_DECEMBER	'<b>PLATFORM CONSTANT. </b><br><br> December.
end enum

syscall(27,"11.TDL") month(daycount as word) as pl_months
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns the month for a given day number. Base date for the day count is 1-JAN-2000 (this is day #0). <br><br>
'See also <font color="teal"><b>weekday</b></font>, <font color="teal"><b>year</b></font>, 
'<font color="teal"><b>date</b></font>, <font color="teal"><b>hours</b></font>, 
'<font color="teal"><b>minutes</b></font>, <font color="teal"><b>daycount</b></font>, and 
'<font color="teal"><b>mincount </b></font>syscalls.

'--------------------------------------------------------------------
syscall(28,"11.TDL") date(daycount as integer) as byte
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns the date for a given day number. Base date for the day count is 1-JAN-2000 (this is day #0). <br><br>
'See also <font color="teal"><b>weekday</b></font>, <font color="teal"><b>year</b></font>, 
'<font color="teal"><b>month</b></font>, <font color="teal"><b>hours</b></font>, 
'<font color="teal"><b>minutes</b></font>, <font color="teal"><b>daycount</b></font>, and 
'<font color="teal"><b>mincount </b></font>syscalls.

'--------------------------------------------------------------------
syscall(29,"12.TDL") daycount(year as byte, month as byte, date as byte) as word
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns the day number for a given year, month, and date. Base date for the day number is 1-JAN-2000 (this is day #0).<br><br>
'The year is supplied as offset from year 2000 (so, it is 6 for year 2006). Acceptable year range is 0-99 (2000-2099).<br><br>
'If any input parameter is illegal (year exceeds 99, month exceeds 12, etc.) this syscall will return 65535. This error
'value cannot be confused with an actual valid day number since the maximum day number recognized by this syscall is
'12-DEC-2099 (day number 36524).<br><br>
'See also <font color="teal"><b>weekday</b></font>, <font color="teal"><b>year</b></font>, 
'<font color="teal"><b>month</b></font>, <font color="teal"><b>date</b></font>, 
'<font color="teal"><b>hours</b></font>, <font color="teal"><b>minutes</b></font>, and 
'<font color="teal"><b>mincount </b></font>syscalls.

'--------------------------------------------------------------------
syscall(30,"13.TDL") hours(mincount as word) as byte
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns the hours value (in 24-hour format) for a given minutes number. Mincount is the number of minutes elapsed
'since midnight (00:00 is minute #0). Maximum mincount number is 1439 (23:59). <br><br>
'If higher value is supplied this call will return 255. This error value cannot be confused with a valid output since normal 
'hours value cannot exceed 23.<br><br>
'See also <font color="teal"><b>weekday</b></font>, <font color="teal"><b>year</b></font>, 
'<font color="teal"><b>month</b></font>, <font color="teal"><b>date</b></font>, 
'<font color="teal"><b>minutes</b></font>, <font color="teal"><b>daycount</b></font>, and 
'<font color="teal"><b>mincount </b></font>syscalls.

'--------------------------------------------------------------------
syscall(31,"13.TDL") minutes(mincount as word) as byte
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns the minutes value for given minutes number. Mincount is the number of minutes since from midnight (00:00 is
'minute #0). Maximum mincount number is 1439 (23:59). <br><br>
'If a value higher than 1439 is supplied, this call will return 255. This error value cannot be confused with valid output 
'since normal minutes value cannot exceed 59.<br><br>
'See also <font color="teal"><b>weekday</b></font>, <font color="teal"><b>year</b></font>, 
'<font color="teal"><b>month</b></font>, <font color="teal"><b>date</b></font>, 
'<font color="teal"><b>hours</b></font>, <font color="teal"><b>daycount</b></font>, and 
'<font color="teal"><b>mincount </b></font>syscalls.

'--------------------------------------------------------------------
syscall(32,"14.TDL") mincount(hours as byte, minutes as byte) as word
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns the minutes number for a given hours and minutes. Minutes are counted from midnight (00:00 is minute #0).<br><br>
'If any input parameter is illegal (hours exceeds 23, minutes exceeds 59, etc.) this syscall will return 65535.
'This error value cannot be confused with an actual valid minute number since the maximum minute number cannot exceed 1439.<br><br>
'See also <font color="teal"><b>weekday</b></font>, <font color="teal"><b>year</b></font>, 
'<font color="teal"><b>month</b></font>, <font color="teal"><b>date</b></font>, 
'<font color="teal"><b>hours</b></font>, <font color="teal"><b>minutes</b></font>, and 
'<font color="teal"><b>daycount </b></font>syscalls.

'--------------------------------------------------------------------
syscall(289,"50.TDL") cfloat(byref num as real) as valid_invalid
'<b>PLATFORM SYSCALL. </b><br><br>
'Floating-point calculations can lead to invalid result (#INF, -#INF errors, as per IEEE specification).<br><br>
'When your application is in the debug mode you will get a FPERR exception if such an error is encountered. <br><br>
'In the release mode the Virtual Machine won't generate an exception, yet your application may need to know if a certain floating-point 
'variable contains correct value. This is where cfloat() function comes handy. <br><br>
'The <font color="teal"><b>cfloat() </b></font>returns <font color="olive"><b>0- VALID </b></font>if the floating-point
'variable num contains a valid value, and <font color="olive"><b>1- INVALID </b></font>if the num contains invalid value.

'--------------------------------------------------------------------
syscall(296,"44.TDL") !fstr(byref num as real) as string
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
enum ftostr_mode
	FTOSTR_MODE_AUTO,	'Choose between plain and mantissa/exponent format automatically. Format that results in the
						'shortest string will be selected.
	FTOSTR_MODE_ME,		'Use mantissa/exponent format.
	FTOSTR_MODE_PLAIN	'Use regular plain format, not mantissa/exponent representation. 
end enum

syscall(287,"44.TDL") ftostr(byref num as real, mode as ftostr_mode, rnd as byte) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Converts real value into its string representation. <font color="teal"><b>Ftostr() </b></font>function offers two formatting 
'options: mode argument selects mantissa/exponent, plain, or "whichever is more compact" format for the output string.<br><br>
'Rnd argument defines how many digits (both in the integer and fractional part) the number should be rounded to.

'--------------------------------------------------------------------
syscall(288,"43.TDL") strtof(byref str as string) as real
'<b>PLATFORM SYSCALL. </b><br><br>
'Converts string representation of a real value into a real value. You must keep in mind that floating-point calculations
'are inherently imprecise. Not every value can be converted into its exact floating-point representation.<br><br>
'Also, <font color="teal"><b>strtof() </b></font>can be invoked implicitly (real_var=string_var).

'--------------------------------------------------------------------
syscall(183,"42.TDL"+) !proc_http_request()
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(260,"46.TDL") !loa32(byref dest, byref sourcestr as string) 
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(257,"47.TDL") !sto32 as dword
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(258,"47.TDL") !sto32i as long
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(577,"47.TDL") !stof() as float
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(578,"47.TDL") !stofi() as float
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(259,"49.TDL") !cpy32(byref dst, byref src)
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(256,"45.TDL") !ladd(byref x as dword, byref y as dword) as dword
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(262,"45.TDL") !lsub(byref x as dword, byref y as dword) as dword
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(261,"45.TDL") !lmul(byref x as dword, byref y as dword) as dword
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(263,"45.TDL") !ldiv(byref x as dword, byref y as dword) as dword
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(264,"45.TDL") !ldivi(byref x as long, byref y as long) as long
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(265,"45.TDL") !lmod(byref x as dword, byref y as dword) as dword
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(266,"45.TDL") !lmodi(byref x as long, byref y as long) as long
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(267,"45.TDL") !lneg(byref x as dword) as dword
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(268,"45.TDL") !land(byref x as dword, byref y as dword) as dword
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(269,"45.TDL") !lor(byref x as dword, byref y as dword) as dword
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(270,"45.TDL") !lxor(byref x as dword, byref y as dword) as dword
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(271,"45.TDL") !lnot(byref x as dword) as dword
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(272,"45.TDL") !lcmp(byref x as dword, byref y as dword)
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(273,"45.TDL") !fadd(byref x as real, byref y as real) as real
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(275,"45.TDL") !fsub(byref x as real, byref y as real) as real
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(274,"45.TDL") !fmul(byref x as real, byref y as real) as real
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(276,"45.TDL") !fdiv(byref x as real, byref y as real) as real
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(278,"45.TDL") !ultof(byref x as dword) as real
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(277,"45.TDL") !ltof(byref x as long) as real
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(279,"45.TDL") !lround(byref x as real) as long
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(280,"45.TDL") !round(byref x as real) as short
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(281,"45.TDL") !fneg(byref x as real) as real
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(282,"45.TDL") !fcmp(byref x as real, byref y as real)
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(62,"51.TDL") !initobj(byref obj, rtti as word)
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(63,"51.TDL") !gotoidx(byref obj,count as byte,i1 as word,i2 as word,i3 as word,i4 as word,i5 as word,i6 as word,i7 as word,i8 as word) as word
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(64,"51.TDL") !objcpy(byref dst, byref src)
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
enum md5_modes
	MD5_UPDATE, 'Set this mode for all data portions except the last one.
	MD5_FINISH 'Set this mode for the last data portion; also use this selection if you only have a single data portion.
end enum

syscall(290,"52.TDL") md5(byref str as string,byref input_hash as string,md5_mode as md5_modes,total_len as word) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Generates MD5 hash on the <b>str </b>string. Returns 16-character hash string; an empty string when invalid str or input_hash argument was detected.
'<br><br>
'<b>str</b> -- String containing (the next portion of) the input data to generate MD5 hash on. When md5_mode= <font color="olive"><b>0- MD5_UPDATE</b></font>, 
'this string must be 64, 128, or 192 characters in length.  Any other length will result in error and the function will return an empty string. 
'When md5_mode= <font color="olive"><b>1- md5_FINISH</b></font>, this string can have any length (up to 255 bytes).
'<br>
'<b>input_hash</b> -- Hash obtained as a result of MD5 calculation on the previous data portion. Leave it empty for the first portion of data.
'Use the result of MD5 calculation on the previous data portion for the second and all subsequent portions of data.
'The result of MD5 is always 16 characters long, so passing the string of any other length (except 0 -- see above) will result in error and this function will return an empty string.
'<br>
'<b>md5_mode</b> -- <font color="olive"><b>0- MD5_UPDATE </b></font> (set this mode for all data portions except the last one), or <font color="olive"><b>1- md5_FINISH </b></font>
'(set this mode for the last data portion; also use this selection if you only have a single data portion).
'<br>
'<b>total_len</b> -- Total length of processed data (in all data portions combined). Only relevant when md5_mode= <font color="olive"><b>1- md5_FINISH</b></font>. 
'That is, only relevant for the last or a single data portion.
'<br><br>
'MD5 is a standard method of calculating hash codes on data of any size. The amount of input data can often exceed maximum capacity of string variables (255 characters).
'The md5 method can be invoked repeatedly in order to process the data of any size.
'<br><br>
'See also:
'<font color="teal"><b>sha1</b</font>.

'--------------------------------------------------------------------
enum sha1_modes
	SHA1_UPDATE, 'Set this mode for all data portions except the last one.
	SHA1_FINISH 'Set this mode for the last data portion; also use this selection if you only have a single data portion.
end enum

syscall(291,"53.TDL") sha1(byref str as string,byref input_hash as string,sha1_mode as sha1_modes,totallen as word) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Generates SHA1 hash on the <b>str </b>string. Returns 20-character hash string; an empty string when invalid str or input_hash argument was detected.
'<br><br>
'<b>str</b> -- String containing (the next portion of) the input data to generate SHA1 hash on. When sha1_mode= <font color="olive"><b>0- SHA1_UPDATE</b></font>, 
'this string must be 64, 128, or 192 characters in length. Any other length will result in error and the function will return an empty string. 
'When sha1_mode= <font color="olive"><b>1- SHA1_FINISH</b></font>, this string can have any length (up to 255 bytes).
'<br>
'<b>input_hash</b> -- Hash obtained as a result of SHA1 calculation on the previous data portion. Leave it empty for the first portion of data.
'Use the result of SHA1 calculation on the previous data portion for the second and all subsequent portions of data.
'The result of SHA1 is always 20 characters long, so passing the string of any other length (except 0 -- see above) will result in error and this function will return an empty string.
'<br>
'<b>md5_mode</b> -- <font color="olive"><b>0- SHA1_UPDATE</b></font>(set this mode for all data portions except the last one), or <font color="olive"><b>1- SHA1_FINISH </b></font>
'(set this mode for the last data portion; also use this selection if you only have a single data portion).
'<br>
'<b>total_len</b> -- Total length of processed data (in all data portions combined). Only relevant when sha1_mode= <font color="olive"><b>1- SHA1_FINISH</b></font>. 
'That is, only relevant for the last or a single data portion.
'<br><br>
'SHA1 is a standard method of calculating hash codes on data of any size. The amount of input data can often exceed maximum capacity of string variables (255 characters).
'The sha1 method can be invoked repeatedly in order to process the data of any size.
'<br><br>
'See also:
'<font color="teal"><b>md5</b</font>.

'--------------------------------------------------------------------
syscall(253,"52.TDL") random(len as byte) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Generates a string consisting of <b>len </b>random characters.

'--------------------------------------------------------------------
syscall(252,"52.TDL") !md5ls() as string
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(254,"52.TDL") !md5ls2(byref str as string) as string
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(549,"09.TDL") insert(byref dest_str as string,pos as byte,byref insert_str as string) as byte
'<b>PLATFORM SYSCALL. </b><br><br>
'Inserts insert_str string into the dest_str string at the insert position pos. Returns the new length of dest_str.
'<br><br>
'This is an insert with overwrite, meaning that the insert_str will overwrite a portion of the dest_str.
'<br><br>
'Dest_str length can increase as a result of this operation (but not beyond declared string capacity). This will happen if the insertion position does
'not allow the source_str to fit within the current length of the dest_string.

'--------------------------------------------------------------------
#if PLATFORM_ID<>EM500W and PLATFORM_ID<>DS1100
syscall(463,"83.TDL") aes128enc(byref key as string,byref plain as string) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Encrypts data in 16-byte blocks according to the AES128 algorithm. Returns encrypted data (which will consist of complete 16-character blocks).
'<br><br>
'<b>Key </b>-- Encryption key. Must be 16 characters long, or NULL string will be returned.
'<br><br>
'<b>Plain </b>-- Plain (unencrypted) data. Will be processed in 16-byte blocks. Last incomplete block will be padded with zeroes. 
'<br><br>
'Not supported on the EM500W platform.
'<b>See also: </b>aes128dec, rc4.
#endif

'--------------------------------------------------------------------
#if PLATFORM_ID<>EM500W and PLATFORM_ID<>DS1100
syscall(464,"84.TDL") aes128dec(byref key as string,byref cypher as string) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Decrypts data in 16-byte blocks according to the AES128 algorithm. Returns decrypted data (which will consist of complete 16-character blocks).
'<br><br>
'<b>Key </b>-- Encryption key. Must be 16 characters long, or NULL string will be returned.
'<br><br>
'<b>Cypher </b>-- Encrypted data, must consist of one or more complete 16-character blocks, or NULL string will be returned. 
'<br><br>
'Not supported on the EM500W platform.
'<br><br>
'<b>See also: </b>aes128dec, rc4.
#endif

'--------------------------------------------------------------------
syscall(579,"88.TDL") rc4(byref key as string, skip as word, byref data as string) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Encrypts/decrypts the data stream according to the RC4 algorithm. Returns processed data.
'<br><br>
'<b>Key </b>-- Encryption key, can have any length.
'<br><br>
'<b>Skip </b>-- The number of "skip" iterations. These are additional iterations added past the standard "key scheduling algorithm". Set this argument to 0 to obtain
'standard encryption results compatible with other systems.
'<br><br>
'<b>Key </b>-- Data to encrypt/decrypt.
'<br><br>
'With RC4 algorithm, the same function is used both for encrypting and decrypting the data.
'<br><br>
'<b>See also: </b>aes128enc, aes128dec.

'--------------------------------------------------------------------
syscall(465,"85.TDL") strand(byref str1 as string,byref str2 as string) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns a string containing the result of logical AND operation on data in str1 and str2 arguments.
'<br><br>
'This function treats data in str1 and str2 as two byte arrays. Logical AND operation is performed on corresponding byte pairs (first byte of str1 AND first byte of str2, etc.).
'<br><br>
'If one of the arguments contains less bytes, then this argument is padded with zeroes prior to performing logical AND operation.
'<br><br>
'<b>See also: </b>stror, strxor.

'--------------------------------------------------------------------
syscall(466,"85.TDL") stror(byref str1 as string,byref str2 as string) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns a string containing the result of logical OR operation on data in str1 and str2 arguments.
'<br><br>
'This function treats data in str1 and str2 as two byte arrays. Logical OR operation is performed on corresponding byte pairs (first byte of str1 OR first byte of str2, etc.).
'<br><br>
'If one of the arguments contains less bytes, then this argument is padded with zeroes prior to performing logical OR operation.
'<br><br>
'<b>See also: </b>strand, strxor.

'--------------------------------------------------------------------
syscall(467,"85.TDL") strxor(byref str1 as string,byref str2 as string) as string
'<b>PLATFORM SYSCALL. </b><br><br>
'Returns a string containing the result of logical exclusive OR (XOR) operation on data in str1 and str2 arguments.
'<br><br>
'This function treats data in str1 and str2 as two byte arrays. Logical XOR operation is performed on corresponding byte pairs (first byte of str1 XOR first byte of str2, etc.).
'<br><br>
'If one of the arguments contains less bytes, then this argument is padded with zeroes prior to performing logical XOR operation.
'<br><br>
'<b>See also: </b>strand, stror.

'--------------------------------------------------------------------
syscall(18) !memcpy(byref dest, byref src, len as word)
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(584,"45.TDL") !lshr(byref val as dword, num_bits as byte) as dword
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(585,"45.TDL") !lshl(byref val as dword, num_bits as byte) as dword
'<b>INTRINSIC PLATFORM SYSCALL. </b><br><br>

'--------------------------------------------------------------------
syscall(586,"02.TDL") strtobin(byref dst, byref src as string, size as byte)

'--------------------------------------------------------------------
syscall(587,"03.TDL") bintostr(byref dst as string, byref src, size as byte)


'**************************************************************************************************
'		EVENTS (FOR ALL OBJECTS)
'**************************************************************************************************

event(1)  on_sys_init
'<b>EVENT of the sys object. </b><br><br> First event to be generated after your devices boots up. Typically, initialization code for
'your application is placed here.

'--------------------------------------------------------------------
event(3)  on_sock_inband
'<b>EVENT of the sock object. </b><br><br>
'At least one data byte is present in the CMD buffer (<font color="maroon"><b>sock.cmdlen</b></font>>0). Use the <font color="maroon"><b>
'sock.getinband </b></font> method to extract the data from the CMD buffer. <br><br>
'Another <font color="teal"><b>on_inband_command </b></font>event on a particular socket is never generated until the previous 
'one is processed. When the event handler is entered the <font color="maroon"><b>sock.num </b></font>is automatically switched to the 
'socket on which this event was generated. 

'--------------------------------------------------------------------
event(24)  on_sock_postdata
'<b>EVENT of the sock object. </b><br><br>
'Generated when at least one data byte is present in the VAR buffer of the socket,
'but only after the VAR buffer has become full at least once in the cause of the current HTTP request processing.
'<br><br>
'Two same-socket <font color="teal"><b>on_sock_postdata </b></font>events never wait in the queue -- the next event can only be generated after the previous one is processed.
'<br><br>
'Use the
'<font color="maroon"><b>sock.gethttprqstring </b></font>
'method or
'<font color="maroon"><b>sock.httprqstring </b></font>
'property to work with the VAR buffer's data.

'--------------------------------------------------------------------
event(4)  on_sock_data_arrival
'<b>EVENT of the sock object. </b><br><br> 
'Generated when at least one data byte is present in the RX buffer of the socket (i.e. for this socket the <font color="maroon"><b>
'sock.rxlen</b></font>>0). When the event handler for this event is entered the <font color="maroon"><b>sock.num </b></font>property is
'automatically switched to the socket for which this event was generated.<br><br>
'Another <font color="teal"><b>on_sock_data_arrival </b></font>event on a particular socket is never generated until the previous 
'one is processed. Use <font color="maroon"><b>sock.getdata </b></font>method to extract the data from the RX buffer.<br><br>
'For TCP protocol (<font color="maroon"><b>sock.protocol</b></font>= <font color="olive"><b>1- PL_SOCK_PROTOCOL_TCP</b></font>), there is 
'no separation into individual packets and you get all arriving data as a "stream". You don't have to process all data in the RX buffer at 
'once. If you exit the <font color="teal"><b>on_sock_data_arrival </b></font>event handler while there is still some unprocessed 
'data in the RX buffer another <font color="teal"><b>on_sock_data_arrival </b></font>event will be generated immediately.<br><br>
'For UDP protocol (<font color="maroon"><b>sock.protocol</b></font>= <font color="olive"><b>0- PL_SOCK_PROTOCOL_UDP</b></font>), the RX 
'buffer preserves datagram boundaries. Each time you enter the <font color="teal"><b>on_sock_data_arrival </b></font>event handler
'you get to process next UDP datagram. If you do not process entire datagram contents the unread portion of the datagram is discarded once 
'you exit the event handler.<br><br>
'This event is not generated for a particular socket when buffer redirection is set for this socket through the <font color="maroon"><b>
'sock.redir </b></font>method.

'--------------------------------------------------------------------
enum pl_sock_state
'<b>ENUM. </b><br><br> Contains the list of constants related to possible socket states. See also enum <font color="olive"><b>pl_sock_state_simple</b></font>.
	PL_SST_CLOSED=0,			'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (and haven't been opened yet, it is a
								'post-powerup state). <br><br>Applies both to UDP and TCP.
	PL_SST_CL_PCLOSED,			'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was a passive close). <br><br>Applies only to TCP.
	PL_SST_CL_ACLOSED,			'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active close by the
								'application). <br><br>Applies only to TCP.
	PL_SST_CL_PRESET_POPENING,	'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was a passive reset during a
								'passive open).<br><br> Applies only to TCP.
	PL_SST_CL_PRESET_AOPENING,	'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was a passive reset during an
								'active open). <br><br>Applies only to TCP.
	PL_SST_CL_PRESET_EST,		'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was a passive reset while in
								'"connection established" state). <br><br>Applies only to TCP.
	PL_SST_CL_PRESET_PCLOSING,	'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was a passive reset while performing
								'a passive close). Applies only to TCP.
	PL_SST_CL_PRESET_ACLOSING,	'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was a passive reset while performing
								'an active close). <br><br>Applies only to TCP.
	PL_SST_CL_PRESET_STRANGE,	'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was a passive reset, no further
								'details available). <br><br>Applies only to TCP.
	PL_SST_CL_ARESET_CMD,		'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset issued by the
								'application). <br><br>Applies only to TCP.
	PL_SST_CL_ARESET_RE_PO,		'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset issued because
								'of excessive retransmission attempts during a passive open). <br><br>Applies only to TCP.
	PL_SST_CL_ARESET_RE_AO,		'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset issued because
								'of excessive retransmission attempts during an active open). <br><br>Applies only to TCP.
	PL_SST_CL_ARESET_RE_EST,	'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset issued because
								'of excessive retransmission attempts while in "connection established" state).
								'<br><br>Applies only to TCP.
	PL_SST_CL_ARESET_RE_PC,		'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset issued because
								'of excessive retransmission attempts during a passive close). <br><br>Applies only to TCP.
	PL_SST_CL_ARESET_RE_AC,		'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset issued because
								'of excessive retransmission attempts during a passive open). <br><br>Applies only to TCP.
	PL_SST_CL_ARESET_TOUT,		'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset caused by
								'connection timeout, i.e. no data was exchanged for sock.connectiontout number of
								'seconds). <br><br>Applies only to TCP.
	PL_SST_CL_ARESET_DERR,		'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset caused by
								'a data exchange error). <br><br>Applies only to TCP.
	PL_SST_CL_DISCARDED_CMD,	'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was discarded by the application).
								'<br><br>Applies both to UDP and TCP.
	PL_SST_CL_DISCARDED_PO_WCS,	'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was discarded because an error
								'in connection sequence was detected during a passive open). <br><br>Applies only to TCP.
	PL_SST_CL_DISCARDED_AO_WCS,	'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was discarded because an error
								'in connection sequence was detected during an active open). <br><br>Applies only to TCP.
	PL_SST_CL_DISCARDED_ARPFL,	'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was discarded because the device has
								'failed to resolve the IP address of the destination during an active open, i.e.
								'there was no reply to ARP requests). <br><br>Applies both to UDP and TCP.
	PL_SST_CL_DISCARDED_TOUT,	'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was discarded because connection has 
								'timed out, i.e. no data was exchanged for sock.connectiontout number of seconds). <br><br>
								'Applies only to UDP.
	PL_SST_ARP=&h20,			'<b>PLATFORM CONSTANT. </b><br><br> ARP resolution is an progress (it is an active open).
								'<br><br>Applies both to UDP and TCP.
	PL_SST_PO=&h40,				'<b>PLATFORM CONSTANT. </b><br><br> Connection is being established (it is a passive open).
								'<br><br>Applies only to TCP.
	PL_SST_AO=&h60,				'<b>PLATFORM CONSTANT. </b><br><br> Connection is being established (it is an active open).
								'<br><br>Applies only to TCP.
	PL_SST_EST=&h80,			'<b>PLATFORM CONSTANT. </b><br><br> Connection is established (generic, includes both passive
								'and active open). <br><br>Applies both to UDP and TCP.  
	PL_SST_EST_POPENED=&h80,	'<b>PLATFORM CONSTANT. </b><br><br> Connection is established (it was a passive open).
								'<br><br>Applies both to UDP and TCP. 
	PL_SST_EST_AOPENED,			'<b>PLATFORM CONSTANT. </b><br><br> Connection is established (it was an active open).
								'<br><br>Applies both to UDP and TCP.
	PL_SST_PC=&hA0,				'<b>PLATFORM CONSTANT. </b><br><br> Connection is being closed (it is a passive close).
								'<br><br>Applies only to TCP. 
	PL_SST_AC=&hC0				'<b>PLATFORM CONSTANT. </b><br><br> Connection is being closed (it is an active close).
								'<br><br>Applies only to TCP.
end enum

enum pl_sock_state_simple
'<b>ENUM. </b><br><br> Contains a simplified list of constants related to possible socket states. See also enum <font color="olive"><b>pl_sock_state</b></font>.
	PL_SSTS_CLOSED,		'<b>PLATFORM CONSTANT. </b><br><br> Connection is closed. <br><br>Applies both to UDP and TCP.
	PL_SSTS_ARP,		'<b>PLATFORM CONSTANT. </b><br><br> ARP resolution is an progress (it is an active open).
						'<br><br>Applies both to UDP and TCP.
	PL_SSTS_PO,			'<b>PLATFORM CONSTANT. </b><br><br> Connection is being established (it is a passive open).
						'<br><br>Applies only to TCP.
	PL_SSTS_AO,			'<b>PLATFORM CONSTANT. </b><br><br> Connection is being established (it is an active open).
						'<br><br>Applies only to TCP.
	PL_SSTS_EST,		'<b>PLATFORM CONSTANT. </b><br><br> Connection is established. <br><br>Applies both to UDP and TCP.  
	PL_SSTS_PC,			'<b>PLATFORM CONSTANT. </b><br><br> Connection is being closed (it is a passive close).
						'<br><br>Applies only to TCP. 
	PL_SSTS_AC			'<b>PLATFORM CONSTANT. </b><br><br> Connection is being closed (it is an active close).
						'<br><br>Applies only to TCP.
end enum

event(5)  on_sock_event(newstate as pl_sock_state,newstatesimple as pl_sock_state_simple)
'<b>EVENT of the sock object. </b><br><br> 
'Notifies your program that the socket state has changed.
'<br><br>
'The newstate and newstatesimple arguments carry the state as it was at the moment of event generation.
'This is different from
'<font color="maroon"><b>sock.state </b></font>and
'<font color="maroon"><b> sock.statesimple</b></font>
'R/O properties that return current socket state.
'<br><br>
'See <font color="olive"><b>pl_sock_state </b></font>and
'<font color="olive"><b>pl_sock_state_simple </b></font>
'constants for description of reported socket states.
'<br><br>
'Multiple
'<font color="olive"><b>on_sock_event </b></font>
'events may be waiting in the event queue. For this reason the doevents statement will be skipped (not executed) if encountered within the event handler
'for this event or the body of any procedure in the related call chain.

'--------------------------------------------------------------------
event(6)  on_sock_overrun
'<b>EVENT of the sock object. </b><br><br> Data overrun has occurred in the RX buffer of the socket. Normally, this can only happen
'for UDP communications as UDP has no "data flow control" and, hence, data overruns are normal.
'<br><br>
'Another <font color="teal"><b>
'on_sock_overrun </b></font>event on a particular socket is never generated until the previous one is processed.
'<br><br>
'When event handler for this event is entered the <font color="maroon"><b>sock.num  </b></font>is automatically switched to the socket on 
'which this event was generated.

'--------------------------------------------------------------------
event(8)  on_pat
'<b>EVENT of the pat object. </b><br><br>
'Generated when LED pattern finishes "playing". This can only happened for "non-looped" patterns.
'<br><br>
'Multiple <font color="teal"><b>on_pat </b></font>events may be waiting in the event queue.
'When the event handler for this event is entered the
'<font color="maroon"><b>pat.channel </b></font>
'property is automatically set to the channel for which this event was generated. 


'--------------------------------------------------------------------
event(9)  on_ser_esc
'<b>EVENT of the ser object. </b><br><br> 
'Generated when currently enabled escape sequence is detected in the received UART data stream. Once the serial escape sequence is detected 
'on a certain serial port this port is automatically disabled (<font color="maroon"><b>ser.enabled</b></font>= <font color="olive"><b>
'0- NO</b></font>).
'<br><br>
'When event handler for this event is entered the <font color="maroon"><b>ser.num </b></font>
'property is automatically switched to the port
'on which this event was generated. Whether or not escape sequence detection is enabled and what kind of escape sequence is expected is
'defined by the
'<font color="maroon"><b>ser.esctype </b></font>property.
'<br><br>
'Escape sequence detection works even when buffer redirection is set for the serial port using the <font color="maroon"><b>ser.redir
'</b></font> method. Escape sequences are only recognized in the UART mode of the serial port (<font color="maroon"><b>ser.mode</b></font>
'= <font color="olive"><b>0- PL_SER_MODE_UART</b></font>).
'<br><br>
'Another <font color="teal"><b>on_ser_esc </b></font>
'event for a particular port is never generated until the previous one is processed.
'<br><br>

'--------------------------------------------------------------------
event(10) on_ser_data_arrival
'<b>EVENT of the ser object. </b><br><br> Generated when at least one data byte is present in the RX buffer of the serial port (i.e. for this
'port the  <font color="maroon"><b>ser.rxlen</b></font>)>0). When the event handler for this event is entered the <font color="maroon"><b>
'ser.num </b></font>property is automatically switched to the port for which this event was generated. <br><br>
'Another <font color="teal"><b>on_ser_data_arrival </b></font>event on a particular port is never generated until the previous one is
'processed. Use <font color="maroon"><b>ser.getdata </b></font>method to extract the data from the RX buffer. <br><br>
'You don't have to process all  data in the RX buffer at once. If you exit the <font color="teal"><b>on_ser_data_arrival
'</b></font>event handler while there is still some unprocessed data in the RX buffer another <font color="teal"><b>on_ser_data_arrival
'</b></font>event will be generated immediately. <br><br>
'This event is not generated for a particular port when buffer redirection is set for this port through the <font color="maroon"><b>
'ser.redir</b></font> method.

'--------------------------------------------------------------------
event(11) on_ser_data_sent
'<b>EVENT of the ser object. </b><br><br> 
'Generated after the total amount of committed data in the TX buffer of the serial port (<font color="maroon"><b>ser.txlen</b></font>) is 
'found to be less than the threshold that was preset through the <font color="maroon"><b>ser.notifysent </b></font>method. <br><br>
'This event may be generated only after the <font color="maroon"><b>ser.notifysent </b></font>method was used. Your application needs to use
'the <font color="maroon"><b>ser.notifysent </b></font>method EACH TIME it wants to cause the <font color="teal"><b>on_ser_data_sent
'</b></font>event generation for a particular port. <br><br>
'When the event handler for this event is entered the <font color="maroon"><b>ser.num </b></font>is automatically switched to the port on
'which this event was generated. Please, remember that uncommitted data in the TX buffer is not taken into account for the 
'<font color="teal"><b>on_sock_data_sent </b></font>event generation.

'--------------------------------------------------------------------
event(12) on_ser_overrun
'<b>EVENT of the ser object. </b><br><br> 
'Generated when data overrun has occurred in the RX buffer of the serial port.
'<br><br>
'Another <font color="teal"><b>on_ser_overrun </b></font>
'event for a particular port is never generated until the previous one is processed. <br><br>
'When the event handler for this event is entered the <font color="maroon"><b>ser.num </b></font>property is automatically switched to the
'port on which this event was generated. <br><br>
'Data overruns are a common occurrence on serial lines. The overrun happens when the serial data is arriving into the RX buffer faster than
'your application is able to extract it, the buffer runs out of space and "misses" some incoming data. <br><br>
'For UART/full-duplex mode of the serial port (<font color="maroon"><b>ser.mode</b></font>= <font color="olive"><b>0- PL_SER_MODE_UART
'</b></font> and <font color="maroon"><b>ser.interface</b></font>= <font color="olive"><b>0- PL_SER_SI_FULLDUPLEX</b></font>) data overruns
'can be prevented through the use of RTS/CTS flow control (see <font color="maroon"><b>ser.flowcontrol</b></font>).
 
'--------------------------------------------------------------------
event(13) on_sock_data_sent
'<b>EVENT of the sock object. </b><br><br> 
'Generated after the total amount of committed data in the TX buffer of the socket (<font color="maroon"><b>sock.txlen</b></font>) is
'found to be less than the threshold that was preset through the <font color="maroon"><b>sock.notifysent </b></font>method. This event may
'be generated only after the <font color="maroon"><b>sock.notifysent</b></font> method was used. <br><br>
'Your application needs to use the <font color="maroon"><b>sock.notifysent</b></font> method EACH TIME it wants to cause the 
'<font color="teal"><b>on_sock_data_sent </b></font>event generation for a particular socket. <br><br>
'When the event handler for this event is entered the <font color="maroon"><b>sock.num  </b></font>is automatically switched to the port on
'which this event was generated. Please, remember that uncommitted data in the TX buffer is not taken into account for the 
'<font color="teal"><b>on_sock_data_sent </b></font>event generation.

'--------------------------------------------------------------------
event(16) on_button_released
'<b>EVENT of the button object. </b><br><br> 
'Generated when the button on your device is released. Multiple <font color="teal"><b>on_button_released </b></font>
'events may be waiting in the event queue. <br><br>
'You can check the time elapsed since the previous <font color="teal"><b> on_button_pressed</b></font> event by reading the 
'value of the <font color="maroon"><b>button.time </b></font>read-only property.
'<br><br>
'Note that the button object performs "debouncing" which rejects very brief transitions of the button state.
'This event will not be generated for such spurious transitions.
'<br><br>
'See also: <font color="teal"><b>on_button_pressed </b></font>event.

'--------------------------------------------------------------------
event(18)  on_sock_tcp_packet_arrival(len as word)
'<b>EVENT of the sock object. </b><br><br> 
'Notifies your program that the TCP packet of a certain size has arrived.
'<br><br>
'The len argument carries packet length. This event is only generated when
'<font color="maroon"><b>sock.splittcppackets</b></font>= <font color="olive"><b>1- YES </b></font>and
'<font color="maroon"><b>sock.inbandcommands</b></font>= <font color="olive"><b>0- DISABLED</b></font>.
'<br><br>
'Notice that only new data, never transmitted before, is counted. If the packet is a retransmission then this event won't be generated. Also,
'if some part of packet's data is a retransmission and some part is new then only the length of the new data will be reported. This way your
'program can maintain correct relationship between data lengths reported by this event and actual data in the RX buffer.
'<br><br>
'Multiple
'<font color="olive"><b>on_sock_tcp_packet_arrival </b></font>
'events may be waiting in the event queue. For this reason the doevents statement will be skipped (not executed) if encountered within the event handler
'for this event or the body of any procedure in the related call chain.

'--------------------------------------------------------------------
event(31) on_button_pressed
'<b>EVENT of the button object. </b><br><br> 
'Generated when the button on your device is pressed. Multiple <font color="teal"><b>on_button_pressed </b></font>
'events may be waiting in the event queue.<br><br>
'You can check the time elapsed since the previous <font color="teal"><b> on_button_released </b></font>event by reading the
'value of the <font color="maroon"><b>button.time </b></font>read-only property.
'<br><br>
'Note that the button object performs "debouncing" which rejects very brief transitions of the button state.
'This event will not be generated for such spurious transitions.
'<br><br>
'See also: <font color="teal"><b>on_button_released </b></font>event.


'**************************************************************************************************
'		SER (Serial port) object
'**************************************************************************************************

object ser
'This is a serial port object that encompasses ALL serial ports (UARTs) available on a particular system (total number
'of available serial ports can be obtained through the <font color="maroon"><b>ser.numofports </b></font>read-only property).
'<br><br>
'Selection of a particular port to work with is done through the <font color="maroon"><b>ser.num property</b></font>. Most other 
'properties and methods refer to the currently selected port. When the handler for one of the serial port events is entered
'the <font color="maroon"><b>ser.num </b></font>is automatically switched to the port for which this event was generated.
'<br><br>
'Each serial port has 2 outputs- TX/W1out/dout and RTS/W0out/cout, and two inputs- RX/W1in/din and CTS/W0&1in/cin. Two lines- 
'TX/W1out/dout and RX/W1in/din use fixed I/O pins and cannot be remapped. Two other lines- RTS/W0out/cout and CTS/W0&1in/cin- can be 
'remapped through <font color="maroon"><b>ser.rtsmap </b></font>and <font color="maroon"><b>ser.ctsmap </b></font>properties.
'<br><br>
'The serial port can work in the UART, Wiegand, or clock/data mode (see <font color="maroon"><b>ser.mode</b></font>).
'<br><br>
'<b>Platforms with explicit configuration of I/O lines as inputs or outputs:</b>
'<br><br>
'For the Wiegand and clock/data mode, TX/W1out/dout and RTS/W0out/cout must be configured as outputs by the application (through <font color="maroon"><b>
'io.enabled</b></font>)- this won't happen automatically. The RX/W1in/din and CTS/W0&1in/cin lines must be configured as inputs- this 
'won't happen automatically as well. <br><br>For the UART mode, the TX/W1out/dout and RX/W1in/din are configured automatically when 
'the port is opened (see <font color="maroon"><b>ser.enabled</b></font>). Your application still needs to set the direction of 
'RTS/W0out/cout CTS/W0&1in/cin "manually".

'--------------------------------------------------------------------
property ser.numofports
'<b>READ-ONLY PROPERTY (BYTE). </b><br><br> 
'Returns total number of serial ports found on the current platform.
	get = syscall(137) as byte
end property

'--------------------------------------------------------------------
property ser.num
'<b>PROPERTY (BYTE), DEFAULT VALUE= 0 (serial port #0 selected). </b><br><br>
'Sets/returns the number of currently selected serial port (ports are enumerated from 0).
'Most other properties and methods of this object relate to the serial port selected through this property.<br><br>
'Note that serial-port related events such as <font color="teal"><b>on_ser_data_arrival </b></font> change currently selected port!
'The value of this property won't exceed <font color="maroon"><b>ser.numofports</b></font>-1 (even if you attempt to set a higher value).
	get = syscall(100) as byte
	set = syscall(101) (value as byte)
end property

'--------------------------------------------------------------------
property ser.enabled
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= <font color="olive"><b>0- NO</b></font> (not enabled). </b><br><br>
'Enables/disables currently selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>): 
'<font color="olive"><b>0- NO </b></font>(not enabled), <font color="olive"><b>1- YES </b></font>(enabled).<br><br>
'Enabling/disabling the serial port does not automatically clear its buffers, this is done via <font color="maroon"><b>ser.rxclear </b></font>
'and <font color="maroon"><b>ser.txclear</b></font>. <br><br>
'Notice that certain properties can only be changed and methods executed when the port is not enabled (<font color="maroon"><b>ser.rtsmap</b>
'</font>, <font color="maroon"><b>ser.ctsmap</b></font>, <font color="maroon"><b>ser.mode</b></font>, <font color="maroon"><b>ser.redir</b>
'</font>, <font color="maroon"><b>ser.txclear</b></font>). You also cannot allocate buffer memory for the port (do <font color="maroon"><b>
'sys.buffalloc </b></font>) when the port is enabled.
	get = syscall(102,"80.TDL"+) as no_yes
	set = syscall(103,"34.TDL"+) (value as no_yes)
end property

'--------------------------------------------------------------------
enum pl_ser_mode
'<b>ENUM. </b><br><br> 
'Contains the list of constants related to the selection of the operating mode of the serial port.
		PL_SER_MODE_UART,	'<b>PLATFORM CONSTANT (DEFAULT). </b><br><br> 
							'UART mode, suitable for RS232, RS422, RS485, etc. communications in full-duplex or half-duplex mode 
							'(see <font color="maroon"><b>ser.interface</b></font>).<br><br>
							'Data is transmitted through the TX pin and received through the RX pin. Optionally, RTS (output) and CTS 
							'(input) lines are used for flow control (see <font color="maroon"><b>ser.flowcontrol</b></font>) 
							'in the full-duplex mode. Additionally, RTS can be used for direction control in the half-duplex mode.
	PL_SER_MODE_WIEGAND,	'<b>PLATFORM CONSTANT. </b><br><br> 
							'Wiegand mode, suitable for sending to or receiving data from any standard Wiegand device. Data transmission 
							'is through pins W0out and W1out, reception- through W0&1in and W1in. <br><br>
							'"W0&1in" means that a logical AND of W0 and W1 signals must be applied to this input. Therefore, external 
							'logical gate is needed in order to receive Wiegand data.				
	PL_SER_MODE_CLOCKDATA	'<b>PLATFORM CONSTANT. </b><br><br> 
							'Clock/data mode, suitable for sending to or receiving data from any standard clock/data (or magstripe) device.
							'Data transmission is through pins cout and dout, reception- through cin and din. <br><br>
							'Third line of the magstripe interface- card present- is not required for data reception. For transmission, 
							'any I/O line can be used as card present output (under software control).
end enum

property ser.mode
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- UART (UART). </b><br><br>
'Sets operating mode for the currently selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>): 
'<font color="olive"><b>0- PL_SER_MODE_UART </b></font>(UART), <font color="olive"><b>1- PL_SER_MODE_WIEGAND </b></font>(Wiegand), 
'<font color="olive"><b>2- PL_SER_MODE_CLOCKDATA </b></font>(clock/data). <br><br>
'Changing port mode is only possible when the port is closed (<font color="maroon"><b>ser.enabled</b></font>= <font color="olive"><b>
'0- NO</b></font>). RTS/W1out/cout and CTS/W0&1in/cin lines can be remapped to other I/O pins of the device through the <font color="maroon"><b>
'ser.rtsmap </b></font>and <font color="maroon"><b>ser.ctsmap </b></font>properties.
'<br><br>
'<b>Platforms with explicit configuration of I/O lines as inputs or outputs:</b>
'<br><br>
'For the UART mode (and provided that <font color="maroon"><b>ser.flowcontrol</b></font>= <font color="olive"><b>1- ENABLED</b></font>),
'you will need to configure RTS line as output and CTS line as input through the <font color="maroon"><b>io.enabled </b></font>property. 
'TX and RX configuration will happen automatically. <br><br>
'For the Wiegand and clock/data mode, you will need to configure both RTS and TX as outputs, and CTS and RX as inputs.  
	get = syscall(75,"80.TDL"+) as pl_ser_mode
	set = syscall(76,"80.TDL"+) (value as pl_ser_mode)
end property

'--------------------------------------------------------------------
enum pl_ser_interface
'<b>ENUM. </b><br><br> 
'Contains the list of constants related to the selection of full-duplex or half-duplex interface for the UART mode
'of serial port (<font color="maroon"><b>ser.mode</b></font>= <font color="olive"><b>0- PL_SER_MODE_UART</b></font>).
	PL_SER_SI_FULLDUPLEX,	'<b>PLATFORM CONSTANT (DEFAULT). </b><br><br> 
							'Full-duplex mode, suitable for RS232, RS422, or four-wire RS485 communications. RTS output (together with 
							'CTS input) can be used for optional hardware flow control (see <font color="maroon"><b>ser.flowcontrol</b></font>).
	PL_SER_SI_HALFDUPLEX	'<b>PLATFORM CONSTANT. </b><br><br> 
							'Half-duplex mode, suitable for two-wire RS485 communications. RTS line is used for direction control.
							'Direction control polarity can be set through <font color="maroon"><b>ser.dircontrol </b></font>property.
end enum

property ser.interface
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- PL_SER_SI_FULLDUPLEX (full-duplex). </b><br><br>
'Chooses full-duplex or half-duplex operating mode for currently selected serial port (selection is made through <font color="maroon"><b>
'ser.num</b></font>): <font color="olive"><b>0- PL_SER_SI_FULLDUPLEX </b></font>(full-duplex mode), <font color="olive"><b>
'1- PL_SER_SI_HALFDUPLEX </b></font>(half-duplex mode). <br><br>
'Full-duplex mode is suitable for RS232, RS422, or four-wire RS485 communications. Half-duplex mode is suitable for 2-wire RS485 communications.
'This property is only relevant when the port is in the UART mode (<font color="maroon"><b>ser.mode</b></font>= <font color="olive"><b>
'0- PL_SER_MODE_UART</b></font>). <br><br>
'RTS and CTS lines can be remapped to other I/O pins of the device through the <font color="maroon"><b>ser.rtsmap </b></font>and 
'<font color="maroon"><b>ser.ctsmap </b></font>properties.
'<br><br>
'<b>Platforms with explicit configuration of I/O lines as inputs or outputs:</b>
'<br><br>
'You have to configure RTS line as output and CTS line as input 
'through the <font color="maroon"><b>io.enabled </b></font>property.
	get = syscall(112,"80.TDL"+) as pl_ser_interface
	set = syscall(113,"80.TDL"+) (value as pl_ser_interface)
end property

'--------------------------------------------------------------------
property ser.flowcontrol
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- DISABLED. </b><br><br> 
'Sets/returns flow control mode for currently selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>): 
'<font color="olive"><b>0- DISABLED</b></font>, <font color="olive"><b>1- ENABLED</b></font>. Only relevant when the serial port is in UART 
'mode (<font color="maroon"><b>ser.mode</b></font>= <font color="olive"><b>0- PL_SER_MODE_UART</b></font>) and full-duplex interface is selected 
'(<font color="maroon"><b>ser.interface</b></font>= <font color="olive"><b>0- PL_SER_SI_FULLDUPLEX</b></font>).<br><br>
'Flow control uses two serial port lines- RTS and CTS- to regulate the flow of data between the serial port of your device and another 
'("attached") serial device. On this platform you can select which I/O line will serve as RTS line and which- as CTS line (see 
'<font color="maroon"><b>ser.rtsmap </b></font>and <font color="maroon"><b>ser.ctsmap</b></font>).
'<br><br>
'<b>Platforms with explicit configuration of I/O lines as inputs or outputs:</b>
'<br><br>
'The RTS lines are not automatically configured as outputs and CTS- as inputs. You need to do this manually, through 
'the <font color="maroon"><b>io.enabled </b></font>property of the io object. 
	get = syscall(110,"80.TDL"+) as dis_en
	set = syscall(111,"80.TDL"+) (value as dis_en)
end property

'--------------------------------------------------------------------
property ser.rtsmap
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE- different for each serial port: UART0: 0- PL_IO_NUM_0, <br>
'UART1: 1- PL_IO_NUM_1,<br> UART2: 2- PL_IO_NUM_2, <br> UART3: 3- PL_IO_NUM_3. </b><br><br>
'Sets/returns the number of the I/O line that will act as RTS/W0out/cout output of currently selected serial port (selection is made through 
'<font color="maroon"><b>ser.num</b></font>). When the port in in the UART/full-duplex mode (<font color="maroon"><b>ser.mode </b></font>= 
'<font color="olive"><b>0- PL_SER_MODE_UART </b></font>and <font color="maroon"><b>ser.interface </b></font>= <font color="olive"><b>
'0- PL_SER_SI_FULLDUPLEX</b></font>) and the flow control is enabled (<font color="maroon"><b>ser.flowcontrol </b></font>=
'<font color="olive"><b>1- ENABLED</b></font>) the line will act as an RTS output, used for flow control. <br><br>
'In the UART/half-duplex mode (<font color="maroon"><b>ser.mode </b></font>= <font color="olive"><b>0- PL_SER_MODE_UART </b></font>and
'<font color="maroon"><b>ser.interface </b></font>= <font color="olive"><b>1- PL_SER_SI_HALFDUPLEX</b></font>) this line acts as direction 
'control output (see also <font color="maroon"><b>ser.dircontrol</b></font>). <br><br>
'In the UART mode, this line has no function when the port is configured for full-duplex operation and the flow control is disabled. When the 
'port is in the Wiegand mode (<font color="maroon"><b>ser.mode </b></font>= <font color="olive"><b>1- PL_SER_MODE_WIEGAND</b></font>) the line 
'will act as a W0out output of Wiegand interface. When the port is in the clock/data mode (<font color="maroon"><b>ser.mode </b></font>= 
'<font color="olive"><b>2- PL_SER_MODE_CLOCKDATA</b></font>) the line will act as a clock output of the clock/data interface. <br><br>
'Absolutely any I/O line can be selected by this property, as long as this line is not occupied by some other function. Property value can only 
'be changed when the port is closed (<font color="maroon"><b>ser.enabled </b></font>= <font color="olive"><b>0- NO</b></font>).
'<br><br>
'<b>Platforms with explicit configuration of I/O lines as inputs or outputs:</b>
'<br><br>
'For the selected line to work, you have to configure it as an output through the <font color="maroon"><b>io.enabled </b></font>property of the 
'io object.
	get = syscall(168,"80.TDL"+) as pl_io_num
	set = syscall(169,"80.TDL"+) (value as pl_io_num)
end property

'--------------------------------------------------------------------
property ser.ctsmap
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE- different for each serial port: UART0: 0- PL_INT_NUM_0, <br>
'UART1: 1- PL_INT_NUM_1, <br>UART2: 2- PL_INT_NUM_2, <br>UART3: 3- PL_INT_NUM_3. </b><br><br>
'Sets/returns the number of I/O line that will act as CTS/W0&1in/cin input of currently selected serial port (selection is made through 
'<font color="maroon"><b>ser.num</b></font>). When the port in in the UART mode (<font color="maroon"><b>ser.mode </b></font>= 
'<font color="olive"><b>0- PL_SER_MODE_UART</b></font>) and the flow control is enabled (ser.flowcontrol </b></font>= 1- ENABLED</b></font>) 
'the line will act as a CTS input, used for flow control. In the UART mode, this line has no function when the flow control is disabled.<br><br>
'When the port is in the Wiegand mode (<font color="maroon"><b>ser.mode </b></font>= <font color="olive"><b>1- PL_SER_MODE_WIEGAND</b></font>) 
'the line will act as a W0in input of Wiegand interface. <br><br>
'When the port is in the clock/data mode (<font color="maroon"><b>ser.mode </b></font>= <font color="olive"><b>2- PL_SER_MODE_CLOCKDATA</b>
'</font>) the line will act as a clock input of the clock/data interface.<br><br>
'Selection can be made only among interrupt lines 0-7 (that is, I/O lines 16-23). Regular, non-interrupt I/O lines cannot be selected. Property 
'value can only be changed when the port is closed (<font color="maroon"><b>ser.enabled </b></font>=<font color="olive"><b>0- NO</b></font>).
'<br><br>
'<b>Platforms with explicit configuration of I/O lines as inputs or outputs:</b>
'<br><br>
'For the selected line to work, you have to configure it as an input through the <font color="maroon"><b>io.enabled </b></font>
'property of the io object.
	get = syscall(174,"80.TDL"+) as pl_int_num
	set = syscall(23,"80.TDL"+) (value as pl_int_num)
end property

'--------------------------------------------------------------------
enum pl_ser_dircontrol
'<b>ENUM. </b><br><br> 
'Contains the list of constants related to the selection of polarity for the RTS line which controls direction in the UART/half-duplex mode of 
'the serial port (<font color="maroon"><b>ser.mode </b></font>= <font color="olive"><b>0- PL_SER_MODE_UART </b></font>and <font color="maroon">
'<b>ser.interface </b></font>= <font color="olive"><b>0- PL_SER_SI_FULLDUPLEX</b></font>).
	PL_SER_DCP_LOWFORINPUT,	'<b>PLATFORM CONSTANT (DEFAULT). </b><br><br> 
							'Specifies (for UART/half-duplex mode of the serial port) that the RTS output will be LOW when the serial 
							'port is ready to RX data and HIGH when the serial port is TXing data. LOW/HIGH states provided are for 
							'the TTL serial ports of MODULE-level products, for RS232 these states will be in reverse.
	PL_SER_DCP_HIGHFORINPUT	'<b>PLATFORM CONSTANT. </b><br><br> 
							'Specifies (for UART/half-duplex mode of the serial port) that the RTS output will be HIGH when the serial 
							'port is ready to RX data and LOW when the serial port is TXing data. LOW/HIGH states provided are for 
							'the TTL serial ports of MODULE-level products, for RS232 these states will be in reverse.
end enum

property ser.dircontrol
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- PL_SER_DCP_LOWFORINPUT (LOW for input). </b><br><br>
'Sets/returns the polarity of the direction control line (RTS) for selected serial port (selection is made through <font color="maroon">
'<b>ser.num</b></font>): <br> <font color="olive"><b>0- PL_SER_DCP_LOWFORINPUT </b></font>(DIR LOW for input, HIGH for output),<br> 
'<font color="olive"><b>1- PL_SER_DCP_HIGHFORINPUT </b></font>(DIR HIGH for input, LOW for output). <br><br>
'Which I/O line of the device will be used  as RTS line is defined by the <font color="maroon"><b>ser.rtsmap </b></font>property. 
'Direction control is only relevant when the serial port is in the UART/half-duplex mode (<font color="maroon"><b>ser.mode </b></font>
'= <font color="olive"><b>0- PL_SER_MODE_UART </b></font>and <font color="maroon"><b>ser.interface </b></font>= <font color="olive"><b>
'1- PL_SER_SI_HALFDUPLEX</b></font>).<br><br>
'Note, that HIGH/LOW states specified above are for the TTL-serial interface of the MODULE-level products. If you are dealing with the RS232 
'port then the states will be in reverse (for example, <font color="olive"><b>1- PL_SER_DCP_HIGHFORINPUT </b></font>will mean "LOW for input, 
'HIGH for output"). When the serial port is in the UART/half-duplex mode you can use the CTS line as a regular I/O line of your device.
	get = syscall(114,"80.TDL"+) as pl_ser_dircontrol
	set = syscall(115,"80.TDL"+) (value as pl_ser_dircontrol)
end property

'--------------------------------------------------------------------
property ser.baudrate
'<b>PROPERTY (WORD), DEFAULT VALUE= "platform-dependent, results in 9600 bps". </b><br><br>
'Sets/returns the baudrate "divisor value" for the selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>).
'Actual baudrade is calculated as follows: (9600*<font color="maroon"><b>ser.div9600</b></font>)/<font color="maroon"><b>ser.baudrate</b></font>.
'<br><br> 
'The <font color="maroon"><b>ser.div9600 </b></font>read-only property returns the value <font color="maroon"><b>ser.baudrate </b></font>must 
'be set to in order to obtain 9600 bps on a particular device under present operating confitions. This property is only relevant when the 
'serial port is in the UART mode (<font color="maroon"><b>ser.mode </b></font>= <font color="olive"><b>0- PL_SER_MODE_UART</b></font>).
	get = syscall(104,"80.TDL"+) as word
	set = syscall(105,"34.TDL"+) (value as word)
end property

'--------------------------------------------------------------------
enum pl_ser_parity
'<b>ENUM. </b><br><br> 
'Contains the list of constants related to the selection of the parity mode of the serial port in the UART mode
'(<font color="maroon"><b>ser.mode </b></font>= <font color="olive"><b>0- PL_SER_MODE_UART</b></font>).
	PL_SER_PR_NONE,		'<b>PLATFORM CONSTANT (DEFAULT). </b><br><br> No parity bit to be transmitted.
	PL_SER_PR_EVEN,		'<b>PLATFORM CONSTANT. </b><br><br> Even parity.
	PL_SER_PR_ODD,		'<b>PLATFORM CONSTANT. </b><br><br> Odd parity.
	PL_SER_PR_MARK,		'<b>PLATFORM CONSTANT. </b><br><br> Parity bit always at "1". Also can be used to emulate second stop bit
						'(there is no separate property to explicitely select the number of stop bits).
	PL_SER_PR_SPACE		'<b>PLATFORM CONSTANT. </b><br><br> Parity bit always at "0".
end enum

property ser.parity
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- PL_SER_PR_NONE (no parity). </b><br><br>
'Sets/returns parity mode for the selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>):<br>
'<font color="olive"><b>0- PL_SER_PR_NONE </b></font>(no parity),<br> <font color="olive"><b>1- PL_SER_PR_EVEN </b></font>(even parity),<br> 
'<font color="olive"><b>2- PL_SER_PR_ODD </b></font>(odd parity),<br> <font color="olive"><b>3- PL_SER_PR_MARK </b></font>(mark),<br>
'<font color="olive"><b>4- PL_SER_PR_SPACE </b></font>(space). <br><br>
'Mark parity is equivalent to having a second stop-bit (there is no separate property toexplicitly select the number of stop bits). This 
'property is only relevant when the serial port is in the UART mode (<font color="maroon"><b>ser.mode </b></font>= <font color="olive">
'<b>0- PL_SER_MODE_UART</b></font>).
	get = syscall(106,"80.TDL"+) as pl_ser_parity
	set = syscall(107,"34.TDL"+) (value as pl_ser_parity)
end property

'--------------------------------------------------------------------
enum pl_ser_bits
'<b>ENUM. </b><br><br> 
'Contains the list of constants related to the selection of the number of bits in the word TXed/RXed by the serial
'port in the UART mode (<font color="maroon"><b>ser.mode</b></font>= <font color="olive"><b>0- PL_SER_MODE_UART</b></font>).
	PL_SER_BB_7,		'<b>PLATFORM CONSTANT. </b><br><br> Data word TXed/RXed by the serial port is to contain 7 data bits.
	PL_SER_BB_8		'<b>PLATFORM CONSTANT (DEFAULT). </b><br><br> Data word TXed/RXed by the serial port is to contain 8 data bits.
end enum

property ser.bits
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 1- PL_SER_BB_8 (8 bits). </b><br><br>
'Specifies the number of data bits in a word TXed/RXed by the serial port for the currently selected port (selection is made through
'<font color="maroon"><b>ser.num</b></font>):<br> <font color="olive"><b>0- PL_SER_BB_7 </b></font>(7 bits/word),<br>
'<font color="olive"><b>1- PL_SER_BB_8 </b></font>(8 bits/word). <br><br>
'This property is only relevant when the serial port is in the UART mode (<font color="maroon"><b>ser.mode </b></font>= 
'<font color="olive"><b>0- PL_SER_MODE_UART</b></font>).
	get = syscall(108,"80.TDL"+) as pl_ser_bits
	set = syscall(109,"34.TDL"+) (value as pl_ser_bits)
end property

'--------------------------------------------------------------------
property ser.interchardelay
'<b>PROPERTY (BYTE), DEFAULT VALUE= 0 (no delay). </b><br><br>
'Sets/returns maximum intercharacter delay for the selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>) 
'in 10ms steps.<br><br>
'For UART mode (<font color="maroon"><b>ser.mode </b></font>= <font color="olive"><b>0- PL_SER_MODE_UART</b></font>) specifies the time that 
'needs to elapse since the arrival of the most recent serial character into the RX buffer to cause the data to be committed (and 
'<font color="teal"><b>on_ser_data_arrival </b></font>event generated). <br><br>
'For Wiegand and clock/data mode (<font color="maroon"><b>ser.mode </b></font>= <font color="olive"><b>1- PL_SER_MODE_WIEGAND </b></font>or 
'<font color="olive"><b>2- PL_SER_MODE_CLOCKDATA</b></font>) the time since the most recent data bit (high-to-low transition on the W0&1in/cin 
'line) is counted. <br><br>
'In the UART mode this property allows you to combine incoming serial data into larger "chunks", which typically improves performance. Notice, 
'that the time is not counted when the new data is not being received because the serial port has set the RTS line to LOW (not ready).<br><br>
'For this to happen, the serial port must be in the UART/full-duplex/flow control mode (<font color="maroon"><b>ser.mode </b></font>= 
'<font color="olive"><b>0- PL_SER_MODE_UART</b></font>, <font color="maroon"><b>ser.interface </b></font>= <font color="olive"><b>
'0- 0- PL_SER_SI_FULLDUPLEX</b></font>, and <font color="maroon"><b>ser.flowcontrol </b></font>= <font color="olive"><b>1- ENABLED</b></font>) 
'and the RX buffer must be getting nearly full (less than 64 bytes of free space left). <br><br>
'For Wiegand and clock/data modes, counting timeout  since the last bit is the only way to determine the end of the data output. Suggested 
'timeout is app. 10 times the bit period of the data output by attached Wiegand or clock/data device.
	get = syscall(116,"80.TDL"+) as byte
	set = syscall(117,"80.TDL"+) (value as byte)
end property

'--------------------------------------------------------------------
property ser.autoclose
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= <font color="olive"><b>0- NO</b></font>. </b><br><br>
'For currently selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>) specifies whether the port will 
'be disabled (<font color="maroon"><b>ser.enabled </b></font>= <font color="olive"><b>0- NO</b></font>) once the intercharacter gap expires 
'(see <font color="maroon"><b>ser.interchardelay</b></font>): <br><br>
'<font color="olive"><b>0- NO </b></font>(port won't be closed),<br> <font color="olive"><b>1- YES </b></font>(port will be closed). <br><br>
'This property offers a way to make sure that no further data is received once the gap of certain length is encountered. This property is
'especially useful in Wiegand or clock/data mode (<font color="maroon"><b>ser.mode </b></font>= <font color="olive"><b>
'1- PL_SER_MODE_WIEGAND </b></font>or <font color="olive"><b>2- PL_SER_MODE_CLOCKDATA</b></font>) where intercharacter gap is the only way 
'to reliably identify the end of one data transmission.
	get = syscall(77,"80.TDL"+) as no_yes
	set = syscall(78,"80.TDL"+) (autoclose as no_yes)
end property

'--------------------------------------------------------------------
enum pl_ser_esctype
'<b>ENUM. </b><br><br> 
'Contains the list of constants related to the selection of the escape sequence type for the the serial port when the
'port is in the UART mode (<font color="maroon"><b>ser.mode </b></font>= <font color="olive"><b>0- PL_SER_MODE_UART</b></font>).
	PL_SER_ET_DISABLED,		'<b>PLATFORM CONSTANT. </b><br><br> Recognition of serial escape sequences disabled.
	PL_SER_ET_TYPE1,		'<b>PLATFORM CONSTANT. </b><br><br> 
							'Escape sequences of type1 are to be recognized. Type1 escape sequence is "prev_char<--min 100ms-->EC<--min 
							'100ms-->EC<--min 100ms-->EC", where "EC" is escape character defined by the <font color="maroon"><b>
							'ser.escchar </b></font>property.<br><br>
							'There must be at least 100ms gap before the arrival of each escape character, otherwise the character will be 
							'counted as a regular data character. When escape sequence is detected in the incoming UART data stream the 
							'<font color="teal"><b>on_ser_esc </b></font>event is generated and the serial port is disabled, 
							'i.e. <font color="maroon"><b>ser.enabled </b></font>= <font color="olive"><b>0- NO</b></font>. 
	PL_SER_ET_TYPE2			'<b>PLATFORM CONSTANT</b></font>. </b><br><br> 
							'Escape sequences of type2 are to be recognized. Type2 escape sequence is "EC OC", where "EC" is escape 
							'character defined by the <font color="maroon"><b>ser.escchar </b></font>property and "OC" is any character other
							'than "EC".<br><br>
							'When escape sequence is detected in the incoming UART data stream the <font color="teal"><b>on_ser_esc
							'</b></font>event is generated and the serial port is disabled, i.e. <font color="maroon"><b>ser.enabled 
							'</b></font>= <font color="olive"><b>0- NO</b></font>.<br><br>
							'Data character with ASCII code matching that of selected EC should be transmitted as "EC EC"- this will result 
							'in a single character added to the RX buffer of the serial port.
end enum

property ser.esctype
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- PL_SER_ET_DISABLED (escape sequences disabled).  </b><br><br>
'Defines, for selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>) whether serial escape sequence
'recognition is enabled and, if yes, what type of escape sequence is to be recognised. <br><br>
'Escape sequence is a special occurrence of characters in the incoming data received by the serial port. When escape sequence is detected the
'<font color="teal"><b>on_ser_esc</b></font> event is generated and the serial port is disabled (<font color="maroon"><b>
'ser.enabled </b></font>= <font color="olive"><b>0- NO</b></font>). When enabled, serial escape sequence detection works even when the buffer
'shorting is employed (see <font color="maroon"><b>ser.redir </b></font>property). <br><br>
'The <font color="maroon"><b>ser.esctype </b></font>property can have the following values: <br>  
'<font color="olive"><b>0- PL_SER_ET_DISABLED </b></font>(recognition of serial escape sequences disabled),<br><font color="olive">
'<b>1- PL_SER_ET_TYPE1</b></font> (Escape sequences of type1 are to be recognized),<br> <font color="olive"><b> 2- PL_SER_ET_TYPE2
'</b></font>(escape sequences of type2 are to be recognized).<br><br> 
'Type1 escape sequence is "prev_char<--min 100ms-->EC<--min 100ms-->EC<--min 100ms-->EC" and Type2 sequence is "EC OC", where "EC" is escape
'character defined by the <font color="maroon"><b>ser.escchar </b></font>property and "OC" is any character other than "EC".<br><br>
'This property is only relevant in the UART mode of the serial port (<font color="maroon"><b>ser.mode </b></font>= <font color="olive">
'<b>0- PL_SER_MODE_UART</b></font>).
	get = syscall(120,"80.TDL"+) as pl_ser_esctype
	set = syscall(121,"80.TDL"+) (value as pl_ser_esctype)
end property

'--------------------------------------------------------------------
property ser.escchar
'<b>PROPERTY (BYTE), DEFAULT VALUE= 1 (SOH character).  </b><br><br>
'For selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>) sets/retrieves ASCII code of the escape
'character used for type1 or type2 serial escape sequences. <br><br>
'Which escape sequence is enabled is defined by the <font color="maroon"><b>ser.esctype </b></font>property. This property is irrelevant when
'<font color="maroon"><b>ser.esctype </b></font>= <font color="olive"><b>0- PL_SER_ET_DISABLED </b></font> (escape sequences disabled) or when
'the serial port is in the Wiegand or clock/data mode (<font color="maroon"><b>ser.mode </b></font>= <font color="olive"><b>
'1- PL_SER_MODE_WIEGAND </b></font> or <font color="maroon"><b>ser.mode </b></font>= <font color="olive"><b>2- PL_SER_MODE_CLOCKDATA</b></font>)
'-- serial escape sequences are only recognized in the UART data.
	get = syscall(118,"80.TDL"+) as byte
	set = syscall(119,"80.TDL"+) (value as byte)
end property

'--------------------------------------------------------------------
property ser.rxbuffsize
'<b>R/O PROPERTY (WORD), DEFAULT VALUE=0 (0 bytes). </b><br><br>
'For the selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>)returns current RX buffer capacity 
'in bytes. Buffer capacity can be changed through the <font color="maroon"><b>ser.rxbuffrq </b></font>method followed by the 
'<font color="maroon"><b>sys.buffalloc </b></font>method.<br><br>
'The <font color="maroon"><b>ser.rxbuffrq </b></font>requests buffer size in 256-byte pages whereas this property returns buffer size 
'in bytes. Relationship between the two is as follows: <br><br><font color="maroon"><b>ser.rxbuffsize</b></font>=num_pages*256-16 (or =0 
'when num_pages=0), where "num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>ser.rxbuffrq</b></font>.
'"-16" is because 16 bytes are needed for internal buffer variables. <br><br>
'The serial port cannot RX data when the RX buffer has zero capacity.
	get = syscall(122,"38.TDL"+) as word
end property

'--------------------------------------------------------------------
property ser.txbuffsize
'<b>R/O PROPERTY (WORD), DEFAULT VALUE=0 (0 bytes). </b><br><br>
'For the selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>) returns current TX buffer capacity 
'in bytes. Buffer capacity can be changed through the <font color="maroon"><b>ser.txbuffrq </b></font>method followed by the 
'<font color="maroon"><b>sys.buffalloc </b></font>method. <br><br>
'The <font color="maroon"><b>ser.txbuffrq </b></font>requests buffer size in 256-byte pages whereas this property returns buffer size 
'in bytes. Relationship between the two is as follows: <br><br><font color="maroon"><b>ser.txbuffsize</b></font>=num_pages*256-16 (or =0 
'when num_pages=0), where "num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>ser.txbuffrq</b></font>. 
'"-16" is because 16 bytes are needed for internal buffer variables. <br><br>
'The serial port cannot TX data when the TX buffer has zero capacity.
	get = syscall(123,"38.TDL"+) as word
end property

'--------------------------------------------------------------------
property ser.rxlen
'<b>R/O PROPERTY (WORD), DEFAULT VALUE=0 (0 bytes). </b><br><br>
'For the selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>) returns total number of committed bytes
'currently waiting in the RX buffer to be extracted and processed by your application. <br><br>
'The <font color="teal"><b>on_ser_data_arrival </b></font>event is generated once the RX buffer is not empty, i.e. there is data to
'process. There may be only one <font color="teal"><b>on_ser_data_arrival </b></font>event for each port waiting to be processed in 
'the event queue. Another <font color="teal"><b>on_ser_data_arrival </b></font> event for the same port may be generated only after
'the previous one is handled.<br><br>
'If, during the <font color="teal"><b>on_ser_data_arrival </b></font>event handler execution, not all data is extracted from the RX 
'buffer, another <font color="teal"><b>on_ser_data_arrival </b></font>event is generated immediately after the 
'<font color="teal"><b>on_ser_data_arrival </b></font>event handler is exited.<br><br>
'Notice that the RX buffer of the serial port employes "data committing" based on the amount of data in the buffer and intercharacter delay 
'(<font color="maroon"><b>ser.interchardelay</b></font>). Data in the RX buffer may not be committed yet. Uncommitted data is not visible
'to your application and is not included in the count returned by the  <font color="maroon"><b>ser.rxlen</b></font>).
	get = syscall(124,"37.TDL"+) as word
end property

'--------------------------------------------------------------------
property ser.txlen
'<b>R/O PROPERTY (WORD), DEFAULT VALUE=0 (0 bytes). </b><br><br>
'For the selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>) returns total number of committed bytes
'currently found in the TX buffer. The data in the TX buffer does not become committed until you use the  <font color="maroon"><b>ser.send
'</b></font>) method. <br><br>
'Your application may use the <font color="maroon"><b>ser.notifysent </b></font>method to get <font color="teal"><b>
'on_ser_data_sent </b></font>event once the total number of committed bytes in the TX buffer drops below the level defined by the
'<font color="maroon"><b>ser.notifysent </b></font> method. <br><br>
'See also <font color="maroon"><b>ser.newtxlen</b></font>.
	get = syscall(125,"37.TDL"+) as word
end property

'--------------------------------------------------------------------
property ser.txfree
'<b>R/O PROPERTY (WORD), DEFAULT VALUE=0 (0 bytes). </b><br><br>
'For the selected serial port (selection is made through <font color="maroon"><b>ser.num </b></font>)returns the amount of free space in the TX
'buffer in bytes, not taking into account uncommitted data. <br><br>
'Actual free space is <font color="maroon"><b>ser.txfree</b></font> - <font color="maroon"><b>ser.newtxlen</b></font>. Your application will not
'be able to store more data than this amount.<br><br>
'To achieve asynchronous data processing, use the <font color="maroon"><b>ser.notifysent</b></font> method to get <font color="teal">
'<b>on_ser_data_sent </b></font>event once the TX buffer gains required amount of free space.
	get = syscall(127) as word
end property

'--------------------------------------------------------------------
property ser.newtxlen
'<b>R/O PROPERTY (WORD), DEFAULT VALUE=0 (0 bytes). </b><br><br>
'For the selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>) returns the amount of uncommitted TX data
'in bytes.<br><br>
'Uncommited data is the one that was added to the TX buffer with the <font color="maroon"><b>ser.setdata </b></font>method but not yet committed
'using the <font color="maroon"><b>ser.send</b></font>) method.
	get = syscall(133) as word
end property

'--------------------------------------------------------------------
syscall(128) ser.rxclear
'<b>METHOD. </b><br><br>
'For the selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>) clears (deletes all data from) the RX
'buffer.

'--------------------------------------------------------------------
syscall(129,"80.TDL"+) ser.txclear
'<b>METHOD. </b><br><br>
'For the selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>) clears (deletes all data from) the TX 
'buffer. This method will only work when the serial port is closed (<font color="maroon"><b>ser.enabled</b></font>= <font color="olive"><b>
'0- NO</b></font>).

'--------------------------------------------------------------------
syscall(130) ser.getdata(maxinplen as word) as string
'<b>METHOD. </b><br><br>
'For the selected serial port (selection is made through <font color="maroon"><b>ser.num </b></font>) returns the string that contains the data
'extracted from the RX buffer. Extracted data is permanently deleted from the buffer.<br><br>
'Length of extracted data is limited by one of the three factors (whichever is smaller): amount of committed data in the RX buffer itself,
'capacity of the "receiving" string variable, and the limit set by the maxinplen argument.<br><br>
'In the UART mode (<font color="maroon"><b>ser.mode</b></font>= <font color="olive"><b>0- PL_SER_MODE_UART</b></font>)
'the data is extracted "as is". <br><br>
'For Wiegand and clock/data mode (<font color="maroon"><b>ser.mode</b></font>= <font color="olive"><b>1- PL_SER_MODE_WIEGAND</b></font> and
'<font color="maroon"><b>ser.mode</b></font>= <font color="olive"><b>2- PL_SER_MODE_CLOCKDATA</b></font>) each character of extracted data
'represents one data bit and only two characters are possible: "0" or "1".
'<br><br>
'See also <font color="maroon"><b>ser.peekdata </b></font>method.

'--------------------------------------------------------------------
syscall(13) ser.peekdata(maxinplen as word) as string
'METHOD.
'For the selected serial port (selection is made through <font color="maroon"><b>ser.num </b></font>) returns the string that contains the "preview" of the data
'from the RX buffer. The data is NOT deleted from the buffer. Length of returned data is limited by one of the three factors
'(whichever is smaller): amount of committed data in the RX buffer itself, capacity of the "receiving" string variable,
'and the limit set by the maxinplen argument.
'<br><br>
'String variables can hold up to 255 bytes of data, so this method will only
'allow you to preview up to 255 "next" bytes from the RX buffer.
'In the UART mode (<font color="maroon"><b>ser.mode</b></font>= <font color="olive"><b>0- PL_SER_MODE_UART</b></font>)
'the data is previed "as is".
'<br><br>
'For Wiegand and clock/data mode (<font color="maroon"><b>ser.mode</b></font>= <font color="olive"><b>1- PL_SER_MODE_WIEGAND</b></font> and
'<font color="maroon"><b>ser.mode</b></font>= <font color="olive"><b>2- PL_SER_MODE_CLOCKDATA</b></font>) each character of extracted data
'represents one data bit and only two characters are possible: "0" or "1".
'<br><br>
'See also <font color="maroon"><b>ser.getdata </b></font>method.

'--------------------------------------------------------------------
syscall(131) ser.setdata(byref txdata as string)
'<b>METHOD. </b><br><br>
'For the selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>) adds the data passed in the txdata argument
'to the contents of the TX buffer. <br><br>
'In the UART mode (<font color="maroon"><b>ser.mode</b></font>= <font color="olive"><b>0- PL_SER_MODE_UART</b></font>) the data is added "as is". 
'<br><br>For Wiegand and clock/data mode (<font color="maroon"><b>ser.mode</b></font>= <font color="olive"><b>1- PL_SER_MODE_WIEGAND </b></font>
'and <font color="maroon"><b>ser.mode</b></font>= <font color="olive"><b>2- PL_SER_MODE_CLOCKDATA</b></font>) each data character represents
'one data bit and only bit0 (least significant bit) of each character is relevant (therefore, adding "0101" will result in
'the 0101 sequence of data bits). <br><br>
'If the buffer doesn't have enough space to accommodate the data being added then this data will be truncated. Newly saved data is not sent out
'immediately. This only happens after the  <font color="maroon"><b>ser.send </b></font>) method is used to commit the data. This allows your
'application to prepare large amounts of data before sending it out.<br><br>
'Total amount of newly added (uncommitted) data in the buffer can be checked through the <font color="maroon"><b>ser.newtxlen</b></font>
'setting. <br><br>
'Also see <font color="maroon"><b>ser.txlen</b></font>, <font color="maroon"><b>ser.txfree</b></font>, <font color="maroon"><b>
'ser.notifysent</b></font>, and <font color="teal"><b>on_ser_data_sent</b></font>. 

'--------------------------------------------------------------------
syscall(132) ser.send()
'<b>METHOD. </b><br><br>
'For the selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>) commits (allows sending) the data that was
'previously saved into the TX buffer using the <font color="maroon"><b>ser.setdata</b></font> method.<br><br>
'You can monitor the sending progress by checking the <font color="maroon"><b>ser.txlen </b></font>property or using the 
'<font color="maroon"><b>ser.notifysent </b></font>method and the <font color="teal"><b>on_ser_data_sent </b></font>event. 

'--------------------------------------------------------------------
syscall(134) ser.notifysent(threshold as word)
'<b>METHOD. </b><br><br>
'Using this method for the selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>) will cause the 
'<font color="teal"><b>on_ser_data_sent </b></font> event to be generated when the amount of committed data in the TX buffer is found 
'to be equal or below "threshold" number of bytes.<br><br>
'Only one <font color="teal"><b>on_ser_data_sent </b></font>event will be generated each time after the <font color="maroon"><b>
'ser.notifysent </b></font> is invoked. This method, together with the <font color="teal"><b>on_ser_data_sent </b></font>event 
'provides a way to handle data sending asynchronously. <br><br>
'Just like with <font color="maroon"><b>ser.txfree</b></font>, the trigger you set won't take into account any uncommitted data in the TX buffer.

'--------------------------------------------------------------------
syscall(85,"35.TDL"+) ser.rxbuffrq(numpages as byte) as byte
'<b>METHOD. </b><br><br>
'For the selected serial port (selection is made through <font color="maroon"><b>ser.num </b></font>) pre-requests "numpages" number of 
'buffer pages (1 page= 256 bytes) for the RX buffer of the serial port. Returns actual number of pages that can be allocated.
'Actual allocation happens when the <font color="maroon"><b>sys.buffalloc </b></font> method is used. <br><br>
'The serial port is unable to RX data if its RX buffer has 0 capacity. Actual current buffer capacity can be checked through the
'<font color="maroon"><b>ser.rxbuffsize </b></font> which returns buffer capacity in bytes. <br><br>
'Relationship between the two is as follows: <font color="maroon"><b>ser.rxbuffsize</b></font>=num_pages*256-16 (or =0 when num_pages=0), where
'"num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>ser.rxbuffrq</b></font>. "-16" is because 16 
'bytes are needed for internal buffer variables.<br><br>
'Buffer allocation will not work if the serial port to which this buffer belongs is opened (<font color="maroon"><b>ser.enabled</b></font>=
'<font color="olive"><b>1- YES</b></font>) at the time when <font color="maroon"><b>sys.buffalloc </b></font> executes. You can only change
'buffer sizes of ports that are closed.<br><br>
'See also <font color="maroon"><b>ser.txbuffrq </b></font>method.

'--------------------------------------------------------------------
syscall(86,"35.TDL"+) ser.txbuffrq(numpages as byte) as byte
'<b>METHOD. </b><br><br>
'For the selected serial port (selection is made through <font color="maroon"><b>ser.num </b></font>) pre-requests "numpages" number of 
'buffer pages (1 page= 256 bytes) for the TX buffer of the serial port. Returns actual number of pages that can be allocated.
'Actual allocation happens when the <font color="maroon"><b>sys.buffalloc </b></font> method is used. <br><br>
'The serial port is unable to TX data if its TX buffer has 0 capacity. Actual current buffer capacity can be checked through the 
'<font color="maroon"><b>ser.txbuffsize </b></font> which returns buffer capacity in bytes.<br><br>
'Relationship between the two is as follows: <font color="maroon"><b>ser.txbuffsize</b></font>=num_pages*256-16 (or =0 when num_pages=0), where
'"num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>ser.txbuffrq</b></font>. "-16" is because 16
'bytes are needed for internal buffer variables.<br><br>
'Buffer allocation will not work if the serial port to which this buffer belongs is opened (<font color="maroon"><b>ser.enabled</b></font>= 
'<font color="olive"><b>1- YES</b></font>) at the time when <font color="maroon"><b>sys.buffalloc </b></font> executes. You can only change
'buffer sizes of ports that are closed.<br><br>
'See also <font color="maroon"><b>ser.rxbuffrq </b></font> method.

'--------------------------------------------------------------------
syscall(79,"24.TDL") ser.redir(redir as pl_redir) as pl_redir
'<b>METHOD. </b><br><br>
'For the selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>) redirects the data being RXed to the TX
'buffer of the same serial port, different serial port, or another object that supports compatible buffers.<br><br>
'The redir argument, as well as the value returned by this method are of "enum <font color="olive"><b>pl_redir </b></font>" type. The
'<font color="olive"><b>pl_redir </b></font>defines a set of inter-object constants that include all possible redirections for this
'platform. Specifying redir value of <font color="olive"><b>0- PL_REDIR_NONE </b></font>cancels redirection. <br><br>
'When the redirection is enabled for a particular serial port, the <font color="teal"><b>on_ser_data_arrival</b></font>
'event is not generated for this port. If redirection is being done on the port that is currently opened (<font color="maroon"><b>
'ser.enabled</b></font>= <font color="olive"><b>1- YES</b></font>) then the port will be closed automatically. <br><br>
'This method returns actual redirection result: <font color="olive"><b>0- PL_REDIR_NONE </b></font>if redirection failed or the same value
'as the one that was passed in the redir argument if redirection was successful.

'--------------------------------------------------------------------
property ser.div9600
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= "platform dependent". </b><br><br>
'Returns the value to which the <font color="maroon"><b>ser.baudrate </b></font>property must be set in order to achieve the baudrate of 
'9600bps under present operating conditions. <br><br>
'This property will return a different value depending on the PLL mode of the device (see<font color="maroon"><b>sys.currentpll</b></font>).<br><br>
'"Smart" applications will use this property to set baudrates independently of present operating conditions.
	get = syscall(126) as word
end property

'--------------------------------------------------------------------
property ser.sinkdata
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- NO (normal data processing). </b><br><br>
'For the currently selected serial port (selection is made through <font color="maroon"><b>ser.num</b></font>)
'specifies whether the incoming data should be discarded.
'<br><br>
'Setting this property to
'<font color="olive"><b>1- YES </b></font>
'causes the port to automatically discard all incoming data without passing it to your application.
'<br><br>
'The <font color="teal"><b>on_ser_data_arrival </b></font>
'event will not be generated, reading
'<font color="maroon"><b>ser.rxlen </b></font>
'will always return zero, and so on. No data will be reaching its destination even in case of buffer redirection
'(see <font color="maroon"><b>ser.redir</b></font>).
'<br><br>
'Escape characters
'(see <font color="maroon"><b>ser.esctype </b></font>and <font color="maroon"><b>ser.escchar</b></font>)
'will still be detected in the incoming data stream.
	get = syscall(11,"80.TDL"+) as no_yes
	set= syscall(12,"80.TDL"+) (value as no_yes)
end property

'**************************************************************************************************
'		SOCK (Socket) object
'**************************************************************************************************

object sock
'This is the sockets object that encompasses ALL available sockets. Total number of sockets is typically 16 but can be
'less due to memory limitations of a particular platform. The number of available sockets can be obtained through
'the <font color="maroon"><b>sock.numofsock </b></font> read-only property. <br><br>
'Selection of a particular socket to work with is done through the <font color="maroon"><b>sock.num </b></font>property. Most other 
'properties and methods refer to the currently selected socket. <br><br>
'When the handler for one of the socket events is entered the <font color="maroon"><b>sock.num  </b></font>is automatically switched 
'to the socket for which this event was generated.   

'--------------------------------------------------------------------
property sock.numofsock
'<b>R/O PROPERTY (BYTE). </b><br><br> Returns total number of sockets available on the current platform. See also <font color="maroon"><b>
'sock.num </b></font>property.
	get = syscall(248) as byte
end property

'--------------------------------------------------------------------
property sock.num
'<b>PROPERTY (BYTE), DEFAULT VALUE= 0 (socket #0 selected). </b><br><br>
'Sets/returns the number of the currently selected socket (sockets are enumerated from 0).<br><br>
'Most other properties and methods of this object relate to the socket selected through this property. Note that socket-related events such 
'as <font color="teal"><b>on_sock_data_arrival </b></font> change currently selected socket!<br><br>
'The value of this property won't exceed <font color="maroon"><b>sock.numofsock</b></font>-1 (even if you attempt to set higher value).
	get = syscall(203) as byte
	set = syscall(204) (sock as byte)
end property

'--------------------------------------------------------------------
property sock.state
'<b>R/O PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0-PL_SST_CLOSED (connection is closed). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns "detailed" current socket state
'(as opposed to <font color="teal"><b>on_sock_event </b></font>that retuns detailed state at the moment of a particular <font color="teal">
'<b>on_sock_event </b></font>event generation).See <font color="olive"><b>pl_sock_state </b></font>constants for state descriptions.<br><br>
'Another read-only property- <font color="maroon"><b>sock.statesimple</b></font>- returns "simplified" socket state.
  
	get = syscall(224) as pl_sock_state
end property

'--------------------------------------------------------------------
property sock.statesimple
'<b>R/O PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0-PL_SST_SIMPLE_CLOSED (connection is closed). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns "simplified" current socket state
'(as opposed to <font color="teal"><b>on_sock_event </b></font> that retuns simplified state at the moment of a particular <font color="teal">
'<b>on_sock_event </b></font> event generation). See <font color="olive"><b>pl_sock_state_simple </b></font>constants for state
'descriptions.<br><br>
'Another read-only property- <font color="maroon"><b>sock.state</b></font>- returns "detailed" socket state.
	get = syscall(185) as pl_sock_state_simple
end property

'--------------------------------------------------------------------
enum pl_sock_inconmode
'<b>ENUM. </b><br><br> 
'Contains the list of constants related to whether the socket accepts any incoming connections and, if yes, from which sources.
	PL_SOCK_INCONMODE_NONE,			'<b>PLATFORM CONSTANT. </b><br><br> The socket does not accept any incoming connections.
	PL_SOCK_INCONMODE_SPECIFIC_IPPORT,	'<b>PLATFORM CONSTANT. </b><br><br> 
										'The socket will only accept an incoming connection from specific IP (matching <font color="maroon">
										'<b>sock.targetip</b></font>) and specific port (matching <font color="maroon"><b>
										'sock.targetport</b></font>)
	PL_SOCK_INCONMODE_SPECIFIC_IP_ANY_PORT,	'<b>PLATFORM CONSTANT. </b><br><br> 
											'The socket will only accept an incoming connection from specific IP (matching <font color="maroon">
											'<b>sock.targetip</b></font>), but any port.
	PL_SOCK_INCONMODE_ANY_IP_ANY_PORT	'<b>PLATFORM CONSTANT. </b><br><br> 
										'The socket will accept an incoming connection from any IP and any port.
end enum

property sock.inconmode
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- PL_SOCK_INCONMODE_NONE (does not accept any incoming connections). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies whether incoming connections
'(passive opens) will be accepted and, if yes, from which sources: <br><br>
'<font color="olive"><b>0- PL_SOCK_INCONMODE_NONE </b></font>(incoming connections are not accepted at all),<br><br>
'<font color="olive"><b>1- PL_SOCK_INCONMODE_SPECIFIC_IPPORT </b></font>(incoming connections accepted only from specific IP (matching 
'<font color="maroon"><b>sock.targetip</b></font>) and specific port (matching <font color="maroon"><b>sock.targetport</b></font>)), <br><br>
'<font color="olive"><b>2- PL_SOCK_INCONMODE_SPECIFIC_IP_ANY_PORT </b></font>(incoming connections accepted only from specific IP (matching 
'<font color="maroon"><b>sock.targetip</b></font>), but any port),<br><br>
'<font color="olive"><b>3- PL_SOCK_INCONMODE_ANY_IP_ANY_PORT </b></font>(incoming connections accepted from any IP and any port). 
	get = syscall(192,"36.TDL"+) as pl_sock_inconmode
	set = syscall(193,"36.TDL"+) (inconmode as pl_sock_inconmode)
end property

'--------------------------------------------------------------------
enum pl_sock_reconmode
'<b>ENUM. </b><br><br> 
'Contains the list of constants that specify whether the socket accepts reconnects, and, if yes, from which sources. Reconnect situation is 
'when a passive open and resulting connection replace, for the same socket, the connection that was already in progress. <br><br>
'For UDP, these constants additionally define whether a "port switchover" will occur as a result of an incoming connection (passive open)
'or a reconnect.<br><br>
'Port switchover is when the socket starts sending its outgoing UDP datagrams to the port from which the most recent UDP datagram was received,
'rather than the port specified by the <font color="maroon"><b>sock.targetport </b></font> property.
	PL_SOCK_RECONMODE_0,		'<b>PLATFORM CONSTANT. </b><br><br> 
								'For UDP: Reconnects accepted only from the same IP as the one already engaged in the current connection 
								'with this socket, but any port; port switchover will not happen. <br><br>
								'TCP: reconnects are not accepted at all.
	PL_SOCK_RECONMODE_1,		'<b>PLATFORM CONSTANT. </b><br><br> 
								'For UDP: Reconnects accepted from any IP, any port; port switchover will not happen. <br><br>
								'TCP: reconnects accepted only from the same IP and port as the ones already engaged in the current connection 
								'with this socket.
	PL_SOCK_RECONMODE_2,		'<b>PLATFORM CONSTANT. </b><br><br> 
								'For UDP: Reconnects accepted only from the same IP as the one already engaged in the current connection with 
								'this socket, but any port; port switchover will happen. <br><br>
								'TCP: reconnects accepted only from the same IP as the one already engaged in the current connection with this
								'socket, but any port.
	PL_SOCK_RECONMODE_3			'<b>PLATFORM CONSTANT. </b><br><br> 
								'For UDP: Reconnects accepted from any IP, any port; port switchover will happen. ,<br><br>
								'TCP: reconnects accepted from any IP, any port.
end enum

property sock.reconmode
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- PL_SOCK_RECONMODE_0. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) whether the socket accepts reconnects, 
'and, if yes, from which sources. Reconnect situation is when a passive open and resulting connection replace, for the same socket, the 
'connection that was already in progress. <br><br>
'For UDP, this property additionally defines whether a "port switchover" will occur as a result of an incoming connection (passive open) or a
'reconnect. Port switchover is when the socket starts sending its outgoing UDP datagrams to the port from which the most recent UDP datagram
'was received, rather than the port specified by the <font color="maroon"><b>sock.targetport</b></font> property. <br><br>
'See <font color="olive"><b>PL_SOCK_RECONMODE_ </b></font>constants for available choices.
	get = syscall(246,"36.TDL"+) as pl_sock_reconmode
	set = syscall(247,"36.TDL"+) (reconmode as pl_sock_reconmode)
end property

'--------------------------------------------------------------------
property sock.localportlist
'<b>PROPERTY (STRING), DEFAULT VALUE= "" (empty string). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) sets/returns the list of listening ports
'on any of which this socket will accept an incoming UDP or TCP connection (as defined by the <font color="maroon"><b>sock.protocol </b></font>
'property and provided that incoming connections are allowed by the <font color="maroon"><b>sock.inconmode </b></font> property).
'Additionally, the
'<font color="maroon"><b>sock.allowedinterfaces </b></font>
'property defines network interfaces on which the socket will accept an incoming connection.
'<br><br>
'This property is of string type and the list of ports is a comma-separated string, i.e. "1001,3000". Max string length for this property is 
'32 bytes. <br><br>
'Notice, that there is also a <font color="maroon"><b>sock.httpportlist </b></font> property that defines a list of listening ports for HTTP 
'TCP connections.
	get = syscall(210,"36.TDL"+) as string
	set = syscall(211,"36.TDL"+) (byref lplist as string)
end property

'--------------------------------------------------------------------
property sock.httpportlist
'<b>PROPERTY (STRING), DEFAULT VALUE= "" (empty string). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) sets/returns the list of listening ports
'on any of which this socket will accept an incoming HTTP connection. (provided that the <font color="maroon"><b>sock.protocol</b></font>= 
'<font color="olive"><b>1- PL_SOCK_PROTOCOL_TCP</b></font> and that incoming connections are allowed by <font color="maroon"><b>
'sock.inconmode</b></font> property). <br><br>
'This property is of string type and the list of ports is a comma-separated string, i.e. "80, 81". Max string length for this property is 32 
'bytes. Notice, that there is also a <font color="maroon"><b>sock.localportlist</b></font> property that defines a list of listening ports for
'UDP and non-HTTP TCP connections. <br><br>
'When a particular port is listed both under the <font color="maroon"><b>sock.localportlist</b></font> and the <font color="maroon"><b>
'sock.httpportlist</b></font>, the protocol for this socket is TCP then <font color="maroon"><b>sock.httpportlist</b></font> has precedence
'(incoming TCP connection on the port in question will be interpreted as HTTP). <br><br>
'See also <font color="maroon"><b>sock.localport </b></font> and <font color="maroon"><b>sock.httpmode </b></font> properties. 
	get = syscall(48,"36.TDL"+) as string
	set = syscall(49,"36.TDL"+) (byref hplist as string)
end property

'--------------------------------------------------------------------
property sock.localport
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns current local port of the socket.
'<br><br>Your application cannot set the local port directly. Instead, a list of ports on which the socket is allowed to accept an incoming 
'connection (passive open) is supplied via the <font color="maroon"><b>sock.localportlist </b></font> and <font color="maroon"><b>
'sock.httpportlist </b></font> properties.<br><br>
'An incoming connection is accepted on any port from those two lists. The <font color="maroon"><b>sock.localport </b></font> property reflects 
'current or the most recent local port on which connection was accepted.
	get = syscall(209) as word
end property

'--------------------------------------------------------------------
property sock.outport
'<b>PROPERTY (WORD), DEFAULT VALUE= 0 (automatic). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) sets/returns the number of the port that
'will be used by the socket to establish outgoing connections. <br><br>
'If this property is set to 0 then the socket will use "automatic" port numbers: for the first connection since the powerup the port number will
'be selected randomly, for all subsequent outgoing connections the port number will increase by one. <br><br>
'Actual local port of a connection can be queried through the <font color="maroon"><b>sock.localport </b></font> read-only property. If this 
'property is not at zero then the port it specifies will be used for all outgoing connections from this socket.
	get = syscall(190,"81.TDL"+) as word
	set = syscall(191,"81.TDL"+) (outport as word)
end property

'--------------------------------------------------------------------
property sock.acceptbcast
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0-NO. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies whether the socket will accept
'incoming broadcast UDP datagrams: <br><br>
'<font color="olive"><b>0- NO </b></font>(won't accept broadcast UDP datagrams),<br><br> <font color="olive"><b>1- YES </b></font> (will accept
'broadcast UDP datagrams).<br><br>
'This property is irrelevant for TCP communications (<font color="maroon"><b>sock.protocol</b></font>=<font color="olive"><b>
'PL_SOCK_PROTOCOL_TCP</b></font>).
	get = syscall(205,"81.TDL"+) as no_yes
	set = syscall(206,"81.TDL"+) (acceptbcast as no_yes)
end property

'--------------------------------------------------------------------
property sock.targetip
'<b>PROPERTY (STRING), DEFAULT VALUE= "0.0.0.0". </b><br><br>
'For active opens on the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies the target IP
'to which the socket will attempt to connect to. <br><br>
'For passive opens, whether this property will matter or not is defined by the <font color="maroon"><b>sock.inconmode</b></font> property. 
'When the <font color="maroon"><b>sock.inconmode</b></font>= <font color="olive"><b>1- PL_SOCK_INCONMODE_SPECIFIC_IPPORT </b></font> or
'<font color="olive"><b>2- PL_SOCK_INCONMODE_SPECIFIC_IP_ANY_PORT </b></font> only the host with IP matching the one set in the 
'<font color="maroon"><b>sock.targetip</b></font> property will be able to connect to the socket.<br><br>
'current IP on the "other side" of the connection can always be checked through the <font color="maroon"><b>sock.remoteip </b></font> read-only
'property.<br><br> 
'See also <font color="maroon"><b>sock.targetport</b></font> and <font color="maroon"><b>sock.remoteport</b></font>.
	get = syscall(212,"39.TDL"+) as string
	set = syscall(213,"40.TDL"+) (byref targetip as string)
end property

'--------------------------------------------------------------------
property sock.targetmac
'<b>PROPERTY (STRING), DEFAULT VALUE= "0.0.0.0.0.0". </b><br><br>
	get = syscall(482,"39.TDL"+) as string
	set = syscall(483,"40.TDL"+) (byref targetip as string)
end property

'--------------------------------------------------------------------
property sock.targetport
'<b>PROPERTY (WORD), DEFAULT VALUE= 0. </b><br><br>
'For active opens on the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies the target port
'to which the socket will attempt to connect to. <br><br>
'For passive opens, whether this property will matter or not is defined by the <font color="maroon"><b>sock.inconmode</b></font> property. 
'When the <font color="maroon"><b>sock.inconmode</b></font>= <font color="olive"><b>1- PL_SOCK_INCONMODE_SPECIFIC_IPPORT </b></font> an incoming
'connection will only be accepted from the port matching the one set in the <font color="maroon"><b>sock.targetport</b></font> property.<br><br>
'Current port on the "other side" of the connection can always be checked through the <font color="maroon"><b>sock.remoteport</b></font>
'read-only property.<br><br>
'See also <font color="maroon"><b>sock.targetip</b></font> and <font color="maroon"><b>sock.remoteip</b></font>.
	get = syscall(214,"81.TDL"+) as word
	set = syscall(215,"81.TDL"+) (targetport as word)
end property

'--------------------------------------------------------------------
property sock.targetbcast
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- NO. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies whether this port will be
'sending its outgoing UDP datagrams as link-level broadcasts: <br><br>
'<font color="olive"><b>0- NO </b></font> (will send as "normal" packets),<br><br> <font color="olive"><b>1- YES </b></font>(will send as 
'broadcast packets).<br><br>
'This property is only relevant for UDP communications (<font color="maroon"><b>sock.protocol</b></font>=<font color="olive"><b>
'PL_SOCK_PROTOCOL_UDP</b></font>). When this property is set to <font color="olive"><b>1- YES </b></font>the socket will be sending out all UDP 
'datagrams as broadcasts and incoming datagrams won't cause port switchover, even if the latter is enabled through the 
'<font color="maroon"><b>sock.reconmode </b></font> property.
	get = syscall(216,"81.TDL"+) as no_yes
	set = syscall(217,"81.TDL"+) (targetbcast as no_yes)
end property

'--------------------------------------------------------------------
property sock.remotemac
'<b>R/O PROPERTY (STRING), DEFAULT VALUE= "0.0.0.0.0.0". </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the MAC address of the host with
'which this socket had the most recent or currently has a connection. <br><br>
'For UDP connections, when the <font color="teal"><b>on_sock_data_arrival </b></font>event handler is entered, the <font color="maroon"><b>
'sock.remotemac </b></font>will contain the MAC address of the sender of the current UDP datagram being processed.<br><br>
'Outside of the <font color="teal"><b>on_sock_data_arrival </b></font>event handler, the property will return the source MAC address of the most
'recent datagram received by the socket. <br><br>
'Also see <font color="maroon"><b>sock.remoteip</b></font>, <font color="maroon"><b>sock.remoteport</b></font>, and <font color="maroon"><b>
'sock.bcast </b></font> properties.
	get = syscall(220,"39.TDL"+) as string
end property

'--------------------------------------------------------------------
property sock.remoteip
'<b>R/O PROPERTY (STRING), DEFAULT VALUE= "0.0.0.0". </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the IP address of the host with 
'which this socket had the most recent or currently has a connection. The application cannot directly change this property, it can only specify
'the target IP address for active opens through the <font color="maroon"><b>sock.targetip </b></font> property.<br><br>
'For UDP connections, when the <font color="teal"><b>on_sock_data_arrival </b></font>event handler is entered, the <font color="maroon"><b>
'sock.remoteip </b></font> will contain the IP address of the sender of the current datagram being processed. <br><br>
'Outside of the <font color="teal"><b>on_sock_data_arrival </b></font>event handler, the property will return the source IP address of the most
'recent datagram received by the socket.<br><br>
'Also see <font color="maroon"><b>sock.remotemac</b></font>, <font color="maroon"><b>sock.remoteport</b></font>, and <font color="maroon"><b>
'sock.bcast </b></font> properties. 
	get = syscall(221,"39.TDL"+) as string
end property

'--------------------------------------------------------------------
property sock.remoteport
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the port number of the host with
'which this socket had the most recent or currently has a connection. The application cannot directly change this property, it can only specify
'the target port for active opens through the <font color="maroon"><b>sock.targetport </b></font> property. <br><br>
'For UDP connections, when the <font color="teal"><b>on_sock_data_arrival </b></font>event handler is entered, the <font color="maroon"><b>
'sock.remoteport</b></font> will contain the port number of the sender of the current datagram being processed. <br><br>
'Outside of the <font color="teal"><b>on_sock_data_arrival </b></font>event handler, the property will return the source port of the most recent
'datagram received by the socket.<br><br>
'Also see <font color="maroon"><b>sock.remotemac</b></font>, <font color="maroon"><b>sock.remoteip</b></font>, and <font color="maroon"><b>
'sock.bcast </b></font> properties.
	get = syscall(222) as word
end property

'--------------------------------------------------------------------
property sock.bcast
'<b>R/O PROPERTY (ENUM BYTE), DEFAULT VALUE= 0- NO. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) reports whether the current or most
'recently received UDP datagram was a broadcast one. <br><br>
'When the <font color="teal"><b>on_sock_data_arrival </b></font>event handler is entered, the <font color="maroon"><b>sock.bcast </b></font> 
'will contain the broadcast status for the current datagram being processed.  <br><br>
'Outside of the <font color="teal"><b>on_sock_data_arrival </b></font>event handler, the property will return the broadcast status of the most
'recent datagram received by the socket.
	get = syscall(223) as no_yes
end property

'--------------------------------------------------------------------
enum pl_sock_protocol
'<b>ENUM. </b><br><br> 
'Contains the list of constants that specify the transport protocol for the socket. HTTP is not listed here because it is not a transport
'protocol (transport protocol used for HTTP is TCP).
	PL_SOCK_PROTOCOL_UDP,		'<b>PLATFORM CONSTANT. </b><br><br> Specifies UDP transport protocol for the socket.
	PL_SOCK_PROTOCOL_TCP,		'<b>PLATFORM CONSTANT. </b><br><br> Specifies TCP transport protocol for the socket.
	PL_SOCK_PROTOCOL_RAW		'<b>PLATFORM CONSTANT. </b><br><br> Specifies RAW packet mode for the socket.
end enum

property sock.protocol
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- PL_SOCK_PROTOCOL_UDP (UDP transport protocol for the socket). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num </b></font>) selects the transport protocol:<br><br>
'<font color="olive"><b>0- PL_SOCK_PROTOCOL_UDP </b></font> (UDP transport protocol), <br><br>
'<font color="olive"><b>1- PL_SOCK_PROTOCOL_TCP</b></font> (TCP transport protocol).<br><br>
'Notice, that there is no "HTTP" selection, as HTTP is not a transport protocol (TCP is the transport protocol required by the HTTP). 
'You make the socket accept HTTP connections by specifying the list of HTTP listening ports using the <font color="maroon"><b>sock.httpportlist
'</b></font> property or using the <font color="maroon"><b>sock.httpmode </b></font> property. <br><br>
'The program won't be able to change the value of this property when the socket is not idle (<font color="maroon"><b>sock.statesimple
'</b></font><> <font color="olive"><b>0- PL_SSTS_CLOSED</b></font>).
	get = syscall(207,"36.TDL"+) as pl_sock_protocol
	set = syscall(208,"36.TDL"+) (proto as pl_sock_protocol)
end property

'--------------------------------------------------------------------
property sock.splittcppackets
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- NO. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) selects how TCP data should be processed:
' <font color="olive"><b>0- NO </b></font>(normal processing), <font color="olive"><b>1- YES </b></font>(additional degree of control over
'individual TCP packets). When this property is set to <font color="olive"><b>1- YES </b></font>your program gets an additional degree of 
'control over TCP. <br><br>
'For incoming  TCP data, the program can know the size of individual incoming packets (this will be reported by the <font color="teal"><b>
'on_sock_tcp_packet_arrival </b></font>event).<br><br>
'For outgoing TCP data, no packet will be sent out at all unless entire contents of the TX buffer can be sent. Therefore, by executing 
'<font color="maroon"><b>sock.send </b></font> and waiting for <font color="maroon"><b>sock.txlen</b></font>=0 your program can make sure that 
'the packet sent will have exactly the size you needed. <br><br>
'The property is only relevant when <font color="maroon"><b>sock.inbandcommands</b></font>= <font color="olive"><b>0- NO</b></font>. With 
'inband commands enabled, the socket will always behave as if the <font color="maroon"><b>sock.splittcppackets</b></font>= <font color="olive">
'<b>0- NO</b></font>. <br><br>
'The program won't be able to change the value of this property when the socket is not idle (<font color="maroon"><b>sock.statesimple</b></font>
'<> <font color="olive"><b>0- PL_SSTS_CLOSED</b></font>). <br>
	get = syscall(65,"36.TDL"+) as no_yes
	set = syscall(251,"36.TDL"+) (splitpackets as no_yes)
end property

'--------------------------------------------------------------------
property sock.httpmode
'<b>PROPERTY (ENUM BYTE), DEFAULT VALUE= 0- NO (not in HTTP mode). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies whether this socket is in the
'HTTP mode: <font color="olive"><b>0- NO</b></font> ("regular" TCP connection), <font color="olive"><b>1- YES </b></font>(TCP HTTP connection). 
'<br><br>This property is irrelavant when the <font color="maroon"><b>sock.protocol</b></font>= <font color="olive"><b>PL_SOCK_PROTOCOL_UDP
'</b></font>(UDP). If you do not set this property directly, it's value will be: <font color="olive"><b>0- NO</b></font> for all outgoing
'connections (active opens) of the socket, <font color="olive"><b>0- NO </b></font>for incoming connections received on one of the ports from 
'the <font color="maroon"><b>sock.localportlist</b></font> list, <font color="olive"><b>1- YES </b></font>for incoming connections received 
'on one of the ports from the <font color="maroon"><b>sock.httpportlist</b></font>.<br><br>
'You can manually switch any TCP connection at any time after it has been established from "regular" to HTTP by setting <font color="maroon"><b>
'sock.httpmode</b></font>=1. However, this operation is "sticky"- once you have converted the TCP connection into the HTTP mode you cannot 
'convert it back into the regular mode- trying to set <font color="maroon"><b>sock.httpmode</b></font>=0 won't have any effect- the TCP 
'connection will remain in the HTTP mode until this connection is closed. 
	get = syscall(46,"69.TDL"+) as no_yes
	set = syscall(47,"69.TDL"+) (httpmode as no_yes)
end property

'--------------------------------------------------------------------
property sock.httpnoclose
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- NO (will be closed). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) sets/returns whether TCP HTTP connection
'will be kept opened after the HTTP request has been processed and the HTML page has been sent out: <font color="olive"><b>0- NO</b></font> 
'(will be closed, standard behavior), <font color="olive"><b>1- YES </b></font>(will be kept open). <br><br>
'In the second case the end of HTML page output is marked by CR/LF/CR/LF sequence.
	get = syscall(44,"36.TDL"+) as no_yes
	set = syscall(45,"36.TDL"+) (value as no_yes)
end property

'--------------------------------------------------------------------
property sock.connectiontout
'<b>PROPERTY (WORD), DEFAULT VALUE= 0 (no timeout). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) sets/returns connection timeout threshold
'for the socket in half-second increments. <br><br>
'When no data is exchanged across the connection for sock.connectiontout/2 number of seconds this connection is aborted (reset for TCP and 
'discarded for UDP). Connection timeout of 0 means "no timeout".
'<br><br>
'Actual time elapsed since the last data exchange across the socket can be obtained through the
'<font color="maroon"><b>sock.toutcounter </b></font>R/O property.
	get = syscall(218,"36.TDL"+) as word
	set = syscall (219,"36.TDL"+) (connectiontout as word)
end property

'--------------------------------------------------------------------
property sock.toutcounter
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0 </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the time, in 0.5 second intervals,
'elapsed since the data was last send or received on this socket.
'<br><br>
'This property is reset to 0 each time there is some data exchanged across the socket connection.
'The property increments at 0.5 second intervals while no data is moving through this socket.
'<br><br>
'If the <font color="maroon"><b>sock.connectiontout </b></font>
'is not at 0, this property increments until it reaches the value of the
'<font color="maroon"><b>sock.connectiontout </b></font>
'and the connection is terminated.
'The <font color="maroon"><b>sock.toutcounter </b></font>
'then stays at this value.
'<br><br>
'If the <font color="maroon"><b>sock.connectiontout </b></font>
'is at 0, the maximum value that the
'<font color="maroon"><b>sock.toutcounter </b></font>
'can reach is 1. That is, the
'<font color="maroon"><b>sock.toutcounter </b></font>
'will be at 0 after the data exchange, and at 1 if at least 0.5 seconds have passed since the last data exchange.
	get = syscall(2) as word
end property

'--------------------------------------------------------------------
property sock.inbandcommands
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- NO (inband commands disabled). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies whether inband command passing
'is allowed: <font color="olive"><b>0- NO</b></font> (inband commands are not allowed), <font color="olive"><b>1- YES </b></font>(inband 
'commands are allowed). <br><br>
'Inband commands are messages passedwithin the TCP data stream. Each message has to be formatted in a specific way- see the <font color="maroon">
'<b>sock.escchar </b></font> and <font color="maroon"><b>sock.endchar </b></font> properties. <br><br>
'Inband commands are not possible for UDP communications so this setting is irrelevant when <font color="maroon"><b>sock.protocol</b></font>=
'<font color="olive"><b>1- PL_SOCK_PROTOCOL_UDP</b></font>. <br><br>
'Inband messaging will work even when redirection (buffer shorting) is enabled for the socket (see the <font color="maroon"><b>sock.redir 
'</b></font>method). The program won't be able to change the value of this property when the socket is not idle (<font color="maroon"><b>
'sock.statesimple</b></font><> <font color="olive"><b>0- PL_SSTS_CLOSED</b></font>).
	get = syscall(38,"36.TDL"+) as no_yes
	set = syscall(39,"36.TDL"+) (inbandcommands as no_yes)
end property

'--------------------------------------------------------------------
property sock.escchar
'<b>PROPERTY (BYTE), DEFAULT VALUE= 255. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies the ASCII code of the 
'character that will be used as an escape character for inband commands (messages). Each inband message starts with "EC OC", where "EC" is the 
'escape character defined by the <font color="maroon"><b>sock.escchar </b></font> property and "OC" is any character other than "EC".<br><br>
'With inband commands enabled, data characters with code matching that of the escape character is transmitted as "EC EC". This property is
'irrelevant when inband commands are disabled (<font color="maroon"><b>sock.inbandcommands</b></font>= <font color="olive"><b>0- NO</b></font>). '<br><br>The program won't be able to change the value of this property when the socket is not idle (<font color="maroon"><b>
'sock.statesimple</b></font><> <font color="olive"><b>0- PL_SSTS_CLOSED</b></font>).<br><br>
'See also <font color="maroon"><b>sock.endchar</b></font>.
	get = syscall(40,"36.TDL"+) as byte
	set = syscall(41,"36.TDL"+) (escchar as byte)
end property

'--------------------------------------------------------------------
property sock.endchar
'<b>PROPERTY (BYTE), DEFAULT VALUE= 13 (CR). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies the ASCII code of the 
'character that will end inband command (message). Each inband message has to end with this character, which will mark a return to the "regular"
'data stream of the TCP connection. <br><br>
'This property is irrelevant when inband commands are disabled (<font color="maroon"><b>sock.inbandcommands</b></font>= <font color="olive"><b>
'0- NO</b></font>). The program won't be able to change the value of this property when the socket is not idle (<font color="maroon"><b>
'sock.statesimple</b></font><> <font color="olive"><b>0- PL_SSTS_CLOSED</b></font>). <br><br>
'See also <font color="maroon"><b>sock.escchar</b></font>.
	get = syscall(42,"36.TDL"+) as byte
	set = syscall(43,"36.TDL"+) (escchar as byte)
end property

'--------------------------------------------------------------------
property sock.gendataarrivalevent
'<b>PROPERTY (BYTE), DEFAULT VALUE= 1- YES (on_sock_data_arrival event will be generated). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies whether the <font color="teal">
'<b>on_sock_data_arrival </b></font>event will be generated once there is some data in the RX buffer: <br><br>
'<font color="olive"><b>0- NO </b></font>(<font color="teal"><b>on_sock_data_arrival </b></font>event won't be generated),<br><br>
'<font color="olive"><b>1- YES </b></font>(<font color="teal"><b>on_sock_data_arrival </b></font>event will be generated).<br><br>
'Turning <font color="teal"><b>on_sock_data_arrival </b></font>event generation off may be handy when you are processing UDP datagrams 
'(<font color="maroon"><b>sock.protocol</b></font>= <font color="olive"><b>0- PL_SOCK_PROTOCOL_UDP</b></font>) in a loop while
'using the doevents. If this is the case the <font color="teal"><b>on_sock_data_arrival </b></font>event handler executed "inside" the doevents
'would "steal" datagrams from you (the datagram is deleted from the RX buffer once the <font color="teal"><b>on_sock_data_arrival
'</b></font>event handler is exited).
	get = syscall(244,"81.TDL"+) as no_yes
	set = syscall(245,"81.TDL"+) (escchar as no_yes)
end property

'--------------------------------------------------------------------
property sock.rxbuffsize
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns current RX buffer capacity in
'bytes.<br><br>
'Buffer capacity can be changed through the <font color="maroon"><b>sock.rxbuffrq</b></font>. The <font color="maroon"><b>sock.rxbuffrq
'</b></font> requests buffer size in 256-byte pages whereas this property returns buffer size in bytes.<br><br>
'Relationship between the two is as follows: <font color="maroon"><b>sock.rxbuffsize</b></font>=num_pages*256-16 (or =0 when num_pages=0), 
'where "num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>sock.rxbuffrq</b></font>. "-16" is 
'because 16 bytes are needed for internal buffer variables. <br><br>
'The socket cannot RX data when the RX buffer has zero capacity.
	get = syscall(230,"36.TDL"+) as word
end property

'--------------------------------------------------------------------
property sock.txbuffsize
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns current TX buffer capacity in
'bytes. Buffer capacity can be changed through the <font color="maroon"><b>sock.txbuffrq </b></font> method followed by the 
'<font color="maroon"><b>sys.buffalloc </b></font> method.<br><br>
'The <font color="maroon"><b>sock.txbuffrq </b></font> requests buffer size in 256-byte pages whereas this property returns buffer size in bytes.
'Relationship between the two is as follows: <font color="maroon"><b>sock.txbuffsize</b></font>=num_pages*256-16 (or =0 when num_pages=0), where
'"num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>sock.txbuffrq</b></font>. "-16" is because 16
'bytes are needed for internal buffer variables.<br><br>
'The socket cannot TX data when the TX buffer has zero capacity.
	get = syscall(231,"36.TDL"+) as word
end property

'--------------------------------------------------------------------
property sock.rxlen
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns total number of bytes currently waiting
'in the RX buffer to be extracted and processed by your application. <br><br>
'The <font color="teal"><b>on_sock_data_arrival </b></font>event is generated once the RX buffer is not empty, i.e. there is data to process. 
'There may be only one <font color="teal"><b>on_sock_data_arrival </b></font>event for each socket waiting to be processed in the event queue.
'<br><br>Another <font color="teal"><b>on_sock_data_arrival </b></font>event for the same socket may be generated only after the previous one 
'is handled. If, during the <font color="teal"><b>on_sock_data_arrival </b></font>event handler execution, not all data is extracted from the 
'RX buffer, another <font color="teal"><b>on_sock_data_arrival </b></font>event is generated immediately after the <font color="teal"><b>
'on_sock_data_arrival </b></font>event handler is exited.
	get = syscall(232,"36.TDL"+) as word
end property

'--------------------------------------------------------------------
property sock.txlen
'<b>R/O PROPERTY (WORD), DEFAULT VALUE=0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns total number of committed bytes 
'currently found in the TX buffer. The data in the TX buffer does not become committed until you use the <font color="maroon"><b>sock.send 
'</b></font>method. <br><br>
'Your application may use the <font color="maroon"><b>sock.notifysent </b></font>method to get <font color="teal"><b>on_sock_data_sent
'</b></font>event once the total number of committed bytes in the TX buffer drops below the level defined by the <font color="maroon"><b>
'sock.notifysent</b></font> method. <br><br>
'See also <font color="maroon"><b>sock.newtxlen</b></font>.
	get = syscall(233,"36.TDL"+) as word
end property

'--------------------------------------------------------------------
property sock.txfree
'<b>R/O PROPERTY (WORD), DEFAULT VALUE=0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the amount of free space in the TX 
'buffer in bytes, not taking into account uncommitted data. Actual free space is <font color="maroon"><b>sock.txfree</b></font>-
'<font color="maroon"><b>sock.newtxlen</b></font>. <br><br>
'Your application will not be able to store more data than this amount. To achieve asynchronous data processing, use the <font color="maroon">
'<b>sock.notifysent</b></font> method to get <font color="teal"><b>on_sock_data_sent</b></font> event once the TX buffer gains required 
'amount of free space.
	get = syscall(235,"36.TDL"+) as word
end property

'--------------------------------------------------------------------
property sock.newtxlen
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the amount of uncommitted TX data in 
'bytes. Uncommitted data is the one that was added to the TX buffer with the <font color="maroon"><b>sock.setdata </b></font> method but not 
'yet committed using the <font color="maroon"><b>sock.send </b></font>method.
	get = syscall(242) as word
end property

'--------------------------------------------------------------------
property sock.httprqstring
'<b>R/O PROPERTY (STRING), DEFAULT VALUE= "". </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns up to 255 bytes of the HTTP
'request string stored in the VAR buffer.
'<br><br>
'The <font color="maroon"><b>sock.httprqstring </b></font>
'is a property; it can be invoked several times and will return the same data (when the property is used the data is not deleted from the VAR buffer).
'<br><br>
'This property is only relevant when the socket is in the HTTP mode
'(<font color="maroon"><b>sock.httpmode</b></font>=
'<font color="olive"><b>1- YES</b></font>).
'Use it from within an HTML page or
'<font color="teal"><b>on_sock_postdata </b></font>
'event handler.
'Maximum length of data that can be obtained through this property is 255 bytes,
'since this is the maximum possible capacity of a string variable that will accept the value of this property.
'<br><br>
'Rely on the
'<font color="teal"><b>on_sock_postdata </b></font>
'event and the
'<font color="maroon"><b>sock.gethttprqstring </b></font>
'method to handle large amounts of HTTP variable data correctly.
	get = syscall(188,"36.TDL"+) as string
end property

'--------------------------------------------------------------------
syscall(556,"36.TDL") sock.gethttprqstring(maxinplen as word) as string
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) extracts up to 255 bytes of the HTTP
'request string from the VAR buffer.
'<br><br>
'Extracted data is permanently deleted from the VAR buffer.
'Length of extracted data is limited by one of the three factors (whichever is smaller):
'amount of data in the buffer itself, capacity of the "receiving" string variable, and the limit set by the maxinplen argument.
'<br><br>
'This method is only relevant when the socket is in the HTTP mode
'(<font color="maroon"><b>sock.httpmode</b></font>=
'<font color="olive"><b>1- YES</b></font>).
'Use it from within an HTML page or
'<font color="teal"><b>on_sock_postdata </b></font>
'event handler.
'<br><br>
'See also: <font color="maroon"><b>sock.httprqstring</b></font>.

'--------------------------------------------------------------------
property sock.rxpacketlen
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the length (in bytes) of the UDP 
'datagram being extracted from the RX buffer. This property is only relevant when the <font color="maroon"><b>sock.protocol</b></font>= 
'<font color="olive"><b>1-PL_SOCK_PROTOCOL_TCP</b></font>. <br><br>
'Correct way of using this property is within the <font color="teal"><b>on_sock_data_arrival </b></font>event or in conjunction with the
'<font color="maroon"><b>sock.nextpacket</b></font> method.<br><br> 
'See also <font color="maroon"><b>sock.rxlen </b></font> property.
	get = syscall(241) as word
end property

'--------------------------------------------------------------------
property sock.cmdlen
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the length of data (in bytes) waiting
'to be processed in the CMD buffer. This buffer accumulates incoming inband commands (messages) and may contain more than one such command.
'Use <font color="maroon"><b>sock.getinband </b></font> method to extract the data from the CMD buffer. <br><br>
'See also <font color="maroon"><b>sock.rpllen </b></font> and <font color="maroon"><b>sock.inbandcommands</b></font>.
	get = syscall(96,"36.TDL"+) as word
end property

'--------------------------------------------------------------------
property sock.rpllen
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the length of data (in bytes) waiting
'to be send out from the RPL buffer; this is the buffer that keeps outgoing inband replies (messages). <br><br>
'Your application adds inband replies to the RPL buffer with the <font color="maroon"><b>sock.setsendinband </b></font> method. Several 
'inband replies may be waiting in the RPL buffer.<br><br>
'See also <font color="maroon"><b>sock.cmdlen</b></font>, <font color="maroon"><b>sock.rplfree </b></font> and <font color="maroon"><b>
'sock.inbandcommands</b></font>.
	get = syscall(97,"36.TDL"+) as word
end property

'--------------------------------------------------------------------
property sock.rplfree
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the free space (in bytes) available in
'the RPL buffer; this is the buffer that stores outgoing inband replies (messages). <br><br>
'Your application adds inband replies to the RPL buffer with the <font color="maroon"><b>sock.setsendinband </b></font> method. Several inband
'replies may be waiting in the RPL buffer.<br><br>
'See also <font color="maroon"><b>sock.cmdlen</b></font>, <font color="maroon"><b>sock.rpllen </b></font> and <font color="maroon"><b>
'sock.inbandcommands</b></font>.
	get = syscall(99,"36.TDL"+) as word
end property

'--------------------------------------------------------------------
property sock.tx2len
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the amount of data waiting to be sent
'out in the TX2 buffer; this is the buffer that is needed to transmit outgoing TCP data when inband commands (messages) are enabled
'(<font color="maroon"><b>sock.inbandcommands</b></font>= <font color="olive"><b>1- YES</b></font>).<br><br>
'If your application needs to make sure that all data is actually sent out then it must verify that both TX and TX2 buffers are empty.<br><br>
'See also <font color="maroon"><b>sock.txlen</b></font> and <font color="maroon"><b>sock.txfree</b></font>.
	get = syscall(98,"36.TDL"+) as word
end property

'--------------------------------------------------------------------
syscall(236) sock.rxclear()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) clears (deletes all data from) the RX buffer.
'Invoking this method will have no effect when the socket is in the HTTP mode (<font color="maroon"><b>sock.httpmode</b></font>= 
'<font color="olive"><b>1- YES</b></font>).

'--------------------------------------------------------------------
syscall(237) sock.txclear()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) clears (deletes all data from) the TX buffer.
'Invoking this method will have no effect when the socket is not idle (<font color="maroon"><b>sock.statesimple</b></font><> 
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>).

'--------------------------------------------------------------------
syscall(238) sock.getdata(maxinplen as word) as string
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the string that contains the data
'extracted from the RX buffer. Extracted data is permanently deleted from the buffer. <br><br>
'Length of extracted data is limited by one of the three factors (whichever is smaller): amount of data in the RX buffer itself, capacity of 
'the "receiving" string variable, and the limit set by the maxinplen argument.<br><br>
'Additionally, if this socket uses UDP transport protocol (<font color="maroon"><b>sock.protocol</b></font>= <font color="olive"><b>
'1-PL_SOCK_PROTOCOL_TCP</b></font>) the length of data that will be extracted is limited to the UDP datagram being processed. <br><br>
'Additional conditions apply to UDP datagram processing; see <font color="teal"><b>on_sock_data_arrival </b></font>event and 
'<font color="maroon"><b>sock.nextpacket </b></font> method.

'--------------------------------------------------------------------
syscall(14) sock.peekdata(maxinplen as word) as string
'METHOD.
'For the selected socket (selection is made through sock.num) returns the string that contains the "preview" of the data
'from the RX buffer. The data is NOT deleted from the buffer. For TCP (sock.protocol= 1- PL_SOCK_PROTOCOL_UDP) the length of returned data is
'limited by one of the three factors (whichever is smaller): amount of data in the RX buffer itself, capacity of the
'"receiving" string variable, and the limit set by the maxinplen argument. String variables can hold up to 255 bytes of data, so this
'method will only allow you to preview up to 255 "next" bytes from the RX buffer.
'For UDP (sock.protocol= 0- PL_SOCK_PROTOCOL_UDP), additional limitations apply. The "current" UDP datagram is always deleted automatically
'when the on_sock_data_arrival event is exited. This means that you will "lose" this datagram from the buffer upon exiting the
'on_sock_data_arrival event even if your program only used sock.peekdata. Also, the amount of data returned by the sock.peekdata is
'limited to the "next" UDP datagram waiting in the RX buffer.
'See on_sock_data_arrival event and sock.nextpacket methods for additional info. See also: sock.getdata method.

'--------------------------------------------------------------------
syscall(239) sock.setdata(byref txdata as string)
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) adds the data passed in the txdata argument to
'the contents of the TX buffer. If the buffer doesn't have enough space to accommodate the data being added then this data will be truncated. 
'Newly saved data is not sent out immediately. This only happens after the <font color="maroon"><b>sock.send</b></font> method
'is used to commit the data. This allows your application to prepare large amounts of data before sending it out.<br><br>
'Total amount of newly added (uncommitted) data in the buffer can be checked through the <font color="maroon"><b>sock.newtxlen </b></font> 
'setting. <br><br>
'Also see <font color="maroon"><b>sock.txlen</b></font>, <font color="maroon"><b>sock.txfree</b></font>, <font color="maroon"><b>
'sock.notifysent</b></font>, and <font color="teal"><b>on_sock_data_sent</b></font>.

'--------------------------------------------------------------------
syscall(240) sock.send()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) commits (allows sending) the data that was
'previously saved into the TX buffer using the <font color="maroon"><b>sock.setdata </b></font> method. <br><br>
'You can monitor the sending progress by checking the <font color="maroon"><b>sock.txlen</b></font> property or using the 
'<font color="maroon"><b>sock.notifysent</b></font> method and the <font color="teal"><b>on_sock_data_sent</b></font> event. 

'--------------------------------------------------------------------
syscall(50,"36.TDL"+) sock.getinband as string
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the string that contains the data
'extracted from the CMD buffer; this is the buffer that accumulates inband commands. <br><br>
'Extracted data is permanently deleted from the CMD buffer. Length of extracted data is limited by one of the two factors (whichever is 
'smaller): amount of data in the CMD buffer itself, and the capacity of the "receiving" buffer variable. <br><br>
'Several inband commands may be waiting in the CMD buffer. Each command will always be complete, i.e. there will be no situation when you
'will extract a portion of the command because the end of this command hasn't arrived yet. <br><br>
'Inband commands stored in the CMD buffer will have escape character (see <font color="maroon"><b>sock.escchar </b></font> property) and the 
'next character after the escape character already cut off, but the end character (see <font color="maroon"><b>sock.endchar </b></font> 
'property) will still be present. Therefore, your application can separate inband command from each other by finding end characters.

'--------------------------------------------------------------------
syscall(427,"36.TDL"+) sock.peekinband as string
'METHOD.
'For the selected socket (selection is made through sock.num) returns the string that contains the "preview" of the data from
'the CMD buffer; this is the buffer that accumulates inband commands. The data is NOT deleted from the
'CMD buffer. Length of extracted data is limited by one of the two factors (whichever is smaller):
'amount of data in the CMD buffer itself, and the capacity of the "receiving" buffer variable. String variables can hold up
'to 255 bytes of data, so this method will only allow you to preview up to 255 "next" bytes from the RX buffer.
'Several inband commands may be waiting in the CMD buffer. Commands stored in the CMD buffer will have escape character
'(see sock.escchar property) and the next character after the escape character already cut off, but the end character
'(see sock.endchar property) will still be present. Therefore, your application can separate inband command from each other by
'finding end characters. Internally, the CMD buffer always stores complete commands. The sock.peekinband method only allows you
'to preview "next" 255 bytes of the buffer contents, therefore, the preview of the data may contain a partial command.
'See also: sock.getinband method. 

'--------------------------------------------------------------------
syscall(51,"36.TDL"+) sock.setsendinband(byref data as string)
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) puts the data into the RPL buffer; this is the
'buffer that stores outgoing inband replies (messages). This method also commits the newly stored data. This is different from the
'TX buffer for which two separate methods- <font color="maroon"><b>sock.setdata </b></font> and <font color="maroon"><b>sock.send</b></font>- 
'are used to store and commit the data. <br><br>
'It is the responsibility of your application to properly encapsulate outgoing messages with escape sequence ("EC OC", see the 
'<font color="maroon"><b>sock.escchar </b></font> property) and the end character (see the <font color="maroon"><b>sock.endchar </b></font>
'property). <br><br>
'When adding the data to the RPL buffer make sure you are adding entire inband message at once- you are not allowed to do this "in portions"!

'--------------------------------------------------------------------
syscall(243) sock.notifysent(threshold as word)
'<b>METHOD. </b><br><br>
'Using this method for the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) will cause the 
'<font color="teal"><b>on_sock_data_sent </b></font>event to be generated when the amount of committed data in the TX buffer is found to be 
'equal or below "threshold" number of bytes.<br><br>
'Only one <font color="teal"><b>on_sock_data_sent </b></font>event will be generated each time after the <font color="maroon"><b>
'sock.notifysent</b></font> is invoked. <br><br>
'This method, together with the <font color="teal"><b>on_sock_data_sent </b></font>event provides a way to handle data sending asynchronously.
'Just like with <font color="maroon"><b>sock.txfree</b></font>, the trigger you set won't take into account any uncommitted data in the TX 
'buffer.

'--------------------------------------------------------------------
syscall(189) sock.nextpacket()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) in the UDP mode (<font color="maroon"><b>
'sock.protocol</b></font>= <font color="olive"><b>0- PL_SOCK_PROTOCOL_UDP</b></font>) closes processing of current UDP datagram and moves to 
'the next datagram. <br><br>
'For UDP, the <font color="maroon"><b>sock.getdata </b></font>method only extracts the data from a single UDP datagram even if several 
'datagrams are stored in the RX buffer. When incoming UDP datagram processing is based on the <font color="teal"><b>on_sock_data_arrival
'</b></font>event the use of the <font color="maroon"><b>sock.nextpacket </b></font> is not required since each invocation of the 
'<font color="teal"><b>on_sock_data_arrival </b></font>event handler "moves" processing to the next UDP datagram.<br><br>
'The method is useful when it is necessary to move to the next datagram without re-entering <font color="teal"><b>on_sock_data_arrival
'</b></font>. Therefore, <font color="maroon"><b>sock.nextpacket </b></font> is only necessary when the application needs to process
'several incoming UDP packets at once and within a single event handler.

'--------------------------------------------------------------------
syscall(226) sock.connect()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) causes the socket to attempt to connect to 
'the target host specified by the <font color="maroon"><b>sock.targetport</b></font> and <font color="maroon"><b>sock.targetip</b></font>
'(unless, for UDP, the socket is to broadcast the data- see the <font color="maroon"><b>sock.targetbcast </b></font> property).
'<br><br>
'Outgoing connection will be attempted through the network interface defined by the
'<font color="maroon"><b>sock.targetinterface </b></font>
'property.
'<br><br>
'Method invocation will have effect only if connection was closed at the time when the method was called (<font color="maroon"><b>sock.state
'</b></font> in one of <font color="olive"><b>PL_SST_CLOSED </b></font> states). 

'--------------------------------------------------------------------
syscall(227) sock.close()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) causes the socket to close the connection 
'with the other host. <br><br>
'For established TCP connections this will be a "graceful disconnect", if the TCP connection was in the "connection opening" or "connection
'closing" state this will be a reset (just like when the <font color="maroon"><b>sock.reset </b></font> method is used).<br><br>
'If connection was in the ARP phase or the transport protocol was UDP (<font color="maroon"><b>sock.protocol</b></font>= 0- 
'<font color="olive"><b>0- PL_SOCK_PROTOCOL_UDP</b></font>) the connection will be discarded (just like when the <font color="maroon"><b>
'sock.discard </b></font> method is used). <br><br>
'Method invocation will have NO effect if connection was closed at the time when the method was called (<font color="maroon"><b>sock.state
'</b></font>in one of <font color="olive"><b>PL_SST_CLOSED </b></font> states).

'--------------------------------------------------------------------
syscall(228) sock.reset()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) causes the socket to abort the connection with
'the other host. <br><br>
'For TCP connections that were established, being opened, or being closed this will be a reset (RST will be sent to the other end of the 
'connection).<br><br>
'If connection was in the ARP phase or the transport protocol was UDP (<font color="maroon"><b>sock.protocol</b></font>= <font color="olive">
'<b>0- PL_SOCK_PROTOCOL_UDP</b></font>) the connection will be discarded (just like when the <font color="maroon"><b>sock.discard </b></font>
'method is used). <br><br>
'Method invocation will have NO effect if connection was closed at the time when the method was called (<font color="maroon"><b>
'sock.state</b></font> in one of <font color="olive"><b>PL_SST_CLOSED </b></font> states). <br><br>
'See also <font color="maroon"><b>sock.close </b></font> method.

'--------------------------------------------------------------------
syscall(229) sock.discard()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) causes the socket to discard the connection 
'with the other host. Discarding the connection means simply forgetting about it without notifying the other side of the connection
'in any way. <br><br>
'See also <font color="maroon"><b>sock.close </b></font> and <font color="maroon"><b>sock.reset </b></font> methods.

'--------------------------------------------------------------------
syscall(89,"35.TDL") sock.rxbuffrq(numpages as byte) as byte
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) pre-requests "numpages" number of buffer pages
'(1 page= 256 bytes) for the RX buffer of the socket. Returns actual number of pages that can be allocated.<br><br>
'Actual allocation happens when the <font color="maroon"><b>sys.buffalloc </b></font> method is used. The socket is unable to RX data if its RX
'buffer has 0 capacity. Actual current buffer capacity can be checked through the <font color="maroon"><b>sock.rxbuffsize </b></font> which
'returns buffer capacity in bytes. Relationship between the two is as follows:<br><br>
'<font color="maroon"><b>sock.rxbuffsize</b></font>=num_pages*256-16 (or =0 when num_pages=0), where "num_pages" is the number of buffer pages
'that was GRANTED through the <font color="maroon"><b>sock.rxbuffrq</b></font>. "-16" is because 16 bytes are needed for internal buffer 
'variables.<br><br>
'Buffer allocation will not work if the socket to which this buffer belongs is not idle (<font color="maroon"><b>sock.statesimple</b></font><>
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>) at the time when <font color="maroon"><b>sys.buffalloc </b></font> executes. You can only change 
'buffer sizes of sockets that are closed.<br><br>
'See also <font color="maroon"><b>sock.txbuffrq </b></font> method.

'--------------------------------------------------------------------
syscall(90,"35.TDL") sock.txbuffrq(numpages as byte) as byte
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) pre-requests "numpages" number of buffer pages
'(1 page= 256 bytes) for the TX buffer of the socket. Returns actual number of pages that can be allocated.<br><bR>
'Actual allocation happens when the <font color="maroon"><b>sys.buffalloc </b></font>method is used. The socket is unable to TX data if its TX 
'buffer has 0 capacity. Actual current buffer capacity can be checked through the <font color="maroon"><b>sock.txbuffsize </b></font> which
'returns buffer capacity in bytes. Relationship between the two is as follows: <br><br>
'<font color="maroon"><b>sock.txbuffsize</b></font>=num_pages*256-16 (or =0 when num_pages=0), where "num_pages" is the number of buffer pages
'that was GRANTED through the <font color="maroon"><b>sock.txbuffrq</b></font>. "-16" is because 16 bytes are needed for internal buffer 
'variables.<br><br>
'Buffer allocation will not work if the socket to which this buffer belongs is not idle (<font color="maroon"><b>sock.statesimple</b></font><>
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>) at the time when <font color="maroon"><b>sys.buffalloc </b></font> executes. You can only change 
'buffer sizes of sockets that are closed.<br><br>
'See also <font color="maroon"><b>sock.tx2buffrq </b></font> method.

'--------------------------------------------------------------------
syscall(91,"35.TDL") sock.cmdbuffrq(numpages as byte) as byte
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) pre-requests "numpages" number of buffer pages
'(1 page= 256 bytes) for the CMD buffer of the socket; this is the buffer that accumulates incoming inband commands (messages). Returns actual 
'number of pages that can be allocated. <br><br>
'Actual allocation happens when the <font color="maroon"><b>sys.buffalloc </b></font> method is used. The socket is unable to receive inband
'commands if its CMD buffer has 0 capacity.<br><br>
'Unlike for TX or RX buffers there is no property to read out actual CMD buffer capacity in bytes. This capacity can be calculated as 
'num_pages*256-16 (or =0 when num_pages=0), where "num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>sock.cmdbuffrq</b></font>. 
'"-16" is because 16 bytes are needed for internal buffer variables.<br><br>
'Buffer allocation will not work if the socket to which this buffer belongs is not idle (<font color="maroon"><b>sock.statesimple</b></font><>
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>) at the time when <font color="maroon"><b>sys.buffalloc </b></font> executes. You can only change 
'buffer sizes of sockets that are closed.<br><br>
'See also <font color="maroon"><b>sock.rplbuffrq </b></font> method.

'--------------------------------------------------------------------
syscall(92,"35.TDL") sock.rplbuffrq(numpages as byte) as byte
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) pre-requests "numpages" number of buffer pages
'(1 page= 256 bytes) for the RPL buffer of the socket; this is the buffer that stores outgoing inband replies (messages). Returns actual number
'of pages that can be allocated.<br><br>
'Actual allocation happens when the <font color="maroon"><b>sys.buffalloc </b></font>method is used. The socket is unable to send inband replies
'if its RPL buffer has 0 capacity.<br><br>
'Unlike for TX or RX buffers there is no property to read out actual RPL buffer capacity in bytes. This capacity can be calculated as 
'num_pages*256-16 (or =0 when num_pages=0), where "num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon">
'<b>sock.rplbuffrq</b></font>. "-16" is because 16 bytes are needed for internal buffer variables.<br><br>
'Buffer allocation will not work if the socket to which this buffer belongs is not idle (<font color="maroon"><b>sock.statesimple</b></font><>
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>) at the time when <font color="maroon"><b>sys.buffalloc </b></font> executes. You can only change 
'buffer sizes of sockets that are closed.<br><br>
'See also <font color="maroon"><b>sock.cmdbuffrq </b></font> method.

'--------------------------------------------------------------------
syscall(93,"35.TDL") sock.varbuffrq(numpages as byte) as byte
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) pre-requests "numpages" number of buffer pages
'(1 page= 256 bytes) for the VAR buffer of the socket; this is the buffer that stores the HTTP request string. Returns actual number of pages 
'that can be allocated. <br><br>
'Actual allocation happens when the <font color="maroon"><b>sys.buffalloc </b></font> method is used. The socket is unable to receive HTTP 
'request string if its VAR buffer has 0 capacity. <br><br>
'Unlike for TX or RX buffers there is no property to read out actual VAR buffer capacity in bytes. This capacity can be calculated as 
'num_pages*256-16 (or =0 when num_pages=0), where "num_pages" is the number of buffer pages that was GRANTED through the sock.varbuffrq. 
'"-16" is because 16 bytes are needed for internal buffer variables.<br><br>
'Buffer allocation will not work if the socket to which this buffer belongs is not idle (<font color="maroon"><b>sock.statesimple</b></font><>
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>) at the time when <font color="maroon"><b>sys.buffalloc </b></font> executes. You can only change 
'buffer sizes of sockets that are closed.<br><br>
'The VAR buffer is only required when you plan to use this socket in the HTTP mode- see <font color="maroon"><b>sock.httpmode</b></font> 'roperty, also <font color="maroon"><b>sock.httpportlist</b></font>.

'--------------------------------------------------------------------
syscall(94,"35.TDL") sock.tx2buffrq(numpages as byte) as byte
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) pre-requests "numpages" number of buffer pages
'(1 page= 256 bytes) for the TX2 buffer of the socket; this buffer is required when inband commands are enabled (<font color="maroon"><b>
'sock.inbandcommands</b></font>= <font color="olive"><b>1- YES</b></font>), without it the socket won't be able to TX data. <br><br>
'Returns actual number of pages that can be allocated. Actual allocation happens when the <font color="maroon"><b>sys.buffalloc </b></font>
'method is used.<br><br>
'Unlike for TX or RX buffers there is no property to read out actual TX2 buffer capacity in bytes. This capacity can be calculated as 
'num_pages*256-16 (or =0 when num_pages=0), where "num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>
'sock.tx2buffrq</b></font>. "-16" is because 16 bytes are needed for internal buffer variables.<br><br>
'Buffer allocation will not work if the socket to which this buffer belongs is not idle (<font color="maroon"><b>sock.statesimple</b></font><>
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>) at the time when <font color="maroon"><b>sys.buffalloc </b></font> executes. You can only change 
'buffer sizes of sockets that are closed.<br><br>

'--------------------------------------------------------------------
syscall(81,"24.TDL") sock.redir(redir as pl_redir) as pl_redir
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) redirects the data being RXed to the TX buffer
'of the same socket, different socket, or another object that supports compatible buffers.<br><br>
'The redir argument, as well as the value returned by this method are of "<font color="olive"><b>enum pl_redir</b></font>" type. The 
'<font color="olive"><b>pl_redir </b></font>defines a set of inter-object constants that include all possible redirections for this platform.
'Specifying redir value of <font color="olive"><b>0- PL_REDIR_NONE </b></font> cancels redirection.<br><br>
'This method returns actual redirection result: <font color="olive"><b>0- PL_REDIR_NONE </b></font>if redirection failed or the
'same value as the one that was passed in the redir argument if redirection was successful.

'--------------------------------------------------------------------
property sock.inconenabledmaster
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 1- YES (incoming connections are globally enabled). </b><br><br>
'A master switch that globally defines whether incoming connections will be accepted: <font color="olive"><b>0- NO </b></font>(no socket will be
'allowed to accept an incoming connection), <font color="olive"><b>1- YES </b></font>(incoming connections are globally enabled; individual 
'socket's behavior and whether it will accept or reject a particular incoming connection depends on the setup of this socket).<br><br>
'This property can be used to temporarily disable incoming connection acceptance on all sockets without changing individual setup of each socket.
	get = syscall(186,"39.TDL"+) as no_yes
	set= syscall(225,"39.TDL"+) (value as no_yes)
end property

'--------------------------------------------------------------------
property sock.urlsubstitutes
'<b>PROPERTY (STRING), DEFAULT VALUE= "" (no substitutes set). </b><br><br>
'A comma-separated list of filenames whose extensions will be automatically substituted for <i>.html </i>by the internal webserver of your device.
'Max string length for this property is 40 bytes.
'<br><br>
'The substitution will be used only if the resource file with the requested file name is not included in the project directly.
'<br><br>
'For example, setting this property to <i>pix1.bmp </i>will force the webserver to actually process <i>pix1.html</i>, but only if the file
'<i>pix1.bmp </i>is not found.
'Data output by the webserver to the browser will still look like a <i>.bmp </i>file.
'For this to work, the <i>pix1.html </i>must exist in the project.
'<br><br>
'This property allows programmatic generation of non-HTML files. In the above example it is possible to generate the BMP file through a
'BASIC code. There is no other way to do this, since only HTML files are parsed for BASIC code inclusions.
	get = syscall(541) as string
	set= syscall(542) (byref value as string)
end property

'--------------------------------------------------------------------
property sock.sinkdata
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- NO (normal data processing). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>)
'specifies whether the incoming data should be discarded.
'<br><br>
'Setting this property to
'<font color="olive"><b>1- YES </b></font>
'causes the socket to automatically discard all incoming data without passing it to your application.
'<br><br>
'The <font color="teal"><b>on_sock_data_arrival </b></font>
'event will not be generated, reading
'<font color="maroon"><b>sock.rxlen </b></font>
'will always return zero, and so on. No data will be reaching its destination even in case of buffer redirection
'(see <font color="maroon"><b>sock.redir</b></font>).
'<br><br>
'Inband commands
'(see <font color="maroon"><b>sock.unband</b></font>)
'will still be extracted from the incoming data stream and processed.
'<font color="maroon"><b>Sock.connectiontout </b></font>and
'<font color="maroon"><b>sock.toutcounter </b></font>
'will work correctly as well. 
	get = syscall(3,"36.TDL"+) as no_yes
	set= syscall(4,"36.TDL"+) (value as no_yes)
end property

'--------------------------------------------------------------------
property sock.allowedinterfaces
'<b>PROPERTY (STRING), DEFAULT VALUE is platform-dependent.</b>
'<br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) defines the list of network interfaces on which
'this socket will accept incoming connections.
'<br><br>
'Interfaces that can be on the list are: "NET" (Ethernet), "WLN" (Wi-Fi), "PPP", and "PPPoE".
'The list of allowed interfaces is comma-delimited, i.e. "WLN,NET".
'<br><br>
'Note that reading back the value of this property may not necessarily return the items in the same order as they were set.
'For example, the application may write "WLN,NET" into this property, yet read "NET,WLN" back. Unsupported interface
'names will be dropped from the list automatically.
'<br><br>
'The list of interfaces supported by your platform can be checked through
'<font color="maroon"><b>sock.availableinterfaces</b></font>.
'Only interfaces from this list can be specified as "allowed". Trying to allow an unsopported interface will not work.
'<br><br>
'See also:
'<font color="maroon"><b>sock.targetinterface</b></font>,
'<font color="maroon"><b>sock.currentinterface</b></font>.
	get = syscall(532,"73.TDL"+) as string
	set = syscall(533,"73.TDL"+) (byref interface as string)
end property

'--------------------------------------------------------------------
property sock.availableinterfaces
'<b>R/O PROPERTY (WORD). </b><br><br>
'Returns the comma-delimited list of network interfaces available on this platform.
'<br><br>
'This list may possibly include: "NET" (Ethernet), "WLN" (Wi-Fi), "PPP", and "PPPoE".
'Different platforms support a different set of interfaces.
'<br><br>
'See also:
'<font color="maroon"><b>sock.targetinterface</b></font>,
'<font color="maroon"><b>sock.currentinterface</b></font>,
'<font color="maroon"><b>sock.allowedinterfaces</b></font>.
	get = syscall(557,"73.TDL"+) as string
end property

'--------------------------------------------------------------------
property sock.targetinterface
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 1- PL_SOCK_INTERFACE_NET</b>.
'<br><br>
'For the selected socket (selection is made through
'<font color="maroon"><b>sock.num</b></font>)
'selects the network interface through which an outgoing connection will be established.
'<br><br>
'The list of possible values reflects the set of interfaces available on the selected platform.
'There is always one extra item on the list -- NULL interface. As the name implies, this is not an empty interface.
'Connection cannot be made on it.
'<br><br>
'See also:
'<font color="maroon"><b>sock.availableinterfaces</b></font>,
'<font color="maroon"><b>sock.currentinterface</b></font>,
'<font color="maroon"><b>sock.allowedinterfaces</b></font>.
	get = syscall(530,"73.TDL"+) as pl_sock_interfaces
	set = syscall(531,"73.TDL"+) (interface as pl_sock_interfaces)
end property

'--------------------------------------------------------------------
property sock.currentinterface
'<b>R/O PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- PL_SOCK_INTERFACE_NULL</b>.
'<br><br>
'For the selected socket (selection is made through
'<font color="maroon"><b>sock.num</b></font>)
'returns the network interface this socket is currently communicating through.
'<br><br>
'The list of possible values reflects the set of interfaces available on the selected platform.
'There is always one extra item on the list -- NULL interface. It means that the socket hasn't been engaged in any connection yet.
'<br><br>
'The value of this property is only valid when the socket is not idle, i.e.
'<font color="maroon"><b>sock.statesimple </b></font>
'is not equal to
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>.
'<br><br>
'See also:
'<font color="maroon"><b>sock.availableinterfaces</b></font>,
'<font color="maroon"><b>sock.targetinterface</b></font>,
'<font color="maroon"><b>sock.allowedinterfaces</b></font>.
	get = syscall(534,"73.TDL"+) as pl_sock_interfaces
end property

'**************************************************************************************************
'		ROM (ROM file access) object
'**************************************************************************************************

object romfile
'The romfile object allows you to access resource (ROM) files that you have added to your project. Resource files appear in
'the "Resource Files" folder of your project tree. Resource files are not processed by the compiler in any way, they are just added
'to the compiled project binary "as is".
'<br><br>
'Resource files are ideal for storing permanent data that never changes.

'--------------------------------------------------------------------
syscall(53,"16.TDL") romfile.find(frompos as dword, byref substr as string, num as word) as word
'<b>METHOD. </b><br><br> 
'Locates the Nth occurrence of a substring within the currently opened resource (ROM) file.
'<br><br>
'Returns a <i>16-bit </i>value indicating the file position at which the specified occurrence of the substring was found or 0 if the specified occurrence wasn't found.
'If the specified occurrence was found at file position 65535 or higher, the value of 65535 will be returned.
'<br><br>
'<b>Frompos </b>-- starting search position in the file (1 to romfile.size).
'<br><br>
'<b>Substr </b>-- substring to search for.
'<br><br>
'<b>Num </b>-- substring occurrence to search for.
'<br><br>
'Bytes in the resource files are counted from 1.
'Use romfile.find32 if you are searching within a file larger than 65535 bytes. 

'--------------------------------------------------------------------
syscall(509,"16.TDL") romfile.find32(frompos as dword, byref substr as string, num as word) as dword
'<b>METHOD. </b><br><br> 
'Locates the Nth occurrence of a substring within the currently opened resource (ROM) file.
'<br><br>
'Returns a <i>32-bit </i>value indicating the file position at which the specified occurrence of the substring was found or 0 if the specified occurrence wasn't found.
'<br><br>
'<b>Frompos </b>-- starting search position in the file (1 to romfile.size).
'<br><br>
'<b>Substr </b>-- substring to search for.
'<br><br>
'<b>Num </b>-- substring occurrence to search for.
'<br><br>
'Bytes in the resource files are counted from 1.
'When searching inside files that do not exceed 65535 bytes, use romfile.find instead -- this will speed up your application.

'--------------------------------------------------------------------
syscall(57,"17.TDL") romfile.getdata(maxinplen as byte) as string
'<b>METHOD. </b><br><br> 
'Reads data from a currently opened resource (ROM) file.
'<br><br>
'<b>Maxinplen </b>-- maximum number of characters to read from the file.
'<br><br>
'The actual return string length is limited by three factors, whichever is smaller:
'the capacity of the receiving string, the amount of remaining data in the file (romfile.size+1-romfile.pointer),
'and the maxinplen argument.
'<br><br>
'Invoking this method moves the current pointer position forward by the actual number of bytes read.

'--------------------------------------------------------------------
property romfile.offset
'<b>R/O PROPERTY (DWORD)</b>.
'<br><br>
'For the currently opened resource (ROM) file returns the absolute file offset in the compiled project binary.
	get = syscall(61) as dword
end property

'--------------------------------------------------------------------
syscall(52,"15.TDL") romfile.open(byref filename as string)
'<b>METHOD. </b><br><br> 
'Opens or re-opens a resource (ROM) file.
'<br><br>
'<b>Filename </b>-- name of the resource file to open.
'<br><br>
'If the file exists and is not empty, the romfile.pointer and romfile.pointer32 properties are set to 1 (each time you (re)open the file).
'If the file doesn't exist or is empty, these two properties are set to 0.
'<br><br>
'There is no method (or need) to explicitly close resource files. Only one resource file can be opened at any given time.

'--------------------------------------------------------------------
property romfile.pointer
'<b>PROPERTY (WORD). </b><br><br>
'Sets/returns the current pointer position in the resource (ROM) file.
'<br><br>
'When the file is (re)opened with the romfile.open method,
'the pointer is reset to the first character of the file (position 1). If the file is not found or contains no data,
'the pointer is set to 0.
'<br><br>
'Pointer position cannot exceed romfile.size+1. When you read from the file with romfile.getdata, the pointer is automatically
'moved forward by the number of bytes that have been read out.
'<br><br>
'Since this property is of the <i>word </i>type, the maximum pointer value you can set with it is 65535.
'Reading the current pointer position with this property will return 65535 for all pointer positions from 65535 and up.
'To navigate within the files that exceed 65535 bytes, use romfile.pointer32 instead. 
	get = syscall(55) as word
	set = syscall(56) (value as word)
end property

'--------------------------------------------------------------------
property romfile.pointer32
'<b>PROPERTY (DWORD). </b><br><br>
'Sets/returns the current pointer position in the resource (ROM) file.
'<br><br>
'When the file is (re)opened with the romfile.open method,
'the pointer is reset to the first character of the file (position 1). If the file is not found or contains no data,
'the pointer is set to 0.
'<br><br>
'Pointer position cannot exceed romfile.size+1. When you read from the file with romfile.getdata, the pointer is automatically
'moved forward by the number of bytes that have been read out.
'<br><br>
'To navigate within files that do not exceed 65535 bytes, use romfile.pointer instead -- this will speed up your application. 

	get = syscall(507,"17.TDL"+) as dword
	set = syscall(508,"17.TDL"+) (value as dword)
end property

'--------------------------------------------------------------------
property romfile.size
'<b>R/O PROPERTY (DWORD). </b><br><br>
'Returns the size of the currently opened resource (ROM) file. Zero size is returned when the file does not exist or the
'file is empty.
	get = syscall(54) as dword
end property

'**************************************************************************************************
'		STOR (Storage system for "settings") object
'**************************************************************************************************

object stor
'The stor object provides access to the non-volatile (EEPROM) memory in which your application can store data that
'must not be lost when the device is switched off. <br><br>
'Using this object you can also access and change the MAC address of the device (be careful with that!). 

'--------------------------------------------------------------------
syscall(58,"18.TDL") stor.getdata(startaddr as word, len as byte) as string
'<b>METHOD. </b><br><br> 
'Reads up to len number of bytes from the EEPROM starting from address startaddr (addresses are counted from 1).
'Actual amount of extracted data is also limited by the capacity of the receiving variable and the starting address.<br><br>
'EEPROM memory capacity can be checked through the <font color="maroon"><b>stor.size </b></font>read-only property. Notice that when the 
'<font color="maroon"><b>stor.getdata </b></font>executes, an offset equal to the value of <font color="maroon"><b>stor.base </b></font>is 
'added to the startaddr. <br><br>
'For example, by default, the <font color="maroon"><b>stor.base </b></font>is 9. Therefore, if you do <font color="maroon"><b>
'stor.getdata</b></font>(1,3) you are actually reading the data starting from physical EEPROM location 9. First 8 bytes of EEPROM are used to
'store the MAC address. <br><br>
'If you set the <font color="maroon"><b>stor.base </b></font>to 1 you will be able to access the EEPROM right from the physical address 0 and
'change the MAC if necessary.<br><br>
'Note: MAC address stored in the EEPROM has a certain formatting- see platform documentation for details.

'--------------------------------------------------------------------
syscall (59,"19.TDL") stor.setdata(byref datatoset as string, startaddr as word) as byte
'<b>METHOD. </b><br><br> 
'Writes data from the datatoset string into the EEPROM, starting from the address startaddr (addresses are counted from 1). Returns actual 
'number of bytes written into the EEPROM. Hence, the operation has completed successfully if the value returned by this method equals the 
'length of the datatoset string. <br><br>
'If this is not the case then the write has (partially) failed and there may be two reasons for this: physical EEPROM failure or invalid
'startaddr (too close to the end of memory to save the entire string). <br><br>
'EEPROM memory capacity can be checked through the <font color="maroon"><b>stor.size </b></font>read-only property. Notice that when the 
'<font color="maroon"><b>stor.setdata </b></font>executes, an offset equal to the value of <font color="maroon"><b>stor.base </b></font>is 
'added to the startaddr. <br><br>
'For example, by default, the <font color="maroon"><b>stor.base </b></font>is 8. Therefore, if you do <font color="maroon"><b>
'stor.setdata</b></font>("ABC",1) you are actually saving the data starting from physical EEPROM location 9. First 8 bytes of EEPROM are 
'used to store the MAC address and this mechanism prevents your program from overriting it by mistake. <br><br>
'On the other hand, if you want to change MAC, set the <font color="maroon"><b>stor.base </b></font>to 1- this way you will be able to write 
'to EEPROM starting from physical address 1.<br><br>
'Note: if you change the MAC address this change will only take effect after device reboot. This is the only time when the device loads its MAC
'address from the EEPROM into the Ethernet controller. MAC address stored in the EEPROM has a certain formatting- see platform documentation for 
'details.

'--------------------------------------------------------------------
property stor.base
'<b>PROPERTY (WORD), DEFAULT VALUE= 8. </b><br><br>
'Returns the base address of the EEPROM from which the area available to your application starts. By default, the base address is 9 -- just 
'above the special configuration area that stores MAC address of the device (8 bytes are needed for that).<br><br>
'Default value of 9 makes sure that your application won't overwrite MAC by mistake. When you are accessing EEPROM memory using 
'<font color="maroon"><b>stor.setdata </b></font>or <font color="maroon"><b>stor.getdata </b></font>methods, you specify the start address.
'Actual physical address you access is start_address+<font color="maroon"><b>stor.base</b></font>. <br><br>
'If your application needs to change the MAC address you can set the <font color="maroon"><b>stor.base </b></font>to 1- this way you will have
'access to the entire memory.<br><br>
'Also see <font color="maroon"><b>stor.size</b></font>.
	get = syscall(181) as word
	set = syscall(182) (value as word)
end property

'--------------------------------------------------------------------
property stor.size
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= "actual_EEPROM_capacity-8" </b><br><br>
'Returns total EEPROM memory capacity (in bytes) for the current device. First 8 bytes of the EEPROM are used by the special configuration
'section (on this platform it occupies 8 bytes and stores MAC address of the device). By default, special configuration area is not accessible
'to the application and is excluded from memory capacity reported by <font color="maroon"><b>stor.size</b></font>.<br><br>
'For example, if the EEPROM capacity is 2048 bytes, the <font color="maroon"><b>stor.size </b></font>will return 2040 by default.
'At the same time, the default value of <font color="maroon"><b>stor.base </b></font>property will be  9, meaning that the EEPROM locations 1-8 
'are occupied by the special configuration area. <br><br>
'If you set the <font color="maroon"><b>stor.base </b></font>to 1 (for instance, to edit the MAC address), the <font color="maroon"><b>stor.size 
'</b></font>will show the capacity of 2048. In other words, the number this property returns is actual_EEPROM_capacity-
'<font color="maroon"><b>stor.base</b></font>+1.
	get = syscall(74) as word
end property

'**************************************************************************************************
'		PAT (Status LED patterns) object
'**************************************************************************************************

object pat
'The pat object allows you to "play" signal patters on up to five LED pairs, each pair consisting of a green and red LED.
'<br><br>
'The first channel (channel 0) is the primary channel of your system.
'It utilizes green and red status LEDs. All Tibbo devices have such LEDs (or LED control lines).
'Note that when your application is not running, the same LEDs are used by the system to display various status information. 
'<br><br>
'The remaining four channels (1-4) use regular I/O lines.
'Flexible mapping allows you to select which I/O lines will be used for LED control.

'--------------------------------------------------------------------
enum pl_pat_int 
	PL_PAT_NOINT,		'<b>PLATFORM CONSTANT. </b><br><br> Tells the <font color="maroon"><b>pat.play </b></font>method that the new
				'pattern can only be loaded if no pattern is playing at the moment (no interrupting of previous pattern).
	PL_PAT_CANINT		'<b>PLATFORM CONSTANT. </b><br><br> Tells the <font color="maroon"><b>pat.play </b></font>method that the new
				'pattern can be loaded even if another pattern is currently playing (previous pattern can be interrupted).
end enum

syscall(184,"31.TDL") pat.play(byref pattern as string, patint as pl_pat_int)
'<b>METHOD. </b><br><br> 
'Loads new LED pattern to play on the currently selected LED channel (selection is made through the
'<font color="maroon"><b>pat.channel</b></font>).
'<br><br>
'The pattern string defines the pattern to play, for example: "R-G-B", where '-'
'means "both red and green off", 'R' means red LED on, 'G' means green LED on, and 'B' means both LEDs on.
'Maximum pattern length is 16 "steps".
'<br><br>
'Additionally, '~' can be added to specify that the pattern should loop indefinitely (not just play once).
''*' can be used to make the pattern "play" at double speed, or quadruple speed ("**").
''~' and '*' can be added anywhere in the pattern string.
'<br><br>
'The second parameter defines whether the <font color="maroon"><b>pat.play </b></font>
'method is allowed to interrupt another pattern that is already playing: <font color="olive"><b>0- PL_PAT_NOINT </b></font>(cannot interrupt), 
'<font color="olive"><b>1-  PL_PAT_CANINT </b></font>(can interrupt). The <font color="teal"><b> on_pat event</b></font>
'is generated once the pattern finishes playing.	
'<br><br>
'Note that correct green and red line mapping must be specified for channels 1-4. Selected I/O lines must also be configured for output. See
'<font color="maroon"><b>pat.greenmap </b></font>and
'<font color="maroon"><b>pat.redmap </b></font>
'properties for details. Channel 0 operates on main status LEDs of the device. No mapping or configuration is required for this channel.

'--------------------------------------------------------------------
property pat.channel
'<b>PROPERTY (BYTE), DEFAULT VALUE= 0 (channel 0). </b><br><br>
'Selects/returns the LED channel (status LED pair) to work with.
'Channels are enumerated from 0. All other properties, methods, and an event of this object relate to the currently selected channel.
'Note that this property's value will be set automatically when the event handler for the
'<font color="teal"><b>on_pat </b></font> event is entered.
	get = syscall(5,"31.TDL"+) as byte
	set = syscall(6,"31.TDL"+) (value as byte)
end property

'--------------------------------------------------------------------
property pat.greenmap
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE: channel 0: (-1), R/0; channels 1-4: PL_IO_NULL.</b><br><br>
'For the selected LED channel (selection is made through the
'<font color="maroon"><b>pat.channel </b></font> property),
'sets/returns the number of the I/O line that will act as a green LED control line.
'<br><br>
'Channel 0 is special -- its LED control lines can't be remapped.
'This is because channel 0 uses standard green and red status LEDs (they are called SG and SR).
'For channel 0, reading the property always returns (-1), and writing has no effect.
'<br><br>
'All other channels use regular I/O lines.
'Any I/O line can be selected to be the green control line of the selected channel.
'Remap as needed and don't forget to configure the selected I/O line as an output -- this won't happen automatically.
'<br><br>
'See also: <font color="maroon"><b>pat.redmap </b></font> property.
	get = syscall(7,"31.TDL"+) as pl_io_num
	set = syscall(8,"31.TDL"+) (value as pl_io_num)
end property

'--------------------------------------------------------------------
property pat.redmap
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE: channel 0: (-1), R/0; channels 1-4: PL_IO_NULL.</b><br><br>
'For the selected LED channel (selection is made through the
'<font color="maroon"><b>pat.channel </b></font> property),
'sets/returns the number of the I/O line that will act as a red LED control line.
'<br><br>
'Channel 0 is special -- its LED control lines can't be remapped.
'This is because channel 0 uses standard green and red status LEDs (they are called SG and SR).
'For channel 0, reading the property always returns (-1), and writing has no effect.
'<br><br>
'All other channels use regular I/O lines.
'Any I/O line can be selected to be the red control line of the selected channel.
'Remap as needed and don't forget to configure the selected I/O line as an output -- this won't happen automatically.
'<br><br>
'See also: <font color="maroon"><b>pat.greenmap </b></font> property.
	get = syscall(9,"31.TDL"+) as pl_io_num
	set = syscall(10,"31.TDL"+) (value as pl_io_num)
end property


'**************************************************************************************************
'		BUTTON object
'**************************************************************************************************

object button
'All Tibbo devices have a setup button (or line for connecting such a button externally).
'This object allows you to monitor button state.
'<br><br>
'The button does not require any pre-configuration and works always.

'--------------------------------------------------------------------
property button.time
'<b>R/O PROPERTY (BYTE).</b><br><br>
'Returns the time (in 0.5 second intervals) elapsed since the button was last pressed or released (whichever happened) later.
'It only makes sense to read this property inside the <font color="teal"><b>on_button_pressed </b></font>or 
'<font color="teal"><b>on_button_released </b></font>event handlers.
'<br><br>
'Once the value of this property reaches 255 
'(127 seconds) it stays at 255 (there is no roll-over to 0). Elapsed time is not counted when the execution of your application is paused.
'<br><br>
'Note that button state detection employes "debouncing" which rejects very brief transitions of the button state.
	get = syscall(21) as byte
end property

'--------------------------------------------------------------------
property button.pressed
'<b>R/O PROPERTY (BYTE).</b><br><br>
'Returns the current button state. This reflects an immediate state of the hardware at the very moment the property is read --
'no "debouncing" performed. This is different from the
'<font color="teal"><b>on_button_pressed </b></font>and <font color="teal"><b>on_button_released </b></font>events, as well as the
'<font color="maroon"><b>button.time </b></font>
'R/O property, which all take debouncing into the account.
	get = syscall(1) as no_yes
end property

'**************************************************************************************************
'		PPP object
'**************************************************************************************************

object ppp
'The ppp object represents a ppp interface of your device (i.e. for accessing TCP/IP networks thru landline or GPRS modems).
'This object only specifies various parameters related to the ppp interface (such as the IP address) and is not responsible for
'sending/transmitting network data. The latter is the job of the sock object.

'--------------------------------------------------------------------
property ppp.enabled
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- NO (not enabled). </b><br><br>
'Enables/disables PPP interface on the serial port specified by the ppp.portnum property. 
'<br><br>
'Once this property is set to 1- YES, the selected serial port seizes to be under the control of your application and works exclusively for the ppp. object.
'PPP channel setup (ppp.buffrq, ppp.ip, ppp.portnum) can only be altered when the ppp. object is disabled.
	get = syscall(459,"39.TDL"+) as no_yes
	set = syscall(460,"39.TDL"+) (value as no_yes)
end property

'--------------------------------------------------------------------
property ppp.portnum
'<b>PROPERTY (BYTE), DEFAULT VALUE= 0 (serial port #0 selected). </b><br><br>
'Sets/returns the number of the serial port that will be used by the ppp. object.
'<br><br>
'Once the PPP interface is enabled (ppp.enabled= 1- YES), the selected serial port seizes to be under the control of your application and works exclusively for the ppp. object.
'The value of this property won't exceed ser.numofports-1 (even if you attempt to set a higher value).
'You can only change this property when the PPP channel is disabled (ppp.enabled= 0- NO).
	get = syscall(461,"39.TDL"+) as byte
	set = syscall(462,"39.TDL"+) (value as byte)
end property

'--------------------------------------------------------------------
syscall(371,"35.TDL") ppp.buffrq(numpages as byte) as byte
'<b>METHOD.</b>
'<br><br>
'Pre-requests "numpages" number of buffer pages (1 page= 256 bytes) for the buffer of the ppp object.
'<br><br>
'This method returns the actual number of pages that can be allocated.
'Actual allocation happens when the sys.buffalloc method is used.
'<br><br>
'The PPP object will be unable to operate properly if its buffer has inadequate capacity. Recommented buffer size is 5 pages.
'<br><br>
'The buffer can only be allocated when the PPP channel is not enabled (ppp.enabled= 0- NO).
'Executing sys.buffalloc while ppp.enabled= 1- YES will leave the buffer size unchanged.
'<br><br>
'The actual current buffer size can be verified through the ppp.buffsize read-only property.

'--------------------------------------------------------------------
property ppp.buffsize
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0 (0 bytes).</b>
'<br><br>
'Returns the current capacity (in bytes) of the ppp. object's buffer.
'<br><br>
'Buffer capacity can be changed through the ppp.buffrq method followed by the sys.buffalloc method invocation.
'<br><br>
'The PPP object will be unable to operate properly if its buffer has inadequate capacity. Recommended buffer size is 5 pages.
	get = syscall(355,"57.TDL"+) as word
end property

'--------------------------------------------------------------------
property ppp.ip
'<b>PROPERTY (STRING), DEFAULT VALUE= "1.0.0.1". </b><br><br>
'Sets/returns the IP address of the PPP interface of your device. <br><br>
'<br><br>
'Typically, the IP address of the PPP interface is negotiated with the ISP. Available GPRS library implements all necessary steps of PPP link negotiation for GPRS modems.
'<br><br>
'This property can only be written to when the PPP interface is disabled (ppp.enabled= 0- NO).
	get = syscall(490,"39.TDL"+) as string
	set = syscall(491,"40.TDL"+) (byref ipstr as string)
end property
